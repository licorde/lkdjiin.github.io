<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : ruby | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-09-04T11:31:14+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Générer un fichier Changelog avec Git]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/04/generer-un-fichier-changelog-avec-git/"/>
    <updated>2013-09-04T11:23:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/04/generer-un-fichier-changelog-avec-git</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p><em>J'ai écrit un script pour Git qui permet de produire un fichier</em>
changelog
<em>en html ou en markdown à partir des commits.</em></p>

<!-- more -->


<p>Dans un
<a href="http://lkdjiin.github.io/blog/2013/07/18/comment-etendre-git-avec-ses-propres-scripts-la-suite/">article précédent</a>
j'ai montré comment étendre Git avec un script pour créer ses propres
commandes. Aujourd'hui je vous présente mon script <code>git-changelog</code>.
Vous pouvez le trouver sur
<a href="https://github.com/lkdjiin/git-changelog">Github</a>.</p>

<p>Il s'agit d'un script Ruby qui ajoute une commande <code>changelog</code> à Git.
Il est utile pour automatiser (ou semi-automatiser) la production du
fichier changelog. Il peut produire des fichiers au format HTML ou au
format Markdown.</p>

<p>Pour l'installer, il faut mettre le fichier <code>git-changelog</code> quelque part
dans votre PATH, après l'avoir téléchargé.</p>

<h2>Utilisation</h2>

<p>Sortie sur la console:</p>

<pre><code>git changelog
</code></pre>

<p>Sortie dans un fichier:</p>

<pre><code>git changelog &gt; changelog.markdown
</code></pre>

<p>Le script accepte l'option <code>--since</code>. C'est la même option qu'utilise la
commande <code>git log</code>:</p>

<pre><code>git changelog --since=2013-07-01
git changelog --since=10.days
</code></pre>

<p>Sortie au format HTML:</p>

<pre><code>git changelog --html
</code></pre>

<p>Un exemple de combinaison:</p>

<pre><code>git changelog --html --since=2013-05-27 &gt; changelog.html
</code></pre>

<h2>Un exemple</h2>

<p>Voici ce que produit <code>git-changelog</code>:</p>

<pre><code>2013-07-18 Version 0.2.1  
==========================
* 2013-07-18 Fix bug for markdown format  
  Html entities are now escaped.
* 2013-07-18 Fix bug with markdown format  
  Commit body now start on a new line.
* 2013-07-18 Add auto-generated changelog file  

2013-07-18 Version 0.2.0  
==========================
* 2013-07-18 Add html format output  
  A new --html option outputs a &amp;lt;ul&amp;gt;.
* 2013-07-17 First commit  
  The script outputs in markdown and accept the option '--since'.
</code></pre>

<p>Et voilà ce que ça donne (avec le style de ce blog):</p>

<h1>2013-07-18 Version 0.2.1  </h1>

<ul>
<li>2013-07-18 Fix bug for markdown format<br/>
Html entities are now escaped.</li>
<li>2013-07-18 Fix bug with markdown format<br/>
Commit body now start on a new line.</li>
<li>2013-07-18 Add auto-generated changelog file</li>
</ul>


<h1>2013-07-18 Version 0.2.0  </h1>

<ul>
<li>2013-07-18 Add html format output<br/>
A new &mdash;html option outputs a &lt;ul&gt;.</li>
<li>2013-07-17 First commit<br/>
The script outputs in markdown and accept the option &lsquo;&mdash;since&rsquo;.</li>
</ul>


<h2>Rake task</h2>

<p>Voici un exemple de <em>rake task</em> pour une gem Ruby:</p>

<p><code>ruby
desc "Generate the changelog"
task :changelog do
  system "git changelog &gt; Changelog.markdown"
end
</code></p>

<p>Et un exemple pour un projet Rails:</p>

<p><code>ruby lib/tasks/changelog.rake
desc "Generate the changelog in html"
task :changelog do
  system "git changelog --html &gt; app/views/pages/_changelog.html"
end
</code></p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 5]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/03/les-algorithmes-genetiques-demystifies-5/"/>
    <updated>2013-09-03T08:43:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/03/les-algorithmes-genetiques-demystifies-5</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Maintenant qu'on sait créer une population de solutions, l'évaluer,
opérer une sélection des meilleures solutions et obtenir une nouvelle
génération par la reproduction, il reste à assembler toutes ces parties
et voir ce qu'il se passe…</p>

<!-- more -->


<p>Voici le code complet de notre algorithme:</p>

<p>``` ruby
def make_chromosome
  value = &ldquo;&rdquo;
  48.times { value += rand(0..1).to_s }
  [nil, value]
end</p>

<p>def make_population
  population = []
  100.times { population &lt;&lt; make_chromosome }
  population
end</p>

<p>def chromosome_to_gene(chromosome)
  chromosome.last.scan /.{4}/
end</p>

<p>def gene_to_operand(gene)
  case gene
  when &ldquo;0000&rdquo; then 0
  when &ldquo;0001&rdquo; then 1
  when &ldquo;0010&rdquo; then 2
  when &ldquo;0011&rdquo; then 3
  when &ldquo;0100&rdquo; then 4
  when &ldquo;0101&rdquo; then 5
  when &ldquo;0110&rdquo; then 6
  when &ldquo;0111&rdquo; then 7
  when &ldquo;1000&rdquo; then 8
  when &ldquo;1001&rdquo; then 9
  when &ldquo;1010&rdquo; then &ldquo;+&rdquo;
  when &ldquo;1011&rdquo; then &ldquo;&ndash;&rdquo;
  when &ldquo;1100&rdquo; then &ldquo;/&rdquo;
  when &ldquo;1101&rdquo; then &ldquo;%&rdquo;
  end
end</p>

<p>def selection
  @selected = @population[0&hellip;50].shuffle
end</p>

<p>def genes_to_formula(genes)
  formula = []
  genes.each {|gene| formula &lt;&lt; gene_to_operand(gene) }
  formula.join
end</p>

<p>def evaluation(genes)
  formula = genes_to_formula(genes)
  begin</p>

<pre><code>result = (@search_value - eval(formula)).abs
</code></pre>

<p>  rescue Exception</p>

<pre><code>result = 999_999_999_999
</code></pre>

<p>  end
  result = 999_999_999_999 unless result.is_a?(Integer)
  result
end</p>

<p>def score_population
  @population = @population.map do |individual|</p>

<pre><code>genes = chromosome_to_gene(individual)
individual[0] = evaluation(genes)
individual
</code></pre>

<p>  end
end</p>

<p>def crossover(parent1, parent2)
  point = rand(1..47)
  child1 = [nil, parent1.last[0&hellip;point] + parent2.last[point..-1]]
  child2 = [nil, parent2.last[0&hellip;point] + parent1.last[point..-1]]
  [child1, child2]
end</p>

<p>def next_generation
  @selection = selection
  @population = []
  25.times do</p>

<pre><code>parent1, parent2 = @selection.slice!(0, 2)
child1, child2 = crossover(parent1, parent2)
child3, child4 = crossover(parent1, parent2)
@population += [child1, child2, child3, child4]
</code></pre>

<p>  end
end</p>

<h1>Ce qui suit est nouveau:</h1>

<p>@search_value = 987
@population = make_population</p>

<p>50.times do |generation|
  score_population
  @population = @population.sort
  best = @population.first.first
  puts &ldquo;Generation: #{generation} Best: #{best}&rdquo;
  exit if best == 0
  next_generation
end
```</p>

<p>Seules les dernières lignes de code sont nouvelles. Elles sont assez
simple à comprendre je pense, même si vous ne connaissez pas le
langage Ruby. On commence par définir le nombre qu'on recherche puis
on crée la population d'origine au hasard avec <code>@population = make_population</code>.
Ensuite on itère sur 50 générations avec <code>50.times do |generation|</code>. C'est
notre première condition de sortie : quoiqu'il se passe, on arrête le
traitement au bout à la 50ème génération. Dans cette boucle on évalue
la génération en cours avec <code>score_population</code> et on la trie. Pour savoir
où on en est visuellement on extrait le meilleur score avec
<code>best = @population.first.first</code> et on affiche cette information à la ligne
suivante. Vient ensuite notre seconde et dernière condition de sortie avec
<code>exit if best == 0</code> ; autrement dit on stoppe le traitement à la première
solution trouvée. Pour finir, on produit la génération suivante avec
<code>next_generation</code>.</p>

<h2>Et ça donne quoi ?</h2>

<p>La plupart du temps ça donne quelque chose comme ça:</p>

<p><code>console
[~/genetic]⇒ ruby test.rb
Generation: 0 Best: 507
Generation: 1 Best: 138
Generation: 2 Best: 485
Generation: 3 Best: 347
Generation: 4 Best: 65
Generation: 5 Best: 208
Generation: 6 Best: 222
Generation: 7 Best: 15
Generation: 8 Best: 15
Generation: 9 Best: 2
Generation: 10 Best: 0
</code></p>

<p>Les générations successives convergent lentement vers la solution.
Si vous voulez voir la solution trouvée (c'est normal d'être curieux)
vous pouvez remplacez une ligne de code pour afficher la solution:</p>

<p>``` ruby</p>

<h1>exit if best == 0</h1>

<p>if best == 0
  genes = chromosome_to_gene(@population.first)
  puts &ldquo;Formula: #{genes_to_formula(genes)}&rdquo;
  exit
end
```</p>

<p>Voici quelques exemples de solutions:</p>

<pre><code>Formula: 912%429+933
Formula: 670+594-277
Formula: 893+91%96+3
Formula: 923--03--61
</code></pre>

<p>Alors, la plupart du temps, ça se passe bien. Mais parfois un phénomène
étrange se produit:</p>

<p><code>console
[~/genetic]⇒ ruby test.rb
Generation: 0 Best: 597
Generation: 1 Best: 621
Generation: 2 Best: 104
...
Generation: 25 Best: 1
...
Generation: 48 Best: 1
Generation: 49 Best: 1
[~/genetic]⇒
</code></p>

<p>L'algorithme reste <em>bloqué</em> sur une valeur et on atteint la 50ème
génération sans avoir trouver de solution. What the fuck ? Et bien
l'algorithme a atteint ce qu'on appelle
<a href="http://fr.wikipedia.org/wiki/Extremum_local">l'extremum local</a>. Pour faire
court, ça signifie qu'il ne peut pas faire mieux
avec les gènes dont il disposait à l'origine. Je developperais cette
idée dans un futur article. En attendant, comment on règle ça ?
En s'inspirant encore une fois de phénomènes naturels : la mutation
et/ou la diversité génétique.
C'est le sujet du prochain article.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 4]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/02/les-algorithmes-genetiques-demystifies-4/"/>
    <updated>2013-09-02T08:26:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/02/les-algorithmes-genetiques-demystifies-4</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Après en avoir terminer avec la création de la population et la sélection,
on passe à la reproduction.</p>

<!-- more -->


<p>Pour imiter ce qu'il se passe dans la nature, de manière fort simple,
on va définir une fonction <code>crossover</code> (croisé, croisement) qui prend
en entrée deux chromosomes, les parents, et qui produit en sortie une liste
de deux autres chromosomes, les enfants. Le principe est de couper chaque
chromosomes parents en deux parties A et B, puis d'assembler la partie A
du parent 1 avec la partie B du parent 2 et vice-versa. Voici une illustration
du processus avec des chromosomes de 8 bits (symbolisés par des lettres):</p>

<pre><code>parent1  aaabbbbb
parent2  xxxyyyyy

enfant1  aaayyyyy
enfant2  xxxbbbbb
</code></pre>

<p>Voici donc la fonction:</p>

<p><code>ruby
def crossover(parent1, parent2)
  point = rand(1..47)
  child1 = [nil, parent1.last[0...point] + parent2.last[point..-1]]
  child2 = [nil, parent2.last[0...point] + parent1.last[point..-1]]
  [child1, child2]
end
</code></p>

<p>Tout d'abord on défini le point de croisement avec <code>point = rand(1..47)</code>.
Puis on assemble les deux chromosomes enfants et on les renvoient sous
la forme d'une liste. Ce mode de reproduction est le plus simple, mais
pas forcement le plus efficace (on en reparle un autre jour).</p>

<p>On a maintenant tout ce qu'il faut pour produire la génération suivante:</p>

<p>``` ruby
def next_generation
  @selection = selection
  @population = []
  25.times do</p>

<pre><code>parent1, parent2 = @selection.slice!(0, 2)
child1, child2 = crossover(parent1, parent2)
child3, child4 = crossover(parent1, parent2)
@population += [child1, child2, child3, child4]
</code></pre>

<p>  end
end
```</p>

<p>Après avoir sélectionné les 50 meilleures solutions (voir
<a href="http://lkdjiin.github.io/blog/2013/08/30/les-algorithmes-genetiques-demystifies-3/">article précédent</a>) je crée une nouvelle population : Avec 50
individus on forme 25 couples qui vont chacun produire 4 enfants et
on retrouve une population de 100 solutions, sensée être globalement
meilleure que la génération précédente.</p>

<p>Même si c'est peu représentatif des phénomènes naturels, dans un algorithme
génétique les générations successives restent généralement stable en taille.
Ça évite aussi bien la croissance infinie (mémoire des ordinateurs limitée)
que le dépérissement de la population.</p>

<p>La prochaine fois on assemblera le tout pour voir notre algorithme
génétique à l'oeuvre.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un langage sur Parrot - partie 13]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/01/un-langage-sur-parrot-partie-13/"/>
    <updated>2013-09-01T21:02:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/01/un-langage-sur-parrot-partie-13</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Après avoir utilisé un AST pour représenter le code source de Naam,
je parcours cet AST pour sortir le code assembleur PIR pour la machine
virtuelle Parrot.</p>

<!-- more -->


<p>Voici la méthode principale (et temporaire):</p>

<p>``` ruby
def self.run(filename)
  .
  .
  .
  syntaxer = Syntaxer.new
  ast = syntaxer.run(units.dup)</p>

<p>  organizer = Organizer.new(ast)
  ast = organizer.reorganize</p>

<p>  emitter = Emitter.new(ast)
  pir_code = emitter.pir_code
  puts pir_code
end
```</p>

<p>La classe Syntaxer se charge de transformer la suite d'unités lexicales
en un arbre syntaxique abstrait (AST). La classe Organizer va en
quelque sorte réorganiser l'arbre, par exemple en regroupant les instructions
qui ne sont pas dans une fonction à l'intérieur d'une fonction principale
PIR.
Quant à la classe Emitter, elle est chargée de transformer l'AST en code PIR.</p>

<p>Voici un extrait de cette classe Emitter:</p>

<p>``` ruby
module Naam
  class Emitter</p>

<pre><code>def initialize(ast)
  @ast = ast.dup
  @code = ""
  @label = "LABEL0000"
  @labels = []
end

# Public: Get PIR code.
#
# Returns PIR code as a String.
def pir_code
  compile(@ast)
  @code
end

private

def compile(node)
  case node
  when MainAST then compile_main(node)
  when FunctionHeaderAST then compile_header(node)
  when IfClauseAST then compile_if_clause(node)
  when ElseClauseAST then compile_else_clause(node)
  when FunctionFooterAST then compile_footer(node)
  end
  node.children.each {|child| compile(child) }
end

...

def compile_header(node)
  name = node.children.first.value
  arg = node.children.last.value
  @code += ".sub #{name}\n"
  @code += "    .param int #{arg}\n"
  @code += "    .local int result\n"
end

...

# Get the next label.
#
# value - The String value attached to the label.
#
# Examples
#
#   next_label
#   # =&gt; {name: "LABEL0001", value: "123"}.
#
# Returns a Hash.
def next_label(value)
  label = {name: @label.next!.dup, value: value}
  @labels &lt;&lt; label
  label
end
</code></pre>

<p>  end
end
```</p>

<p>La prochaine fois, le compilateur sera fonctionnel.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un langage sur Parrot - partie 12]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/31/un-langage-sur-parrot-partie-12/"/>
    <updated>2013-08-31T11:02:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/31/un-langage-sur-parrot-partie-12</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Dans le dernier épisode, j'utilisais un AST pour capturer la grammaire
de Naam, et le code n'était pas très propre. Cette fois je nettoie un peu
tout ça en mettant les règles de grammaire dans leur propres classes.</p>

<!-- more -->


<p>De ce fait, le syntaxer a beaucoup maigri puisqu'il se contente
maintenant de lancer la première règle:</p>

<p>``` ruby
module Naam</p>

<p>  # Public: Here we transform a list of lexical units in an AST.
  class Syntaxer</p>

<pre><code>def initialize
  @ast = AST.new "ast"
end

# Public: Compile lexical units from a Naam program in an AST.
#
# units - Array of LexicalUnits
#
# Returns the AST.
def run units
  ProgramRule.new(units, @ast).apply!
  @ast
end
</code></pre>

<p>  end
end
```</p>

<p>Voici la règle de base:</p>

<p>``` ruby
module Naam
  class BaseRule</p>

<pre><code>def initialize(units, ast_node)
  @units = units
  @ast_node = ast_node
  @series = []
end

def apply!
  raise NotImplementedError
end

private

def accept(type, value = '')
  unit = @units.slice!(0)
  @series &lt;&lt; unit
  raise Error unless unit.type == type
  if value != ''
    raise Error unless unit.value == value
  end
end

def accept_series(*args)
  args.each {|arg| accept(arg) }
end
</code></pre>

<p>  end
end
```</p>

<p>Reste à écrire une classe par règle de grammaire. Voici par exemple la
règle pour la <code>else clause</code>:</p>

<p>``` ruby
module Naam
  class ElseClauseRule &lt; BaseRule</p>

<pre><code>def apply!
  accept(:int)
  accept(:keyword, 'else')
  accept(:eol)
  else_node = ElseClauseAST.new
  else_node.add_child(ReturnValueAST.new(@series[0].value))
  @ast_node.add_child(else_node)
end
</code></pre>

<p>  end
end
```</p>

<p>La prochaine étape sera de sortir le code PIR à partir de l'AST.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
