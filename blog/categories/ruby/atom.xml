<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : ruby | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-10-03T10:59:31+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby: un exemple de valeur par défaut pour un Hash]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/03/ruby-un-exemple-de-valeur-par-defaut-pour-un-hash/"/>
    <updated>2013-10-03T10:52:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/03/ruby-un-exemple-de-valeur-par-defaut-pour-un-hash</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>J'oublie régulièrement qu'un Hash peut renvoyer une valeur par défaut.
Du coup, je me retrouve souvent avec un code inutilement lourd.
Aujourd'hui je montre un exemple d'initialisation d'un Hash avec une
valeur par défaut et pourquoi c'est intéressant.</p>

<!-- more -->


<p>Dans <a href="http://lkdjiin.github.io/blog/2013/10/02/les-algorithmes-genetiques-demystifies-27/">l'article d'hier</a>
(sur les algorithmes génétiques) je donnais un script de trois lignes sans
fournir d'explications, les voici.</p>

<h2>L'objectif</h2>

<p>J'ai un fichier (&ldquo;mots.txt&rdquo;) contenant un certain nombre de mots pouvant
apparaitre plusieurs fois:</p>

<pre><code>casserole
casserole
assiette
fourchette
casserole
fourchette
verre
...
</code></pre>

<p>Je veux connaitre le nombre d'occurence de chaque mot et produire une sortie
de ce genre:</p>

<pre><code>187 =&gt; casserole
 13 =&gt; assiette
  2 =&gt; fourchette
  1 =&gt; verre
</code></pre>

<h2>La classe Hash expliquée en 30 secondes</h2>

<p><em>Si vous savez déjà ce qu'est un hash, passez directement à la section
suivante.</em></p>

<p>Un <em>hash</em> peut contenir un nombre indeterminé de paires d'objets ; ces paires
étants organisées en clé/valeur. Ça marche comme un dictionnaire. Dans
d'autres langages, vous les connaissez peut-être sous le nom de dict, map,
tableau associatif, hashtable, etc. En Ruby, on peut créer un hash vide de
deux façons:</p>

<p><code>ruby
hash = {}
autre_hash = Hash.new
</code></p>

<p>On peut créer et remplir un hash en même temps:</p>

<p><code>ruby
hash = { "clef1" =&gt; 123, "clef2" =&gt; 456 }
</code></p>

<p>Pour connaitre la valeur associée à la clé &ldquo;clef1&rdquo;:</p>

<p><code>ruby
hash["clef1"]
</code></p>

<p>Pour modifier la valeur associée à la clé &ldquo;clef1&rdquo;:</p>

<p><code>ruby
hash["clef1"] = 0
</code></p>

<p>Pour ajouter une paire clé/valeur:</p>

<p><code>ruby
hash["nouvelle clef"] = 123546789
</code></p>

<p>Notez que les clés et leurs valeurs peuvent être de n'importe quel type.
On n'est pas limité à des chaînes de caractères et des nombres.</p>

<h2>Première version</h2>

<p>Mon premier jet a donné ceci:</p>

<p>``` ruby</p>

<h1>Version 1</h1>

<p>hash = Hash.new</p>

<p>File.open(&ldquo;mots.txt&rdquo;, &ldquo;r&rdquo;).each_line do |line|
  if hash.key?(line)</p>

<pre><code>hash[line] = hash[line] + 1
</code></pre>

<p>  else</p>

<pre><code>hash[line] = 1
</code></pre>

<p>  end
end</p>

<p>hash.each {|key, value| puts &ldquo;#{&rdquo;%3d" % value} => #{key}&ldquo; }
```</p>

<p>La première ligne crée un hash vide tandis que la dernière affiche
le contenu du hash, formaté comme je le veux. Au milieu, on itère sur
les lignes du fichier texte (les mots) pour remplir le hash,
c'est ça qui m'intéresse:</p>

<p>``` ruby
  if hash.key?(line)</p>

<pre><code>hash[line] = hash[line] + 1
</code></pre>

<p>  else</p>

<pre><code>hash[line] = 1
</code></pre>

<p>  end
```</p>

<p>C'est une construction classique à base de if/else. Si le hash possède
une clé identique à la ligne en cours (<code>if hash.key?(line)</code>) alors on
incrémente sa valeur associée. Sinon on crée cette clé, associée à la
valeur 1 puisque c'est la première fois qu'on rencontre ce mot
(<code>hash[line] = 1</code>).</p>

<h2>Deuxième version</h2>

<p>Ruby possède un opérateur ternaire (<em>ternary operator</em>) qui peut remplacer
un if/else simple comme le notre:</p>

<pre><code>condition ? oui : non
</code></pre>

<p>Si <code>condition</code> est vérifiée, on execute <code>oui</code>, sinon on execute <code>non</code>.
Dans notre cas on peut donc écrire:</p>

<p><code>ruby
File.open("mots.txt", "r").each_line do |line|
  hash[line] = hash.key?(line) ? hash[line] + 1 : 1
end
</code></p>

<p>Certains adorent ce genre de construction, d'autres détestent. <em>À priori</em> je
n'ai rien contre, mais il faut avouer que dans ce cas précis c'est tout
simplement illisible.</p>

<h2>Troisième version</h2>

<p>Ruby possède un opérateur sympa qu'on peut parfois utiliser quand on veut
initialiser une variable si elle n'existe pas où la modifier si elle
existe: <code>||=</code>. Il faut savoir qu'un hash renvoie la valeur <code>nil</code> quand on
lui fournit une clé inexistante:</p>

<p><code>ruby
File.open("result.txt", "r").each_line do |line|
  hash[line] ||= 0
  hash[line] += 1
end
</code></p>

<p><code>hash[line] ||= 0</code> va créer la clé et lui donner la valeur 0 si cette clé
n'existe pas, sinon la clé se voit affecter sa valeur. Ensuite la valeur de
la clé est incrémentée avec <code>hash[line] += 1</code>. Je trouve cela plus lisible
que la version avec l'opérateur ternaire, mais moins lisible que la version
avec le if/else, car cela fait appel à un «truc».</p>

<h2>Quatrième et dernière version</h2>

<p>Voici la <em>bonne</em> version (selon moi bien entendu). Il faut modifier
légerement la création du hash:</p>

<p><code>ruby
hash = Hash.new(0)
File.open("result.txt", "r").each_line do |line|
  hash[line] += 1
end
</code></p>

<p>Quand vous créer un hash, vous pouvez lui dire: «Je veux que tu renvois
telle valeur quand on te donne une clé inexistante». Dans notre cas, les
clés inexistantes renverront toujours zéro. Le tour est joué: une simple
incrémentation suffit maintenant, qu'une clé existe déjà ou non.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 27]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/02/les-algorithmes-genetiques-demystifies-27/"/>
    <updated>2013-10-02T12:06:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/02/les-algorithmes-genetiques-demystifies-27</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Maintenant qu'on a vu ce qu'était <em>en théorie</em> un extremum local, on
regarde <em>en pratique</em> comment il se manifeste dans les algorithmes
génétiques.</p>

<!-- more -->


<h2>Comment un extremum local se manifeste dans les algorithmes génétiques ?</h2>

<p>On va reprendre le <a href="http://lkdjiin.github.io/blog/2013/09/27/les-algorithmes-genetiques-demystifies-24/">dernier code</a>
sur le problème des 8 dames et modifier deux ou trois petites choses.
D'abord on s'assure d'avoir des soucis en passant la taille de l'échiquier
à 16, et on réduit le nombre de générations pour ne pas avoir à attendre
trop longtemps, 200 semble un bon compromis:</p>

<p><code>ruby
generations = 200
board_size = 16
</code></p>

<p>Puis on modifie la méthode <code>run</code> de la classe <code>GeneticAlgorithm</code> de cette
manière:</p>

<p>``` ruby
def run
  @generations.times do |generation|</p>

<pre><code>Evaluator.new(@board_size, @population).evaluate
best = @population.best
# display(generation, best)
if best.score &gt; 1.0
  best.display
  exit
end
next_generation
</code></pre>

<p>  end
  @population.each {|individual| p individual.chromosome }
end
```</p>

<p>La nouveauté est la ligne suivante:</p>

<p><code>ruby
  @population.each {|individual| p individual.chromosome }
</code></p>

<p>Ainsi, au bout de 200 générations, on affiche la liste des chromosomes.
Pour ceux qui ne connaisse pas Ruby, <code>p x</code> est un raccourci pour
<code>puts x.inspect</code>.</p>

<p>J'ai aussi pris soin de commenter la ligne <code>display(generation, best)</code>
pour pouvoir enregistrer plus tard le résultat dans un fichier sans que
celui-ci soit pollué par des données inutiles.</p>

<p>Quand on lance le programme, on obtient quelque chose comme ça:</p>

<pre><code>[~/genetic]⇒ ruby 8_queens.rb
[10, 8, 5, 11, 2, 0, 15, 6, 9, 13, 1, 4, 14, 7, 14, 3]
[10, 8, 5, 11, 2, 0, 15, 6, 9, 13, 1, 4, 14, 7, 11, 3]
[10, 8, 5, 11, 2, 0, 15, 12, 9, 13, 1, 4, 14, 7, 14, 3]
[10, 8, 5, 11, 2, 0, 15, 6, 9, 13, 1, 4, 14, 7, 11, 3]
[10, 8, 5, 11, 2, 0, 15, 6, 9, 13, 1, 4, 14, 7, 14, 3]
...
</code></pre>

<p>Les chromosomes sont tous identiques, ou presque ! Pour savoir à quel
point ils sont identiques, on peut les compter à la main (!?) où écrire
un petit script de trois lignes:</p>

<p><code>ruby 8_queens_stat.rb
hash = Hash.new(0)
File.open(ARGV.first, "r").each_line {|line| hash[line] += 1 }
hash.each {|key, value| puts "#{"%3d" % value} =&gt; #{key}" }
</code></p>

<p>L'explication de ce script dépasse le cadre de cet article, l'objectif
étant de savoir combien de chromosomes sont identiques. Pour cela on
refait tourner notre algorithme génétique en enregistrant le résultat
(c'est à dire la liste des chromosomes après 200 générations) dans un
fichier:</p>

<pre><code>[~/genetic]⇒ ruby 8_queens.rb &gt; result.txt
</code></pre>

<p>Puis on fait travailler notre script sur ce fichier:</p>

<pre><code>[~/genetic]⇒ ruby 8_queens_stat.rb result.txt
971 =&gt; [1, 7, 13, 11, 9, 15, 5, 14, 2, 0, 8, 6, 12, 10, 2, 4]
  1 =&gt; [1, 7, 2, 11, 9, 15, 5, 14, 2, 0, 8, 6, 12, 10, 2, 4]
  1 =&gt; [1, 7, 13, 11, 9, 15, 5, 8, 2, 0, 8, 6, 12, 10, 2, 4]
  1 =&gt; [1, 7, 13, 11, 9, 15, 5, 14, 2, 12, 8, 6, 12, 10, 2, 4]
  1 =&gt; [1, 7, 13, 11, 9, 15, 5, 14, 2, 0, 8, 6, 12, 10, 2, 0]
  2 =&gt; [1, 7, 13, 11, 9, 15, 5, 14, 9, 0, 8, 6, 12, 10, 2, 4]
  1 =&gt; [1, 13, 13, 11, 9, 15, 5, 14, 2, 0, 8, 6, 12, 10, 2, 4]
  3 =&gt; [1, 7, 13, 11, 9, 15, 5, 14, 2, 0, 8, 6, 12, 10, 2, 6]
  8 =&gt; [3, 7, 13, 11, 9, 15, 5, 14, 2, 0, 8, 6, 12, 10, 2, 4]
  1 =&gt; [1, 7, 13, 2, 9, 15, 5, 14, 2, 0, 8, 6, 12, 10, 2, 4]
  1 =&gt; [1, 7, 13, 11, 9, 15, 5, 14, 2, 0, 8, 6, 12, 10, 2, 14]
  1 =&gt; [1, 7, 13, 11, 9, 15, 5, 14, 2, 0, 8, 6, 12, 10, 3, 4]
  1 =&gt; [1, 7, 13, 3, 9, 15, 5, 14, 2, 0, 8, 6, 12, 10, 2, 4]
  1 =&gt; [1, 7, 13, 11, 9, 15, 5, 14, 2, 0, 8, 6, 12, 5, 2, 4]
  1 =&gt; [1, 7, 13, 11, 9, 15, 5, 14, 2, 0, 8, 6, 13, 10, 2, 4]
  1 =&gt; [1, 7, 14, 11, 9, 15, 5, 14, 2, 0, 8, 6, 12, 10, 2, 4]
  1 =&gt; [1, 3, 13, 11, 9, 15, 5, 14, 2, 0, 8, 6, 12, 10, 2, 4]
  2 =&gt; [1, 7, 13, 11, 4, 15, 5, 14, 2, 0, 8, 6, 12, 10, 2, 4]
  1 =&gt; [1, 7, 13, 11, 9, 15, 5, 14, 2, 0, 8, 6, 12, 14, 2, 4]
</code></pre>

<p>971 chromosomes sur 1000 sont identiques ! Question diversité génétique
on repassera… Voilà donc comment un extremum local se manifeste dans
un algorithme génétique: toutes les solutions convergent vers un même
point. L'algorithme ne peut plus produire de nouvelles solutions originales,
il patauge. Les quelques chromosomes différents, 29 sur 1000 dans ce cas là
(ou encore 2,9%) s'expliquent en grande partie par la mutation.</p>

<p>Si vous étudiez en détail le résultat ci-dessus, vous verrez que chaque
chromosome différent ne diffère du chromosome majoritaire que par un
seul de ses gènes. C'est la clé pour comprendre pourquoi la mutation
semble impuissante à nous aider dans ce problème des 8 dames, alors que
tout avait bien fonctionné avec le paradoxe du singe savant. On verra
ça dans le prochain article.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby: Les méthodes du module Kernel 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/29/ruby-les-methodes-du-module-kernel-3/"/>
    <updated>2013-09-29T12:51:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/29/ruby-les-methodes-du-module-kernel-3</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Aujourd'hui c'est dimanche, l'article sera court, on voit deux méthodes
utiles pour le débugage ou pour les fichiers
de log: <code>__method__</code> et <code>__dir__</code>.</p>

<!-- more -->


<h2><code>__method__</code></h2>

<p><code>__method__</code> renvoit le nom de la méthode courante comme un type Symbol:</p>

<p>``` irb</p>

<blockquote><blockquote><p>def foo
<strong>method</strong>
end
nil
foo
:foo
```</p></blockquote></blockquote>

<p>Et si vous avez besoin de récupérer une chaîne de caractère:</p>

<p>``` irb</p>

<blockquote><blockquote><p>def bar
<strong>method</strong>.to_s
end
nil
bar
&ldquo;bar&rdquo;
```</p></blockquote></blockquote>

<h2><code>__dir__</code></h2>

<p>Comme son nom l'indique presque, cette méthode renvoit le nom (complet)
du répértoire du fichier dans lequel la méthode est appelée:</p>

<p>``` ruby ~/test/dir.rb
def this_dir
  <strong>dir</strong>
end</p>

<p>puts this_dir
```</p>

<pre><code>[~/test]⇒ rvm use 2.0.0
Using /home/xavier/.rvm/gems/ruby-2.0.0-p247
[~/test]⇒ ruby dir.rb 
/home/xavier/test
</code></pre>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby: Les méthodes du module Kernel 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/28/ruby-les-methodes-du-module-kernel-2/"/>
    <updated>2013-09-28T13:59:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/28/ruby-les-methodes-du-module-kernel-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>On continue l'exploration du module Kernel avec quatre
autres méthodes de conversions, pour les nombres:</p>

<ul>
<li>Complex</li>
<li>Float</li>
<li>Integer</li>
<li>Rational</li>
</ul>


<!-- more -->


<p>Voyons d'abord <code>Integer</code>. On peut lui passer une chaîne de caractère:</p>

<p>``` irb</p>

<blockquote><blockquote><p>Integer(&ldquo;123&rdquo;)
123
```</p></blockquote></blockquote>

<p>Ça fonctionne avec les préfixes. En octal, hexadécimal et binaire:</p>

<p>``` irb</p>

<blockquote><blockquote><p>Integer(&ldquo;0123&rdquo;)
83
Integer(&ldquo;0x123&rdquo;)
291
Integer(&ldquo;0b111&rdquo;)
7
```</p></blockquote></blockquote>

<p>On peut aussi spécifier la base:</p>

<p>``` irb</p>

<blockquote><blockquote><p>Integer(&ldquo;0123&rdquo;, 10)
123
```</p></blockquote></blockquote>

<p>On peut aussi passer en argument un objet répondant à <code>to_int</code> ou <code>to_i</code>:</p>

<p>``` irb</p>

<blockquote><blockquote><p>class Foo
  def to_i</p>

<pre><code>123
</code></pre>

<p>  end
end
nil
Integer(Foo.new)
123
```</p></blockquote></blockquote>

<p>Passons maintenant à <code>Float(arg)</code> qui convertit un argument en type <code>Float</code>.
Soit l'argument est de type <code>Numeric</code>:</p>

<p>``` irb</p>

<blockquote><blockquote><p>Float(123)
123.0
Float(Rational(&ldquo;&frac12;&rdquo;))
0.5
```</p></blockquote></blockquote>

<p>Soit la méthode fait appel à <code>to_f</code>:</p>

<p>``` irb</p>

<blockquote><blockquote><p>class Foo
  def to_f</p>

<pre><code>1.23
</code></pre>

<p>  end
end
nil
Float(Foo.new)
1.23
```</p></blockquote></blockquote>

<p>Au tour de la méthode <code>Rational</code> qui convertit son (ses) argument(s) en un
nombre rationnel (de classe <code>Rational</code>), autrement dit une fraction:</p>

<p>``` irb</p>

<blockquote><blockquote><p>Rational(&ldquo;1/3&rdquo;)
1/3
Rational(1, 3)
1/3
x = Rational(&ldquo;1/3&rdquo;)
1/3
x + x
2/3
```</p></blockquote></blockquote>

<p>Reste la méthode <code>Complex</code>, qui convertit son (ses) argument(s) en un nombre
complexe. Je la signale pour être exhaustif, mais les nombres complexes
dépassent largement mes compétences en mathématique.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 24]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/27/les-algorithmes-genetiques-demystifies-24/"/>
    <updated>2013-09-27T18:26:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/27/les-algorithmes-genetiques-demystifies-24</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Maintenant vous connaissez bien la procédure : on trouve comment représenter
les chromosomes, comment les évaluer, puis une fois la population
initialisée on sélectionne, on croise, on mute…</p>

<!-- more -->


<p>Dernièrement on s'est occupé des chromosomes, de l'évaluation et de la
population. Reste à sélectionner, croiser, muter.
Je ne vais pas trop m'étendre sur le code permettant de faire ceci puisqu'il
s'agit pratiquement d'un copier/coller des classes développées
précédement. Voici le code permettant de résoudre le problème des
8 dames:</p>

<p>``` ruby 8_queens.rb
class Individual
  def self.random(chromosome_size)</p>

<pre><code>new(nil, chromosome_size)
</code></pre>

<p>  end</p>

<p>  def self.from_chromosome(chromosome)</p>

<pre><code>new(chromosome)
</code></pre>

<p>  end</p>

<p>  def display</p>

<pre><code>@chromosome.each do |queen_position|
  row = ""
  @chromosome.size.times do |cell|
    row += (cell == queen_position) ? "Q" : "."
  end
  puts row
end
</code></pre>

<p>  end</p>

<p>  attr_accessor :score, :fitness
  attr_reader :chromosome</p>

<p>  def initialize(chromosome = nil, chromosome_size = nil)</p>

<pre><code>if chromosome
  @chromosome = chromosome
else
  @chromosome = []
  chromosome_size.times { @chromosome &lt;&lt; Gene.random(chromosome_size) }
end
</code></pre>

<p>  end
  private_class_method :new
end</p>

<p>class Gene
  def self.random(limit)</p>

<pre><code>rand(limit)
</code></pre>

<p>  end
end</p>

<p>class Population &lt; Array
  def initialize(chromosome_size, population_size)</p>

<pre><code>population_size.times { self &lt;&lt; Individual.random(chromosome_size) }
</code></pre>

<p>  end</p>

<p>  def best</p>

<pre><code>self.sort_by{|individual| individual.score}.last
</code></pre>

<p>  end
end</p>

<p>class Evaluator
  def initialize(board_size, population)</p>

<pre><code>@board_size = board_size
@population = population
</code></pre>

<p>  end</p>

<p>  def evaluate</p>

<pre><code>@population.each {|individual| score(individual) }
fitness
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def score(individual)</p>

<pre><code>individual.score = 1.0 / conflicts(individual)
</code></pre>

<p>  end</p>

<p>  def conflicts(individual)</p>

<pre><code>board = individual.chromosome
score = 0
@board_size.times do |row1|
  gene1 = board[row1]
  (row1+1...@board_size).each do |row2|
    gene2 = board[row2]
    score += 1 if gene1 == gene2
    score += 1 if row2 - row1 == (gene1 - gene2).abs
  end
end
score
</code></pre>

<p>  end</p>

<p>  def fitness</p>

<pre><code>total = @population.inject(0) {|sum, individual| sum + individual.score }
@population.each do |individual|
  individual.fitness = individual.score.to_f / total * @population.size
end
</code></pre>

<p>  end
end</p>

<p>class GeneticAlgorithm
  def initialize(generations, population, board_size, mutation_rate)</p>

<pre><code>@generations = generations
@population = population
@board_size = board_size
@mutation_rate = mutation_rate
@crossover = Crossover.new(board_size, mutation_rate)
</code></pre>

<p>  end</p>

<p>  def run</p>

<pre><code>@generations.times do |generation|
  Evaluator.new(@board_size, @population).evaluate
  best = @population.best
  display(generation, best)
  if best.score &gt; 1.0
    best.display
    exit
  end
  next_generation
end
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def display(generation, best)</p>

<pre><code>puts "----------------------"
puts "Gen: #{generation}"
puts "Best: #{best.score}"
</code></pre>

<p>  end</p>

<p>  def next_generation</p>

<pre><code>pool = MatingPool.new(@population)
population_size = @population.size
@population.clear
population_size.times do
  @population &lt;&lt; @crossover.two_point(pool.random, pool.random)
end
</code></pre>

<p>  end
end</p>

<p>class MatingPool
  def initialize(population)</p>

<pre><code>@mating_pool = []
population.each do |individual|
  integer_part = individual.fitness.to_i
  real_part = individual.fitness - integer_part
  integer_part.times { @mating_pool &lt;&lt; individual.dup }
  @mating_pool &lt;&lt; individual.dup if rand &lt; real_part
end
@size = @mating_pool.size
</code></pre>

<p>  end</p>

<p>  def random</p>

<pre><code>@mating_pool[rand(@size)]
</code></pre>

<p>  end
end</p>

<p>class Crossover
  def initialize(chromosome_size, mutation_rate)</p>

<pre><code>@size = chromosome_size
@rate = mutation_rate
@mutator = Mutator.new(@size, @rate)
</code></pre>

<p>  end</p>

<p>  def two_point(parent1, parent2)</p>

<pre><code>child = assemble(parent1, parent2, two_cut_points)
child = @mutator.mutate(child)
Individual.from_chromosome(child)
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def two_cut_points</p>

<pre><code>point1 = cut_point
point2 = cut_point
point1, point2 = point2, point1 if point1 &gt; point2
[point1, point2]
</code></pre>

<p>  end</p>

<p>  def cut_point</p>

<pre><code>rand(@size)
</code></pre>

<p>  end</p>

<p>  def assemble(parent1, parent2, points)</p>

<pre><code>point1, point2 = points
parent1.chromosome[0...point1] + 
  parent2.chromosome[point1..point2] +
  parent1.chromosome[point2+1..-1]
</code></pre>

<p>  end
end</p>

<p>class Mutator
  def initialize(chromosome_size, mutation_rate)</p>

<pre><code>@size = chromosome_size
@rate = mutation_rate
</code></pre>

<p>  end</p>

<p>  def mutate(chromosome)</p>

<pre><code>@size.times do |index|
  if rand &lt; @rate
    chromosome[index] = Gene.random(@size)
  end
end
chromosome
</code></pre>

<p>  end
end</p>

<p>generations = 500
board_size = 8
population = Population.new(board_size, 1000)
mutation = 0.001
GeneticAlgorithm.new(generations, population, board_size, mutation).run
```</p>

<p>J'ai seulement ajouter une méthode <code>display</code> à la classe <code>Individual</code> pour
afficher à l'écran une représentation de la solution. Voilà le programme
en marche:</p>

<pre><code>[~/genetic]⇒ ruby 8_queens.rb 
----------------------
Gen: 0
Best: 0.5
----------------------
Gen: 1
Best: 0.5
.
.
.
Gen: 11
Best: 1.0
----------------------
Gen: 12
Best: Infinity
.......Q
.Q......
...Q....
Q.......
......Q.
....Q...
..Q.....
.....Q..
</code></pre>

<p>Cool ! Une solution en 12 générations. J'ai écrit récemment que trouver
une solution pour un échiquier de 8 x 8 cases ne serait pas difficile.
Et bien voilà, c'est fait. J'ai écrit aussi qu'il serait plus intéressant de
voir ce qu'il se passe avec des plateaux plus grands. Si on essaye en
doublant les dimensions:</p>

<p><code>ruby
board_size = 16
</code></p>

<p>On aura de grandes chances de voir ce type de sortie:</p>

<pre><code>[~/genetic]⇒ ruby 8_queens.rb 
----------------------
Gen: 0
Best: 0.125
----------------------
Gen: 1
Best: 0.16666666666666666
.
.
.
Gen: 70
Best: 0.5
----------------------
Gen: 71
Best: 1.0
.
.
.
----------------------
Gen: 499
Best: 1.0
</code></pre>

<p>Plus de 400 générations coincées sur le même résultat. Vous pensiez en
avoir fini avec les extremums locaux ? Et ben non, ils ne sont jamais
bien loin. 3 questions:</p>

<ol>
<li>Comment je sais que l'algorithme est coinçé dans un extremum local ?</li>
<li>Pourquoi cet algorithme coinçe alors qu'il est écrit comme le
précédent qui lui, ne coinçait pas ?</li>
<li>Comment on s'en sort ?</li>
</ol>


<p>Avant de répondre à cela, je pense qu'il est plus que temps d'expliquer
quelques petites choses sur les extremums locaux:</p>

<ol>
<li>Qu'est ce que c'est qu'un extremum local ?</li>
<li>Comment un extremum local se manifeste dans les algorithmes génétiques ?</li>
</ol>


<p>J'ai mon sujet pour le prochain article…</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
