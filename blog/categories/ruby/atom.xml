<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : ruby | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-09-26T18:24:39+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 23]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/26/les-algorithmes-genetiques-demystifies-23/"/>
    <updated>2013-09-26T18:19:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/26/les-algorithmes-genetiques-demystifies-23</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Pour évaluer une solution potentielle dans le problème des 8 dames, on va
devoir calculer le nombre de paires de dames qui sont en conflit (en prise,
pour les joueurs d'échecs).</p>

<!-- more -->


<p>Dans <a href="http://lkdjiin.github.io/blog/2013/09/25/les-algorithmes-genetiques-demystifies-22/">l'article précédent</a>
on a mis en place la classe <code>Evaluator</code>, mais il manquait une partie
déterminante: le calcul du nombre de conflits. Le voici:</p>

<p>``` ruby
  def conflicts(individual)</p>

<pre><code>board = individual.chromosome
score = 0
@board_size.times do |row1|
  gene1 = board[row1]
  (row1+1...@board_size).each do |row2|
    gene2 = board[row2]
    score += 1 if gene1 == gene2
    score += 1 if row2 - row1 == (gene1 - gene2).abs
  end
end
score
</code></pre>

<p>  end
```</p>

<p>Je ne suis pas très satisfait de cette méthode, elle est assez imposante
(trop longue) et difficile à lire (pas claire). Néanmoins elle fait son
travail et c'est ce qui compte pour l'instant. Je ferais peut-être du
refactoring plus tard (ou bien c'est un lecteur charitable qui va nous
le faire ?). Une explication s'impose:</p>

<p>``` ruby</p>

<pre><code>@board_size.times do |row1|
  gene1 = board[row1]
</code></pre>

<p>```</p>

<p>On a une première itération sur chaque rangées. Dans chaque boucle, la variable
<code>gene1</code> reçoit la position de la dame de cette rangée, c'est à dire
le numéro de la colonne (base 0). On va ensuite
comparer cette dame avec les dames des rangées suivantes:</p>

<p>``` ruby</p>

<pre><code>  (row1+1...@board_size).each do |row2|
    gene2 = board[row2]
</code></pre>

<p>```</p>

<p>Dans cette seconde itération, <code>gene2</code> reçoit successivement les positions
de chaque dames restantes. On peut maintenant regarder si deux dames sont
dans la même colonne:</p>

<p>``` ruby</p>

<pre><code>    score += 1 if gene1 == gene2
</code></pre>

<p>```</p>

<p>Ça se passe de commentaire… Pour savoir si deux dames sont sur une
même diagonale, c'est un peu plus tordu:</p>

<p>``` ruby</p>

<pre><code>    score += 1 if row2 - row1 == (gene1 - gene2).abs
</code></pre>

<p>```</p>

<p>Je vois un peu ça comme un problème de géométrie. Si deux dames ont le
même écart en nombre de colonnes et en nombre de rangées, c'est qu'elles
partagent la même diagonale.</p>

<p>Cet article n'était pas vraiment orienté algorithme génétique mais je pense
qu'il était pourtant nécessaire. Si on a pas une bonne fonction d'évaluation,
un algorithme génétique n'est d'aucune aide. C'est pour ça que la première
chose que je fais quand j'aborde un nouveau problème c'est de réfléchir au
combo évaluation/chromosome jusqu'à en avoir une vision claire.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 22]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/25/les-algorithmes-genetiques-demystifies-22/"/>
    <updated>2013-09-25T14:22:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/25/les-algorithmes-genetiques-demystifies-22</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Après avoir trouver comment représenter un chromosome pour le
problème des 8 dames (<a href="http://lkdjiin.github.io/blog/2013/09/24/les-algorithmes-genetiques-demystifies-21-probleme-des-8-dames/">article précédent</a>),
on regarde aujourd'hui comment réaliser l'évaluation de la population.</p>

<!-- more -->


<p>Sans plus attendre, voici la classe <code>Evaluator</code> dans toute sa
splendeur, on la détaille après:</p>

<p>``` ruby
class Evaluator
  def initialize(board_size, population)</p>

<pre><code>@board_size = board_size
@population = population
</code></pre>

<p>  end</p>

<p>  def evaluate</p>

<pre><code>@population.each {|individual| score(individual) }
fitness
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def score(individual)</p>

<pre><code>individual.score = 1.0 / conflicts(individual)
</code></pre>

<p>  end</p>

<p>  def conflicts(individual)</p>

<pre><code># Calcule et renvoie le nombre de paires de dames en conflits.
</code></pre>

<p>  end</p>

<p>  def fitness</p>

<pre><code>total = @population.inject(0) {|sum, individual| sum + individual.score }
@population.each do |individual|
  individual.fitness = individual.score.to_f / total * @population.size
end
</code></pre>

<p>  end
end
```</p>

<p>Tout d'abord le constucteur:</p>

<p><code>ruby
  def initialize(board_size, population)
</code></p>

<p>Il prends comme paramêtre la taille de l'échiquier et la population à
évaluer. Trouver une solution pour un échiquier de 8 x 8 cases ne
devrait pas être trop difficile et il sera plus intéressant de voir
comment l'algorithme se débrouille avec des échiquiers de plus grande
taille.</p>

<p>La méthode <code>evalute</code> est identique à celle de la
<a href="http://lkdjiin.github.io/blog/2013/09/19/les-algorithmes-genetiques-demystifies-18/">dernière fois</a>:
elle calcule le <em>score</em> puis le <em>fitness</em> de chaque individu.</p>

<p>Passons à la méthode <code>conflicts</code>, qui n'est pas encore implémentée:</p>

<p>``` ruby
  def conflicts(individual)</p>

<pre><code># Calcule et renvoie le nombre de paires de dames en conflits.
</code></pre>

<p>  end
```</p>

<p>C'est en calculant le nombre de paires de dames en conflits qu'on pourra
évaluer les différentes positions. Plus il y a de conflits, plus on est
loin d'une solution. À l'inverse, une solution possède zéro conflits.
L'implémentation sera pour la prochaine fois.</p>

<p>Voyons maintenant la méthode <code>score</code>:</p>

<p>``` ruby
  def score(individual)</p>

<pre><code>individual.score = 1.0 / conflicts(individual)
</code></pre>

<p>  end
```</p>

<p>Pourquoi diviser 1 par le nombre de conflits ? Pourquoi ne pas avoir écrit
simplement <code>individual.score = conflicts(individual)</code> ?
Parce que je ne trouve pas naturel qu'un score de zéro soit meilleur qu'un
score de 5, 10, 20, etc. Je préfère donc calculer l'inverse du nombre de
conflits. De cette manière si il y a 10 conflits, le score sera 0,1 et si il
y a 2 conflits le score sera 0,5. Et si il y a zéro conflits ? Ruby ne pose
pas de problème avec les nombres réèls:</p>

<p>``` irb
[~]⇒ irb</p>

<blockquote><blockquote><p>1.0 / 0
Infinity
```</p></blockquote></blockquote>

<p>Je saurais donc que j'ai trouvé une solution quand un score sera supérieur
à 1. Avec d'autres langages on peut gérer ça avec des exceptions, des erreurs,
détecter la division par zéro avant de la faire, etc. Ou encore ajouter
une petite valeur au nombre de conflits, par exemple:</p>

<pre><code>score = 1.0 / (nombre_de_conflits + 0.1)
</code></pre>

<p>La prochaine fois on verra comment calculer le nombre de conflits.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 21: Problème des 8 dames]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/24/les-algorithmes-genetiques-demystifies-21-probleme-des-8-dames/"/>
    <updated>2013-09-24T10:04:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/24/les-algorithmes-genetiques-demystifies-21-probleme-des-8-dames</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>On va tenter de résoudre le problème des 8 dames à l'aide d'un algorithme
génétique.</p>

<p><blockquote><p>Le but du problème des huit dames est de placer huit dames d'un jeu d'échecs sur un échiquier de 8 × 8 cases sans que les dames ne puissent se menacer mutuellement, conformément aux règles du jeu d'échecs (la couleur des pièces étant ignorée). Par conséquent, deux dames ne devraient jamais partager la même rangée, colonne, ou diagonale.</p><footer><strong>Wikipédia <a href="http://fr.wikipedia.org/wiki/Probl%C3%A8me_des_huit_dames">http://fr.wikipedia.org/wiki/Probl%C3%A8me_des_huit_dames</a></strong></footer></blockquote></p>

<!-- more -->


<p>Avant toute chose, il faut trouver comment nos chromosomes vont pouvoir
représenter une solution potentielle. On pourrait coder ça sous forme
d'une chaîne de 64 bits, un par case, les 0 étants des cases vides et
les 1 étants les cases occupées par les dames. On pourrait aussi les coder
comme un tableau à deux dimensions, soit 8 rangées multipliées par 8 colonnes.
En y regardant de plus près (ou simplement en relisant la définition du
problème), on remarque que pour qu'une solution soit
viable, il faut une seule dame par rangée, une seule par colonne et une
seule par diagonale. On peut donc se contenter d'une liste (un tableau) de
8 nombres entiers, ces nombres étants le numéro de la colonne. Ainsi, pour
un échiquier de 4 x 4 cases, la liste <code>[0, 2, 3, 3]</code> équivaut à la position
suivante:</p>

<pre><code>---------
|D| | | |
---------
| | |D| |
---------
| | | |D|
---------
| | | |D|
---------
</code></pre>

<p>Maintenant on peut s'occuper de la population. Je vais me servir du code
objet développé dans les derniers articles, en essayant de le modifier
le moins possible.</p>

<p>``` ruby
class Individual
  def self.random(chromosome_size)</p>

<pre><code>new(nil, chromosome_size)
</code></pre>

<p>  end</p>

<p>  def self.from_chromosome(chromosome)</p>

<pre><code>new(chromosome)
</code></pre>

<p>  end</p>

<p>  attr_accessor :score, :fitness
  attr_reader :chromosome</p>

<p>  def initialize(chromosome = nil, chromosome_size = nil)</p>

<pre><code>if chromosome
  @chromosome = chromosome
else
  @chromosome = []
  chromosome_size.times { @chromosome &lt;&lt; Gene.random(chromosome_size) }
end
</code></pre>

<p>  end
  private_class_method :new
end</p>

<p>class Gene
  def self.random(limit)</p>

<pre><code>rand(limit)
</code></pre>

<p>  end
end</p>

<p>class Population &lt; Array
  def initialize(chromosome_size, population_size)</p>

<pre><code>population_size.times { self &lt;&lt; Individual.random(chromosome_size) }
</code></pre>

<p>  end</p>

<p>  def best</p>

<pre><code>self.sort_by{|individual| individual.score}.last
</code></pre>

<p>  end
end
```</p>

<p>J'ai été obligé de modifier la méthode <code>initialize</code> de la classe <code>Individual</code>
ainsi que la classe <code>Gene</code>. Il faudra en tenir compte si on veut qu'un
framework sorte de tout ça…</p>

<p>Le prochain article traitera de l'évaluation du problème des 8 dames.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 20]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/23/les-algorithmes-genetiques-demystifies-20/"/>
    <updated>2013-09-23T18:41:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/23/les-algorithmes-genetiques-demystifies-20</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>C'est le vingtième article de cette série sur les algorithmes génétiques et
j'aimerai en profiter pour dresser un petit bilan provisoire.</p>

<!-- more -->


<p>On a vu le fonctionnement d'un algorithme génétique à l'aide de deux exemples
simples. Dans le premier exemple il s'agissait de trouver une expression comme
«123+54x3» et dans le second il fallait trouver la chaîne «Mon royaume pour un
cheval».</p>

<p>On a appris à représenter une population d'individus. Chaque individu étant une
solution potentielle du problême posé. Cette solution est codée dans le
chromosome d'un individu. On a vu l'utilisation «historique» d'une chaîne de
bits pour réprésenter les chromosomes, mais aussi qu'on pouvait utiliser une
chaîne de caractères quelconques. En fait, il ne faut pas hésiter à représenter
les chromosomes comme bon vous semble.</p>

<p>On a vu ensuite la phase d'évaluation de la population. Il s'agit d'abord
d'évaluer un chromosome seul en lui affectant un score, puis de l'évaluer par
rapport aux autres chromosomes, en lui affectant un <em>fitness</em> (aptitude).  Le
fitness permettant d'être plus fin lors de l'étape de sélection.</p>

<p>Pour l'étape de la sélection, nous avons vu deux manières de faire :
l'élitisme et la roue de la fortune. L'élitisme consiste à ne conserver
qu'un pourcentage des meilleurs spécimens d'une génération. La roue de la
fortune consiste à donner à chaque individu une chance plus ou moins
grande de se reproduire en rapport avec son <em>fitness</em>.</p>

<p>Nous avons fait se reproduire les individus/solutions selectionnés par
croisement de leurs chromosomes. À partir de deux parents, nous avons
obtenu un ou deux enfants. On a utilisé la méthode du croisement en
un point, du croisement en deux points et du croisement uniforme.</p>

<p>Enfin, la mutation (ou l'apport de matériel génétique inédit d'une façon ou d'une
autre) a joué un rôle déterminant pour éviter à nos algorithmes de tomber dans
un extremum local.</p>

<p>En résumé, on a abordé pas mal de choses. Mais ce n'est que la surface
de l'iceberg.</p>

<p>Pour les articles à venir, je pense me pencher sur le
<a href="http://fr.wikipedia.org/wiki/Probl%C3%A8me_des_huit_dames">problème des 8 dames</a>.
Ça permettra de voir une autre façon de coder un chromosome et aussi de
confronter les classes développées dans les derniers articles à un
problème bien différent. Ensuite, j'aimerais résoudre un problème visuel.
Du genre : «Si je dispose de 1000 carrés de taille et de couleur quelconque,
quelle est la meilleure disposition pour s'approcher au mieux d'une
image donnée ?». C'est typiquement le genre de problème qui pourrait
tourner dans les navigateurs et être codé en Javascript. Avez-vous
d'autres idées/envies pour la suite ?</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby: Les méthodes du module Kernel]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/21/ruby-les-methodes-du-module-kernel/"/>
    <updated>2013-09-21T13:53:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/21/ruby-les-methodes-du-module-kernel</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Les méthodes définies dans le module Kernel de Ruby sont <em>à priori</em> des
méthodes très importantes. En effet le module Kernel est inclus d'office
dans la classe Object, et donc, ses méthodes sont toujours disponibles.
Elles s'utilisent directement sous la forme <code>method_name</code> et non pas
<code>object_name.method_name</code>. C'est cette différence de traitement qui
me donne à penser qu'elles sont importantes. Dans cette série d'articles,
je me propose de passer en revue chacune des méthodes du module Kernel
de Ruby version 2.0.</p>

<!-- more -->


<p>Aujourd'hui on voit les méthodes suivantes:</p>

<ul>
<li>Array(<em>arg</em>)</li>
<li>Hash(<em>arg</em>)</li>
<li>String(<em>arg</em>)</li>
</ul>


<p>Ce sont toutes les trois des méthodes de conversions. Elles transforment
respectivement l'argument en un type Array, Hash ou String. Pour effectuer
cette conversion elles utilisent la méthode <code>to_*</code> sur l'argument. Par
exemple <code>String(self)</code> utilise <code>self.to_s</code>:</p>

<p>``` irb
[~]⇒ irb</p>

<blockquote><blockquote><p>String(self)
&ldquo;main&rdquo;
self.to_s
&ldquo;main
```</p></blockquote></blockquote>

<p>La particularité de ces méthodes est que leur nom débutent par une majuscule,
ce qui va à l'encontre des conventions en Ruby et les fait ressembler un
peu comme à un constructeur en Java et consorts. D'un autre coté, le langage
n'empêche pas de nommer les méthodes ainsi:</p>

<p>``` irb</p>

<blockquote><blockquote><p>def Foo(arg)
  puts arg
end
nil
Foo(&ldquo;hello&rdquo;)
hello
nil
```</p></blockquote></blockquote>

<p>J'imagine que si ces méthodes débutent par une majuscule, c'est pour
permettre aux développeurs d'utiliser <code>array</code>, <code>hash</code> et <code>string</code> comme
nom de variable. Par contre je n'arrive pas à trouver une utilité à
ces méthodes… Je veux dire pourquoi utiliser <code>String(arg)</code> plutôt que
<code>arg.to_s</code> ?</p>

<p>Si toi, Lecteur, tu as une réponse, n'hésite pas à laisser un commentaire ;&ndash;)</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
