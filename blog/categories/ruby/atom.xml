<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : ruby | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-10-12T21:16:15+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby 2.0: Raffinement de méthode]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/10/ruby-2-dot-0-raffinement-de-methode/"/>
    <updated>2013-10-10T18:18:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/10/ruby-2-dot-0-raffinement-de-methode</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Ruby possède un truc cool : les classes ouvertes. Lorsque j'écris :</p>

<p>``` ruby
class String
  def foo</p>

<pre><code>"foo"
</code></pre>

<p>  end
end
```</p>

<p>Je ne suis pas en train de <em>définir</em> une nouvelle classe <code>String</code>, je suis
simplement en train <em>d'ouvrir</em> la classe <code>String</code> existante pour lui ajouter
une nouvelle méthode.</p>

<!-- more -->


<p>C'est très utile et très cohérent avec l'esprit orienté objet de Ruby.
Mettons que j'ai besoin de cacher les voyelles d'une phrase pour un
hypothétique jeu de lettre, je peux écrire un module avec une collection
de méthodes utilitaires, par exemple:</p>

<p>``` ruby
module Util
  def self.hide_vowels(string)</p>

<pre><code>string.tr('aeiouy', '*')
</code></pre>

<p>  end
end</p>

<p>puts Util.hide_vowels(&ldquo;bonjour xavier&rdquo;)
```</p>

<p>Ce qui donne:</p>

<pre><code>b*nj**r x*v**r
</code></pre>

<p>Mais on peut aussi tirer parti des classes ouvertes de cette manière:</p>

<p>``` ruby
class String
  def hide_vowels</p>

<pre><code>tr('aeiouy', '*')
</code></pre>

<p>  end
end</p>

<p>puts &ldquo;bonjour xavier&rdquo;.hide_vowels
```</p>

<p>C'est plus élégant, à la fois dans la définition et dans l'utilisation.
Seulement ce genre de code peut poser problème quand il est utilisé dans
des bibliothèques, puisque une fois chargée, la nouvelle méthode est visible
dans tout le code client. Parfois c'est ce qu'on veut, parfois ce ne devrait
être qu'une méthode utilitaire du code tiers.</p>

<p>Ruby 2.0 propose le raffinement de méthode (<em>method refinement</em>) pour
pallier à ce problème. L'idée est de limiter la portée des méthodes ajoutées
ou modifiées avec le mécanisme des classes ouvertes. Voici un petit exemple:</p>

<p>```
module CoolString
  refine String do</p>

<pre><code>def hide_vowels
  tr('aeiouy', '*')
end
</code></pre>

<p>  end
end</p>

<h1>puts &ldquo;abc&rdquo;.hide_vowels</h1>

<p>using CoolString
puts &ldquo;abc&rdquo;.hide_vowels
```</p>

<p>La ligne en commentaire provoquerait une erreur (NoMethodError). Pour pouvoir
utiliser la méthode <code>hide_vowels</code> il faut explicitement écrire
<code>using CoolString</code>. La portée de <code>hide_vowels</code> s'étend du moment où on utilise
la méthode <code>using</code> jusqu'à la fin du fichier.</p>

<p>Le raffinement de méthode est expérimental dans Ruby 2.0 et devrait être
définitivement adopté dans Ruby 2.1. Pour aller plus loin, on peut se
reporter à la <a href="http://www.ruby-doc.org/core-2.0.0/doc/syntax/refinements_rdoc.html">documentation</a>.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés: un point sur les performances]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/09/les-algorithmes-genetiques-demystifies-un-point-sur-les-performances/"/>
    <updated>2013-10-09T11:57:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/09/les-algorithmes-genetiques-demystifies-un-point-sur-les-performances</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Aujourd'hui j'ai peu de temps à consacrer à ce blog. Je voudrais faire
un petit point sur les performances de différentes versions de
l'interpréteur Ruby.</p>

<!-- more -->


<p>Utiliser un interpréteur plus rapide est le moyen le plus simple de
booster les performances. J'ai calculé le temps que prends une génération
avec diverses tailles d'échiquier (16, 30 et 40) et trois interpréteurs
différents: MRI 1.9.3, MRI 2.0.0 et Rubinius 2.0.0.
Voici les résultats:</p>

<pre><code>Temps en seconde pour une génération
====================================

                 16x16  30x30  40x40

MRI 1.9.3        0.092  0.24   0.40
MRI 2.0.0        0.081  0.20   0.34
Rubinius 2.0.0   0.075  0.15   0.24
</code></pre>

<p>C'est sans appel et sans surprise. On peut quand même noter que plus
la taille de l'échiquier augmente, plus Rubinius est proportionnelement rapide.
En gros 22% plus rapide sur un échiquier de 16x16 cases et 66% plus rapide sur
un échiquier de 40x40 cases.</p>

<p>Conclusion évidente: choisissez bien vos outils ;&ndash;)</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 30: La population initiale]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/08/les-algorithmes-genetiques-demystifies-30-la-population-initiale/"/>
    <updated>2013-10-08T21:30:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/08/les-algorithmes-genetiques-demystifies-30-la-population-initiale</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Aujourd'hui je voudrais parler un peu de la population initiale dans
l'algorithme génétique du problème des 8 dames et en général.</p>

<!-- more -->


<h2>La population initiale</h2>

<p>Dans le paradoxe du singe savant, les chromosomes de la population initiale,
c'est à dire les phrases, étaient générés complètement au hasard. Ce n'est
pas le cas dans le programme qu'on a développé pour solutionner le problème
des 8 dames…</p>

<p>Les dames ne sont pas placées au hasard sur l'échiquier, mais sont
placées une seule par rangée. Cela a pour effet d'<em>orienter</em> la population
initiale. Les chromosomes de la population initiale appartiennent à un
sous-ensemble des chromosomes possibles. Et comme la fonction de mutation
s'applique elle aussi sur une rangée on ne peut jamais sortir de ce
sous-ensemble.</p>

<p>On pourrait même <em>orienter</em> encore plus la population initiale en faisant
en sorte que les dames ne puissent se trouver ni sur une même rangée, ni
sur une même colonne. Pour cela, on pourrait changer la méthode
<code>initialize</code> de la classe <code>Individual</code> ainsi:</p>

<p>``` ruby
  def initialize(chromosome = nil, chromosome_size = nil)</p>

<pre><code>if chromosome
  # Comme précédement…
else
  @chromosome = (0...chromosome_size).to_a.shuffle
end
</code></pre>

<p>  end
```</p>

<p>Alors est-ce-que c'est bien d'orienter la population initiale ? Ça dépend.
Le truc c'est qu'on ne possède pas toujours une totale compréhension du
problème et de l'ensemble des solutions potentielles. Et bien souvent,
orienter la population initiale d'une manière que l'on <em>croit</em> bonne a pour
effet d'emmener le programme dans un extremum local d'où il peut être
long de sortir. Il est difficile d'obtenir la preuve qu'on puisse se passer
de certains gènes…</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 29]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/07/les-algorithmes-genetiques-demystifies-29/"/>
    <updated>2013-10-07T18:48:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/07/les-algorithmes-genetiques-demystifies-29</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Aujourd'hui on voit comment sortir de l'extremum local qui bloque notre
algorithme sur le problème des 8 dames.</p>

<!-- more -->


<p>Pour rappel, on essaie de faire fonctionner l'algorithme sur des échiquiers
de plus grande taille: 16, 20 ou 30 cases.
On a vu dernièrement que le faible taux de mutation (1/<em>n</em>, où <em>n</em> est la
taille de la population) qu'on emploie à du bon et du mauvais.
Il est bon puisqu'en exploitant les chromosomes, il mène assez vite à une
<em>presque</em> solution. Et il est mauvais puisque arrivé à cette <em>presque</em> solution,
qui est un extremum local, il ne permet pas l'exploration d'autres chromosomes.</p>

<p>À priori, on peut penser qu'il suffit d'augmenter le taux de mutation.
Effectivement, on obtiendra souvent de très bons résultats entre 1 et
3%. Mais souvent ne veut pas dire toujours et on restera régulièrement
coincé.</p>

<p>Une solution envisageable est d'avoir un taux de mutation variable. 1/<em>n</em>
au début, puis quand on sent arriver l'extremum local on augmente le taux
pour permettre à l'exploration de reprendre. Enfin, quand on pense être
sorti de l'extremum local, on repasse au taux original.</p>

<p>Voici la nouvelle classe <code>Mutator</code>, j'ai mis le code supplémentaire
entre <code># ---</code>:</p>

<p>``` ruby
class Mutator
  def initialize(chromosome_size, mutation_rate)</p>

<pre><code>@size = chromosome_size
@rate = mutation_rate
# ---
@original = mutation_rate
# ---
</code></pre>

<p>  end</p>

<p>  def mutate(chromosome)</p>

<pre><code>@size.times do |index|
  if rand &lt; @rate
    chromosome[index] = Gene.random(@size)
  end
end
chromosome
</code></pre>

<p>  end</p>

<p>  # &mdash;&ndash;
  def increase_mutation_rate</p>

<pre><code>@rate += 0.1
</code></pre>

<p>  end</p>

<p>  def original_mutation_rate</p>

<pre><code>@rate = @original
</code></pre>

<p>  end
  # &mdash;&ndash;
end
```</p>

<p>Le nouveau membre <code>@original</code> et les deux nouvelles méthodes permettent
d'augmenter le taux de mutation (de 10% carrément) et de le repasser
à l'original.</p>

<p>Les autres modifications du code sont en rapport avec ceci. Voici le code
complet:</p>

<p>``` ruby 8_queens.rb
class Individual
  def self.random(chromosome_size)</p>

<pre><code>new(nil, chromosome_size)
</code></pre>

<p>  end</p>

<p>  def self.from_chromosome(chromosome)</p>

<pre><code>new(chromosome)
</code></pre>

<p>  end</p>

<p>  def display</p>

<pre><code>@chromosome.each do |queen_position|
  row = ""
  @chromosome.size.times do |cell|
    row += (cell == queen_position) ? "Q" : "."
  end
  puts row
end
</code></pre>

<p>  end</p>

<p>  attr_accessor :score, :fitness
  attr_reader :chromosome</p>

<p>  def initialize(chromosome = nil, chromosome_size = nil)</p>

<pre><code>if chromosome
  @chromosome = chromosome
else
  @chromosome = []
  chromosome_size.times { @chromosome &lt;&lt; Gene.random(chromosome_size) }
end
</code></pre>

<p>  end
  private_class_method :new
end</p>

<p>class Gene
  def self.random(limit)</p>

<pre><code>rand(limit)
</code></pre>

<p>  end
end</p>

<p>class Population &lt; Array
  def initialize(chromosome_size, population_size)</p>

<pre><code>population_size.times { self &lt;&lt; Individual.random(chromosome_size) }
</code></pre>

<p>  end</p>

<p>  def best</p>

<pre><code>self.sort_by{|individual| individual.score}.last
</code></pre>

<p>  end
end</p>

<p>class Evaluator
  def initialize(board_size, population)</p>

<pre><code>@board_size = board_size
@population = population
</code></pre>

<p>  end</p>

<p>  def evaluate</p>

<pre><code>@population.each {|individual| score(individual) }
fitness
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def score(individual)</p>

<pre><code>individual.score = 1.0 / conflicts(individual)
</code></pre>

<p>  end</p>

<p>  def conflicts(individual)</p>

<pre><code>board = individual.chromosome
score = 0
@board_size.times do |row1|
  gene1 = board[row1]
  (row1+1...@board_size).each do |row2|
    gene2 = board[row2]
    score += 1 if gene1 == gene2
    score += 1 if row2 - row1 == (gene1 - gene2).abs
  end
end
score
</code></pre>

<p>  end</p>

<p>  def fitness</p>

<pre><code>total = @population.inject(0) {|sum, individual| sum + individual.score }
@population.each do |individual|
  individual.fitness = individual.score.to_f / total * @population.size
end
</code></pre>

<p>  end
end</p>

<p>class GeneticAlgorithm
  def initialize(generations, population, board_size, mutation_rate)</p>

<pre><code>@generations = generations
@population = population
@board_size = board_size
@mutation_rate = mutation_rate
@crossover = Crossover.new(board_size, mutation_rate)
</code></pre>

<p>  end</p>

<p>  def run</p>

<pre><code># ---
old_best = 0
same_best = 1
# ---
@generations.times do |generation|
  Evaluator.new(@board_size, @population).evaluate
  best = @population.best
  display(generation, best)
  if best.score &gt; 1.0
    best.display
    exit
  end
  # ---
  if best.score == old_best
    same_best += 1
  else
    same_best = 1
    @crossover.original_mutation_rate
  end
  old_best = best.score
  if same_best == 5
    same_best = 1
    puts "Increase mutation rate to #{@crossover.increase_mutation_rate}"
  end
  # ---
  next_generation
end
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def display(generation, best)</p>

<pre><code>puts "#{generation} #{best.score}"
</code></pre>

<p>  end</p>

<p>  def next_generation</p>

<pre><code>pool = MatingPool.new(@population)
population_size = @population.size
@population.clear
population_size.times do
  @population &lt;&lt; @crossover.two_point(pool.random, pool.random)
end
</code></pre>

<p>  end
end</p>

<p>class MatingPool
  def initialize(population)</p>

<pre><code>@mating_pool = []
population.each do |individual|
  integer_part = individual.fitness.to_i
  real_part = individual.fitness - integer_part
  integer_part.times { @mating_pool &lt;&lt; individual.dup }
  @mating_pool &lt;&lt; individual.dup if rand &lt; real_part
end
@size = @mating_pool.size
</code></pre>

<p>  end</p>

<p>  def random</p>

<pre><code>@mating_pool[rand(@size)]
</code></pre>

<p>  end
end</p>

<p>class Crossover
  def initialize(chromosome_size, mutation_rate)</p>

<pre><code>@size = chromosome_size
@rate = mutation_rate
@mutator = Mutator.new(@size, @rate)
</code></pre>

<p>  end</p>

<p>  def two_point(parent1, parent2)</p>

<pre><code>child = assemble(parent1, parent2, two_cut_points)
child = @mutator.mutate(child)
Individual.from_chromosome(child)
</code></pre>

<p>  end</p>

<p>  # &mdash;&ndash;
  def increase_mutation_rate</p>

<pre><code>@mutator.increase_mutation_rate
</code></pre>

<p>  end</p>

<p>  def original_mutation_rate</p>

<pre><code>@mutator.original_mutation_rate
</code></pre>

<p>  end
  # &mdash;&ndash;</p>

<p>  private</p>

<p>  def two_cut_points</p>

<pre><code>point1 = cut_point
point2 = cut_point
point1, point2 = point2, point1 if point1 &gt; point2
[point1, point2]
</code></pre>

<p>  end</p>

<p>  def cut_point</p>

<pre><code>rand(@size)
</code></pre>

<p>  end</p>

<p>  def assemble(parent1, parent2, points)</p>

<pre><code>point1, point2 = points
parent1.chromosome[0...point1] + 
  parent2.chromosome[point1..point2] +
  parent1.chromosome[point2+1..-1]
</code></pre>

<p>  end
end</p>

<p>class Mutator
  def initialize(chromosome_size, mutation_rate)</p>

<pre><code>@size = chromosome_size
@rate = mutation_rate
# ---
@original = mutation_rate
# ---
</code></pre>

<p>  end</p>

<p>  def mutate(chromosome)</p>

<pre><code>@size.times do |index|
  if rand &lt; @rate
    chromosome[index] = Gene.random(@size)
  end
end
chromosome
</code></pre>

<p>  end</p>

<p>  # &mdash;&ndash;
  def increase_mutation_rate</p>

<pre><code>@rate += 0.1
</code></pre>

<p>  end</p>

<p>  def original_mutation_rate</p>

<pre><code>@rate = @original
</code></pre>

<p>  end
  # &mdash;&ndash;
end</p>

<p>generations = 1_000
board_size = 16
population = Population.new(board_size, 1000)
mutation = 0.001
GeneticAlgorithm.new(generations, population, board_size, mutation).run
```</p>

<p>On peut voir dans la méthode <code>run</code> que l'augmentation du taux de mutation
se fait lorsque 5 générations successives on le même meilleur score.
Avec cette méthode, je génère une solution pour un échiquier de 16x16 cases
avec une moyenne de 311 générations.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gem Ruby: Tracez vos fonctions et données en 2D avec ctioga2]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/05/gem-ruby-tracez-vos-fonctions-et-donnees-en-2d-avec-ctioga2/"/>
    <updated>2013-10-05T14:43:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/05/gem-ruby-tracez-vos-fonctions-et-donnees-en-2d-avec-ctioga2</id>
    <content type="html"><![CDATA[<p>Je cherchais un programme simple à prendre en main pour tracer des
ensembles de données depuis un fichier et des fonctions mathématiques
et je suis tombé sur la gem <a href="http://ctioga2.rubyforge.org/index.html">ctioga2</a>.</p>

<p><img src="/images/ctioga2.png"></p>

<p>Voici une introduction rapide à ce programme de traçage.</p>

<!-- more -->


<h2>Installation</h2>

<p>Il faut d'abord installer les outils nécessaires à la génération de document
pdf. Sur Linux c'est texlive, pour les autres OS voyez la
<a href="http://ctioga2.rubyforge.org/install.html">page d'installation</a> de ctioga2.
Ensuite on installe la gem comme d'habitude:</p>

<pre><code>gem install ctioga2
</code></pre>

<h2>Le fichier de données</h2>

<p>Un commentaire commence par un <code>#</code>. La première colonne est la coordonnée <code>x</code> et
la seconde colonne est la coordonnée <code>y</code>. Difficile de faire plus simple.
Un exemple:</p>

<pre><code># Fichier data.dat
# x y
0 -0.9
1 -0.4
2 -0.1
3 0.1
4 0.4
5 0.9
</code></pre>

<h2>Les scripts</h2>

<p>Voici un script minimal pour générer un fichier pdf:</p>

<pre><code># Fichier test.ct2
xpdf
plot data.dat
title 'Test'
</code></pre>

<p>Ce script va générer un fichier au format pdf à partir de notre fichier
de données, avec le titre <code>Test</code>. On le lance ainsi:</p>

<pre><code>ctioga2 -f test.ct2
</code></pre>

<p><strong>Note</strong> j'ai trouvé que seuls les caractères ascii fonctionnaient pour le
titre.</p>

<p>Si notre fichier de données possèdent plusieurs colonnes, on peut tracer
plusieurs courbes ainsi:</p>

<pre><code># Fichier test.ct2
xpdf
plot data.dat
plot data.dat@1:3
title 'Test'
</code></pre>

<p>Par défaut les <code>x</code> proviennent de la 1ère colonne et les <code>y</code> de la seconde.
La ligne <code>plot data.dat@1:3</code> trace une seconde courbe avec les <code>y</code> venant
de la 3ème colonne.</p>

<p>On peut aussi fournir des expressions Ruby:</p>

<pre><code>plot data2.dat@'$2:$3**2'
</code></pre>

<p>Ici la seconde colonne est utilisée pour les <code>x</code> et les <code>y</code> proviennent de
la troisième colonne, dont les données sont élevées à la puissance 2.</p>

<p>Plein d'autres choses sont possibles, comme produire du format png ou
svg, spécifier la portée des coordonnées x et y, utiliser le programme
en ligne de commande, etc.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
