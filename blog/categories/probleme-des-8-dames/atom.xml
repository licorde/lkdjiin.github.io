<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : problème des 8 dames | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/probleme-des-8-dames/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-09-25T14:28:48+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 22]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/25/les-algorithmes-genetiques-demystifies-22/"/>
    <updated>2013-09-25T14:22:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/25/les-algorithmes-genetiques-demystifies-22</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Après avoir trouver comment représenter un chromosome pour le
problème des 8 dames (<a href="http://lkdjiin.github.io/blog/2013/09/24/les-algorithmes-genetiques-demystifies-21-probleme-des-8-dames/">article précédent</a>),
on regarde aujourd'hui comment réaliser l'évaluation de la population.</p>

<!-- more -->


<p>Sans plus attendre, voici la classe <code>Evaluator</code> dans toute sa
splendeur, on la détaille après:</p>

<p>``` ruby
class Evaluator
  def initialize(board_size, population)</p>

<pre><code>@board_size = board_size
@population = population
</code></pre>

<p>  end</p>

<p>  def evaluate</p>

<pre><code>@population.each {|individual| score(individual) }
fitness
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def score(individual)</p>

<pre><code>individual.score = 1.0 / conflicts(individual)
</code></pre>

<p>  end</p>

<p>  def conflicts(individual)</p>

<pre><code># Calcule et renvoie le nombre de paires de dames en conflits.
</code></pre>

<p>  end</p>

<p>  def fitness</p>

<pre><code>total = @population.inject(0) {|sum, individual| sum + individual.score }
@population.each do |individual|
  individual.fitness = individual.score.to_f / total * @population.size
end
</code></pre>

<p>  end
end
```</p>

<p>Tout d'abord le constucteur:</p>

<p><code>ruby
  def initialize(board_size, population)
</code></p>

<p>Il prends comme paramêtre la taille de l'échiquier et la population à
évaluer. Trouver une solution pour un échiquier de 8 x 8 cases ne
devrait pas être trop difficile et il sera plus intéressant de voir
comment l'algorithme se débrouille avec des échiquiers de plus grande
taille.</p>

<p>La méthode <code>evalute</code> est identique à celle de la
<a href="http://lkdjiin.github.io/blog/2013/09/19/les-algorithmes-genetiques-demystifies-18/">dernière fois</a>:
elle calcule le <em>score</em> puis le <em>fitness</em> de chaque individu.</p>

<p>Passons à la méthode <code>conflicts</code>, qui n'est pas encore implémentée:</p>

<p>``` ruby
  def conflicts(individual)</p>

<pre><code># Calcule et renvoie le nombre de paires de dames en conflits.
</code></pre>

<p>  end
```</p>

<p>C'est en calculant le nombre de paires de dames en conflits qu'on pourra
évaluer les différentes positions. Plus il y a de conflits, plus on est
loin d'une solution. À l'inverse, une solution possède zéro conflits.
L'implémentation sera pour la prochaine fois.</p>

<p>Voyons maintenant la méthode <code>score</code>:</p>

<p>``` ruby
  def score(individual)</p>

<pre><code>individual.score = 1.0 / conflicts(individual)
</code></pre>

<p>  end
```</p>

<p>Pourquoi diviser 1 par le nombre de conflits ? Pourquoi ne pas avoir écrit
simplement <code>individual.score = conflicts(individual)</code> ?
Parce que je ne trouve pas naturel qu'un score de zéro soit meilleur qu'un
score de 5, 10, 20, etc. Je préfère donc calculer l'inverse du nombre de
conflits. De cette manière si il y a 10 conflits, le score sera 0,1 et si il
y a 2 conflits le score sera 0,5. Et si il y a zéro conflits ? Ruby ne pose
pas de problème avec les nombres réèls:</p>

<p>``` irb
[~]⇒ irb</p>

<blockquote><blockquote><p>1.0 / 0
Infinity
```</p></blockquote></blockquote>

<p>Je saurais donc que j'ai trouvé une solution quand un score sera supérieur
à 1. Avec d'autres langages on peut gérer ça avec des exceptions, des erreurs,
détecter la division par zéro avant de la faire, etc. Ou encore ajouter
une petite valeur au nombre de conflits, par exemple:</p>

<pre><code>score = 1.0 / (nombre_de_conflits + 0.1)
</code></pre>

<p>La prochaine fois on verra comment calculer le nombre de conflits.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 21: Problème des 8 dames]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/24/les-algorithmes-genetiques-demystifies-21-probleme-des-8-dames/"/>
    <updated>2013-09-24T10:04:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/24/les-algorithmes-genetiques-demystifies-21-probleme-des-8-dames</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>On va tenter de résoudre le problème des 8 dames à l'aide d'un algorithme
génétique.</p>

<p><blockquote><p>Le but du problème des huit dames est de placer huit dames d'un jeu d'échecs sur un échiquier de 8 × 8 cases sans que les dames ne puissent se menacer mutuellement, conformément aux règles du jeu d'échecs (la couleur des pièces étant ignorée). Par conséquent, deux dames ne devraient jamais partager la même rangée, colonne, ou diagonale.</p><footer><strong>Wikipédia <a href="http://fr.wikipedia.org/wiki/Probl%C3%A8me_des_huit_dames">http://fr.wikipedia.org/wiki/Probl%C3%A8me_des_huit_dames</a></strong></footer></blockquote></p>

<!-- more -->


<p>Avant toute chose, il faut trouver comment nos chromosomes vont pouvoir
représenter une solution potentielle. On pourrait coder ça sous forme
d'une chaîne de 64 bits, un par case, les 0 étants des cases vides et
les 1 étants les cases occupées par les dames. On pourrait aussi les coder
comme un tableau à deux dimensions, soit 8 rangées multipliées par 8 colonnes.
En y regardant de plus près (ou simplement en relisant la définition du
problème), on remarque que pour qu'une solution soit
viable, il faut une seule dame par rangée, une seule par colonne et une
seule par diagonale. On peut donc se contenter d'une liste (un tableau) de
8 nombres entiers, ces nombres étants le numéro de la colonne. Ainsi, pour
un échiquier de 4 x 4 cases, la liste <code>[0, 2, 3, 3]</code> équivaut à la position
suivante:</p>

<pre><code>---------
|D| | | |
---------
| | |D| |
---------
| | | |D|
---------
| | | |D|
---------
</code></pre>

<p>Maintenant on peut s'occuper de la population. Je vais me servir du code
objet développé dans les derniers articles, en essayant de le modifier
le moins possible.</p>

<p>``` ruby
class Individual
  def self.random(chromosome_size)</p>

<pre><code>new(nil, chromosome_size)
</code></pre>

<p>  end</p>

<p>  def self.from_chromosome(chromosome)</p>

<pre><code>new(chromosome)
</code></pre>

<p>  end</p>

<p>  attr_accessor :score, :fitness
  attr_reader :chromosome</p>

<p>  def initialize(chromosome = nil, chromosome_size = nil)</p>

<pre><code>if chromosome
  @chromosome = chromosome
else
  @chromosome = []
  chromosome_size.times { @chromosome &lt;&lt; Gene.random(chromosome_size) }
end
</code></pre>

<p>  end
  private_class_method :new
end</p>

<p>class Gene
  def self.random(limit)</p>

<pre><code>rand(limit)
</code></pre>

<p>  end
end</p>

<p>class Population &lt; Array
  def initialize(chromosome_size, population_size)</p>

<pre><code>population_size.times { self &lt;&lt; Individual.random(chromosome_size) }
</code></pre>

<p>  end</p>

<p>  def best</p>

<pre><code>self.sort_by{|individual| individual.score}.last
</code></pre>

<p>  end
end
```</p>

<p>J'ai été obligé de modifier la méthode <code>initialize</code> de la classe <code>Individual</code>
ainsi que la classe <code>Gene</code>. Il faudra en tenir compte si on veut qu'un
framework sorte de tout ça…</p>

<p>Le prochain article traitera de l'évaluation du problème des 8 dames.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
