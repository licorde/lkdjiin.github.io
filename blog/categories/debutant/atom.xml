<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : débutant | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/debutant/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-09-04T11:31:14+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Générer un fichier Changelog avec Git]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/04/generer-un-fichier-changelog-avec-git/"/>
    <updated>2013-09-04T11:23:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/04/generer-un-fichier-changelog-avec-git</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p><em>J'ai écrit un script pour Git qui permet de produire un fichier</em>
changelog
<em>en html ou en markdown à partir des commits.</em></p>

<!-- more -->


<p>Dans un
<a href="http://lkdjiin.github.io/blog/2013/07/18/comment-etendre-git-avec-ses-propres-scripts-la-suite/">article précédent</a>
j'ai montré comment étendre Git avec un script pour créer ses propres
commandes. Aujourd'hui je vous présente mon script <code>git-changelog</code>.
Vous pouvez le trouver sur
<a href="https://github.com/lkdjiin/git-changelog">Github</a>.</p>

<p>Il s'agit d'un script Ruby qui ajoute une commande <code>changelog</code> à Git.
Il est utile pour automatiser (ou semi-automatiser) la production du
fichier changelog. Il peut produire des fichiers au format HTML ou au
format Markdown.</p>

<p>Pour l'installer, il faut mettre le fichier <code>git-changelog</code> quelque part
dans votre PATH, après l'avoir téléchargé.</p>

<h2>Utilisation</h2>

<p>Sortie sur la console:</p>

<pre><code>git changelog
</code></pre>

<p>Sortie dans un fichier:</p>

<pre><code>git changelog &gt; changelog.markdown
</code></pre>

<p>Le script accepte l'option <code>--since</code>. C'est la même option qu'utilise la
commande <code>git log</code>:</p>

<pre><code>git changelog --since=2013-07-01
git changelog --since=10.days
</code></pre>

<p>Sortie au format HTML:</p>

<pre><code>git changelog --html
</code></pre>

<p>Un exemple de combinaison:</p>

<pre><code>git changelog --html --since=2013-05-27 &gt; changelog.html
</code></pre>

<h2>Un exemple</h2>

<p>Voici ce que produit <code>git-changelog</code>:</p>

<pre><code>2013-07-18 Version 0.2.1  
==========================
* 2013-07-18 Fix bug for markdown format  
  Html entities are now escaped.
* 2013-07-18 Fix bug with markdown format  
  Commit body now start on a new line.
* 2013-07-18 Add auto-generated changelog file  

2013-07-18 Version 0.2.0  
==========================
* 2013-07-18 Add html format output  
  A new --html option outputs a &amp;lt;ul&amp;gt;.
* 2013-07-17 First commit  
  The script outputs in markdown and accept the option '--since'.
</code></pre>

<p>Et voilà ce que ça donne (avec le style de ce blog):</p>

<h1>2013-07-18 Version 0.2.1  </h1>

<ul>
<li>2013-07-18 Fix bug for markdown format<br/>
Html entities are now escaped.</li>
<li>2013-07-18 Fix bug with markdown format<br/>
Commit body now start on a new line.</li>
<li>2013-07-18 Add auto-generated changelog file</li>
</ul>


<h1>2013-07-18 Version 0.2.0  </h1>

<ul>
<li>2013-07-18 Add html format output<br/>
A new &mdash;html option outputs a &lt;ul&gt;.</li>
<li>2013-07-17 First commit<br/>
The script outputs in markdown and accept the option &lsquo;&mdash;since&rsquo;.</li>
</ul>


<h2>Rake task</h2>

<p>Voici un exemple de <em>rake task</em> pour une gem Ruby:</p>

<p><code>ruby
desc "Generate the changelog"
task :changelog do
  system "git changelog &gt; Changelog.markdown"
end
</code></p>

<p>Et un exemple pour un projet Rails:</p>

<p><code>ruby lib/tasks/changelog.rake
desc "Generate the changelog in html"
task :changelog do
  system "git changelog --html &gt; app/views/pages/_changelog.html"
end
</code></p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bien débuter avec Vim: Recherche de texte]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/27/bien-debuter-avec-vim-recherche-de-texte/"/>
    <updated>2013-08-27T10:14:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/27/bien-debuter-avec-vim-recherche-de-texte</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Aujourd'hui je montre comment rechercher une chaîne de caractères dans un
fichier avec Vim: les commandes, les options et un petit truc en plus…</p>

<!-- more -->


<h2>Les commandes utiles</h2>

<p>Pour rechercher un texte dans le fichier, on utilise la commande <code>/</code> suivie
du texte à rechercher et de la touche entrée. Ainsi:</p>

<pre><code>/texte
</code></pre>

<p>va chercher toutes les occurences de «texte» dans le fichier.</p>

<p>Pour se déplacer parmi les occurences trouvées, on utilise <code>n</code> et <code>N</code>. <code>n</code>
va à l'occurence suivante tandis que <code>N</code> va à l'occurence précédente.</p>

<p>Attention, la commande de recherche <code>/</code> ne tient pas compte des <em>mots</em>.
Je m'explique: <code>/xxx</code> va trouver les 4 expressions suivantes.</p>

<ol>
<li>xxx</li>
<li>aaaxxx</li>
<li>xxxbbb</li>
<li>aaaxxxbbb</li>
</ol>


<p>Parfois c'est ce que l'on veut, parfois non. Pour modifier ce comportement
on utilise <code>\&lt;</code> et <code>\&gt;</code>, respectivement pour signifier le début et la fin
d'un mot. Ainsi <code>\&lt;xxx\&gt;</code> ne trouvera que l'expression n° 1. <code>\&lt;xxx</code> trouvera
la n° 1 et la n° 3. Quand à <code>/xxx\&gt;</code>, elle trouvera la n° 1 et la n° 2.</p>

<h2>Les options</h2>

<p>Voici quelques options à utiliser dans votre fichier .vimrc.</p>

<p><code>vim
set incsearch
</code></p>

<p>La recherche sera mise en évidence au fur et à mesure de la frappe clavier,
et non pas seulement après la touche entrée. <code>incsearch</code> signifie
<em>incremental search</em>.</p>

<p><code>vim
set ignorecase smartcase
</code></p>

<p>Ces deux options marchent souvent de pair. <code>ignorecase</code> permet d'ignorer la
différence minuscule/majuscule, ainsi <code>/texte</code> trouvera «texte», «TEXTE» et
«Texte». <code>smartcase</code> repassera en mode différenciation des
minuscules/majuscules si vous saisissez une majuscule, ainsi <code>/Texte</code> trouvera
«Texte» mais pas «TEXTE» ni «texte».</p>

<p><code>vim
set hlsearch
</code></p>

<p>Cette option sert à mettre en évidence la recherche, autrement dit à la
surligner.</p>

<h2>Supprimer la mise en évidence du texte après une recherche</h2>

<p>Une fois que vous avez fait ce que vous aviez à faire avec votre recherche,
celle-ci reste surlignée, ce qui devient vite très agaçant (pour rester poli).
Pour effacer le surlignage, on utilise la commande <code>nohlsearch</code>:</p>

<p><code>vim
:nohlsearch
</code></p>

<p>On aura évidemment intérêt à mapper cette commande, par exemple sur
<code>&lt;Leader&gt;h</code>:</p>

<p><code>vim
nnoremap &lt;Leader&gt;h :nohlsearch&lt;CR&gt;
</code></p>

<p>Personnellement, je n'ai pas de mappage pour cette commande: je ne m'en
sert tout simplement pas. Pour supprimer la mise en évidence de la
dernière recherche je tape juste <code>/xx</code>. Vous pouvez utiliser <code>/yy</code> ou <code>/ww</code>
ou tout ce qui tombe bien sous vos doigts. Le principe est de rechercher
une chaîne qui n'existe pas, ce qui a pour effet d'effacer la dernière
mise en évidence.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Quelques ressources libres pour Elixir]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/24/quelques-ressources-libres-pour-elixir/"/>
    <updated>2013-08-24T11:24:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/24/quelques-ressources-libres-pour-elixir</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>J'ai passé quelques semaines à tester/jouer avec le langage Elixir. Voici
une liste des ressources qui m'ont été très utiles.</p>

<!-- more -->


<h2>Le site officiel</h2>

<p>Tout commence ici: <a href="http://elixir-lang.org/">http://elixir-lang.org/</a>.
Plus spécifiquement, vous y trouverez une liste de
<a href="http://elixir-lang.org/getting_started/1.html">tutoriels</a>
bien foutus, quoique trop succints à mon goût.</p>

<h2>La documentation</h2>

<p>N'hésitez jamais à consulter la
<a href="http://elixir-lang.org/docs/stable/">documentation d'Elixir</a>. Elle est
claire et assez complète pour un jeune projet.</p>

<h2>Études for Elixir</h2>

<p><a href="http://chimera.labs.oreilly.com/books/1234000001642">Études for Elixir</a>
est un bouquin par O'Reilly en open-source. Il s'agit d'une série d'exercices
à réaliser, on apprend beaucoup. Si vous êtes coincés, les solutions se
trouvent
<a href="https://github.com/oreillymedia/etudes-for-elixir">ici</a>.</p>

<h2>La mailing list</h2>

<p>Si vous êtes perdus, la <a href="https://groups.google.com/forum/#!forum/elixir-lang-talk">mailing list</a>
d'Elixir est votre amie. L'auteur du langage, et d'autres passionnés/engagés,
vous répondent rapidement et poliment. Les réponses sont toujours pertinentes.
C'est vraiment une très bonne mailing list.</p>

<h2>Plugin vim</h2>

<p>Si vous utilisez Vim, ce qu'il vous faut pour la syntaxe, l'indentation, etc,
se trouve <a href="https://github.com/elixir-lang/vim-elixir">ici</a>.</p>

<p>Si vous utilisez le plugin Vim Snipmate, voici en bonus un fichier de
snippets pour Elixir que j'ai commencé. Il y en a peu, mais je pense que
c'est un bon départ, à vous ensuite de créer les votres:</p>

<p>``` vim
snippet case</p>

<pre><code>case ${1:var} do
    ${2:condition1} -&gt; ${3:action1}
    _ -&gt; ${4:other}
end
</code></pre>

<p>snippet cond</p>

<pre><code>cond do
    ${1:condition1} -&gt; ${2:action1}
    true -&gt; ${3:other}
end
</code></pre>

<p>snippet d</p>

<pre><code>def ${1:function} do
    ${2}
end
</code></pre>

<p>snippet dm</p>

<pre><code>defmodule ${1:ModuleName} do
    ${2}
end
</code></pre>

<p>snippet dp</p>

<pre><code>defp ${1:function} do
    ${2}
end
</code></pre>

<p>snippet map</p>

<pre><code>Enum.map(${1:list}, fn e -&gt; ${2:action} end)
</code></pre>

<p>snippet puts</p>

<pre><code>IO.puts ${1}
</code></pre>

<p>```</p>

<h2>Conclusion provisoire sur Elixir</h2>

<p>Apprendre les bases d'Elixir a été plaisant, mais je vais m'arrêter là,
du moins jusqu'à la sortie de la version 1.0.
Le gros avantage d'Elixir est d'utiliser la totalité de vos processeurs
gratuitement. Il n'y a rien à faire, rien à dire, rien à configurer. Ça
marche et c'est tout. J'ai moins aimé la syntaxe qui te fait croire que
tu es en terrain conquis si tu connais Ruby. Ça n'est pas le cas, les
deux langages sont vraiment différents. Le couplage avec Erlang ne
m'a pas convaincu. À un moment ou un autre (du moins quand j'écris ces
lignes) si on veut écrire quelque chose de conséquent, il faut apprendre
un minimum d'Erlang. Ça changera peut-être avec le temps.</p>

<p>Quoiqu'il en soit, la fréquence de nos processeurs n'augmentant plus, un
langage élégant qui sait <em>réellement</em> utiliser le multi-coeur simplement
et avec efficacité est sans conteste un langage sur lequel il faut
garder un oeil…</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bash: ajouter une ligne à la fin de plusieurs fichiers]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/23/bash-ajouter-une-ligne-a-la-fin-de-plusieurs-fichiers/"/>
    <updated>2013-08-23T11:26:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/23/bash-ajouter-une-ligne-a-la-fin-de-plusieurs-fichiers</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Dans l'article d'hier, je décrivais mon deuxième plugin pour Octopress.
Pour le mettre en place sur ce blog, je vais devoir ajouter une ligne de
texte à l'ensemble des articles. Il y en a presque une cinquantaine
maintenant, il est donc hors de question de le faire à la main.
Bash va me faire ça en quelques secondes.</p>

<!-- more -->


<p>J'ouvre une console dans le dossier où sont placés mes articles, et j'entre
ce qui suit:</p>

<p>``` console
[~/&hellip;/source/_posts]⇒ for file in *.markdown; do</p>

<blockquote><p>echo &lsquo;ligne à ajouter&rsquo; >> &ldquo;$file&rdquo;
done
```</p></blockquote>

<p>Tada ! C'est fini. Si vous n'êtes pas familier de Bash, voici une petite
description de ce qui s'est passé:</p>

<p>``` bash
for file in *.markdown; do</p>

<h1>&hellip;</h1>

<p>done
```</p>

<p><code>for - do - done</code> est une structure d'itération de Bash, en gros l'équivalent
d'une boucle <code>for</code> en C, Java, etc. On l'utilise généralement pour itérer
sur les arguments de la ligne de commande, ou bien, comme ici, sur les
fichiers du répertoire. Elle peut s'écrire aussi sur 3 lignes:</p>

<p><code>bash
for x in *
do
ma_commande
done
</code></p>

<p>Et même sur une seule ligne: <code>for x in *; do ma_commande ; done</code></p>

<p><code>bash
echo 'ligne à ajouter' &gt;&gt; "$file"
</code></p>

<p>La commande <code>echo</code> affiche normalement une chaîne de caractère sur
la console. Ici cette chaîne est redirigée avec <code>&gt;&gt;</code> dans le fichier
représenté par <code>"$file"</code>.</p>

<p><code>&gt;&gt;</code> permet d'ajouter en fin de fichier. et le <code>$</code> permet d'extraire le contenu
d'une variable.</p>

<h2>Pour conclure</h2>

<p>La syntaxe de Bash m'a toujours défrisé, mais quand il s'agit de traiter des
fichiers texte, c'est vraiment un outil puissant. Comme je suis curieux,
j'aimerais bien savoir ce que <em>toi</em>, lecteur, tu aurais utilisé pour
cette tâche. Bash, Perl, Sed, Awk, Ruby, autre chose ?</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un plugin Octopress pour les articles connexes]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/22/un-plugin-octopress-pour-les-articles-connexes/"/>
    <updated>2013-08-22T15:56:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/22/un-plugin-octopress-pour-les-articles-connexes</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Je cherchais un plugin Octopress pour embarquer une section d'articles
connexes (<em>related posts</em>) dans certains articles et, curieusement, je
n'en ai pas trouvé. C'est donc l'occasion d'écrire mon second plugin pour
Octopress.</p>

<!-- more -->


<p>Pour voir ce que fait ce plugin, il vous suffit de regarder la section
«Articles connexes» à la fin de cet article. Le code est sur Github:
<a href="https://github.com/lkdjiin/octopress-connexe">octopress-connexe</a>.</p>

<p>Je vais commenter quelques unes des méthodes:</p>

<p>``` ruby
def my_categories(context)
  context.environments.first[&ldquo;page&rdquo;][&ldquo;categories&rdquo;]
end</p>

<p>def my_url(context)
  context.environments.first[&ldquo;page&rdquo;][&ldquo;url&rdquo;]
end
```</p>

<p>J'ai séché un certain temps là-dessus. Pour connaitre les informations
relative à l'article courant, on se sert de
<code>context.environments.first["page"]</code>.</p>

<p>Et voici comment je fais la sélection des articles connexes:</p>

<p>``` ruby
def build_posts(context)
  remove_unrelated_posts
  remove_current_post(context)
  sort_posts
end</p>

<p>def remove_unrelated_posts
  @posts = @posts.select do |post|</p>

<pre><code>result = false
@categories.each do |category|
  result = true if post.categories.include?(category)
end
result
</code></pre>

<p>  end
end</p>

<p>def remove_current_post(context)
  @posts.delete_if {|post| post.url == my_url(context)}
end</p>

<p>def sort_posts
  @posts = @posts.map do |post|</p>

<pre><code>weight = 0
@categories.each do |category|
  weight += 1 if post.categories.include?(category)
end
[weight, post]
</code></pre>

<p>  end
  @posts = @posts.sort.reverse
end
```</p>

<p>Dans un premier temps, j'écarte les articles qui n'ont pas au moins
une catégorie commune avec l'article courant. C'est le rôle de la méthode
<code>remove_unrelated_posts</code>. Puis après avoir écarter de la liste l'article
courant, il ne reste plus qu'à trier avec la méthode <code>sort_posts</code>. Dans cette
méthode, j'attribue un poid à chaque article en fonction du nombre de
catégories communes. C'est ce poid qui sert de référence pour le tri.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
