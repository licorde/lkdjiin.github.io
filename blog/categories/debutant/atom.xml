<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : débutant | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/debutant/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-08-07T09:02:48+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Elixir et les paramètres par défaut]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/07/elixir-et-les-parametres-par-defaut/"/>
    <updated>2013-08-07T08:46:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/07/elixir-et-les-parametres-par-defaut</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Pour définir un paramètre par défaut dans une fonction de module, Elixir
fournit l'opérateur <code>//</code>:</p>

<p>``` elixir test.exs
defmodule M do
  def foo(a // &ldquo;a&rdquo;) do</p>

<pre><code>IO.puts(a)
</code></pre>

<p>  end
end</p>

<p>M.foo()
M.foo(&ldquo;z&rdquo;)
```</p>

<!-- more -->


<pre><code>$ elixir test.exs 
a
z
</code></pre>

<p>Beaucoup d'autres langages permettent la même chose, en général à l'aide
de l'opérateur d'affection <code>=</code>. Si Elixir utilise <code>//</code> à la place de <code>=</code>,
ça n'est pas par goût de l'étrange ou par snobisme. Avec Elixir l'opérateur
<code>=</code> fait plus que de l'affectation, <code>=</code> fait aussi du
<a href="http://lkdjiin.github.io/blog/2013/07/28/pattern-matching-avec-elixir-une-premiere-approche/">pattern matching</a>.
Et d'après ce que j'ai pu voir, le <em>pattern matching</em> est interdit dans
la définition des paramètres.</p>

<p>On peut bien sûr mixer paramètre <em>normal</em> et paramètre par défaut:</p>

<p>``` elixir test.exs
defmodule M do
  def foo(a, b // &ldquo;b&rdquo;) do</p>

<pre><code>IO.puts "#{a} #{b}"
</code></pre>

<p>  end
end</p>

<p>M.foo(&ldquo;a&rdquo;)
M.foo(&ldquo;a&rdquo;, &ldquo;z&rdquo;)
```</p>

<pre><code>$ elixir test.exs 
a b
a z
</code></pre>

<p>Encore une fois c'est comme avec un tas d'autres langages. On place les
paramètres par défaut à la fin. Mais Elixir va plus loin en permettant
de placer les paramètres par défaut n'importe où:</p>

<p>``` elixir test.exs
defmodule M do
  def foo(a // &ldquo;a&rdquo;, b) do</p>

<pre><code>IO.puts "#{a} #{b}"
</code></pre>

<p>  end
end</p>

<p>M.foo(&ldquo;z&rdquo;)
```</p>

<pre><code>$ elixir test.exs 
a z
</code></pre>

<p>C'est peut-être un classique de la programmation fonctionnelle, mais moi, c'est
la première fois que je vois ça. Je ne sais pas encore si c'est utile, mais
au moins c'est possible. Si vous connaissez d'autres langages qui permettent
ce truc, laissez moi un commentaire, je suis curieux.</p>

<p>À demain.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Comment lire et écrire un fichier texte avec Elixir]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/06/comment-lire-et-ecrire-un-fichier-texte-avec-elixir/"/>
    <updated>2013-08-06T08:43:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/06/comment-lire-et-ecrire-un-fichier-texte-avec-elixir</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Quand j'aborde un nouveau langage j'aime bien regarder l'API pour les
entrées/sorties. Je trouve que ça donne le ton.
Aujourd'hui on voit comment ouvrir, lire et écrire des fichiers texte.</p>

<!-- more -->


<h2>Lire un fichier</h2>

<p><code>elixir
{result, device} = File.open("file.ext", [:read, :utf8])
data = IO.read(device, :line)
File.close(device)
</code></p>

<p><code>result</code> contiendra <code>:ok</code> ou <code>:error</code>. On peut tester ce résultat après
coup ou bien se servir du
<a href="http://lkdjiin.github.io/blog/2013/07/28/pattern-matching-avec-elixir-une-premiere-approche/">pattern matching</a> ainsi:</p>

<p><code>elixir
{:ok, device} = File.open("file.ext", [:read, :utf8])
</code></p>

<p>Lorsque la fin du fichier est atteinte, <code>IO.read</code> retourne <code>:eof</code>.
Si on veut lire un certain nombre de caractères au lieu d'une ligne
complète, on passe le nombre de caractères à lire à la fonction <code>IO.read</code>:</p>

<p><code>elixir
chars = IO.read(device, 3)
</code></p>

<p>On notera qu'il faut penser à fermer le fichier après utilisation, ce que
je trouve toujours bizarre avec un langage moderne. J'attends vraiment que
le runtime fasse ça pour moi.</p>

<h2>Écrire un fichier</h2>

<p><code>elixir
{:ok, device} = File.open("test", [:write, :utf8])
IO.write(device, "foo\n")
IO.puts(device, "bar")
File.close(device)
</code></p>

<p>Pas grand chose à dire, c'est clair. La seule différence entre <code>IO.write</code>
et <code>IO.puts</code> est que cette dernière ajoute le caractère de fin de ligne.</p>

<h2>Les entrées/sorties console</h2>

<p>Pour lire sur la console on utilise <code>IO.gets</code>. Le <em>device</em> est <code>:stdio</code>
par défaut:</p>

<p><code>iex
iex(46)&gt; str = IO.gets(:stdio, "Votre nom: ")
Votre nom: xavier
"xavier\n"
iex(47)&gt; str = IO.gets("Votre nom: ")        
Votre nom: foobar
"foobar\n"
</code></p>

<p>Pour écrire sur la console on utilise <code>IO.puts</code>, mais ça vous le saviez déjà.</p>

<p>``` iex
iex(48)> IO.puts(:stdio, str)      <br/>
foobar</p>

<p>:ok
iex(49)> IO.puts(str)      <br/>
foobar</p>

<p>:ok
```</p>

<h2>Pour finir</h2>

<p>Voilà, c'est suffisant pour commencer à bidouiller. Pour aller plus loin,
on pourra lire la documentation des modules IO et File, qui permettent de
faire bien d'autres choses…</p>

<p>À demain.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bien débuter avec Vim: conseil numéro huit]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/05/bien-debuter-avec-vim-conseil-numero-huit/"/>
    <updated>2013-08-05T08:53:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/05/bien-debuter-avec-vim-conseil-numero-huit</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<h2>N'utilisez pas (encore) de plugins</h2>

<p><em>Ce conseil là, personne ne va le suivre…</em></p>

<p>Très vite, au bout de quelques heures, au mieux quelques jours, vous allez
vouloir installer des plugins. La raison principale est
que vous voudrez vous sentir à l'aise avec Vim.
Et pour cela vous chercherez a reproduire (voir simuler) le
comportement de votre ex éditeur/EDI.
C'est normal, c'est humain, mais à mon avis c'est une erreur.</p>

<!-- more -->


<p>Un plugin est fait pour pallier un manque dans une application, pour l'étendre.
Or en tant que débutant, on n'est pas à même de savoir ce que Vim peut ou ne
peut pas faire pour nous. C'est pourquoi vous devriez attendre au moins un
mois avant d'installer votre
premier plugin. Pendant ce temps là, si quelque chose vous manque, cherchez le
dans l'aide de vim ou avec google. La plupart du temps vous finirez par trouver
une façon de faire <em>à la vim</em>.</p>

<p>Surround your pullquote like this {" text to be quoted "}</p>

<pre><code>^&lt;C-v&gt;}I#&lt;Esc&gt;
</code></pre>

<p>Et ça pour décommenter:</p>

<pre><code>^&lt;C-v&gt;}d&lt;Esc&gt;
</code></pre>

<p>Je vous accorde que ça n'est pas aussi agréable que d'utiliser un plugin,
mais ça marche. Et ça peut être utile quand on doit utiliser un Vim de base.</p>

<p>À demain.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bien débuter avec Vim: conseil numéro sept]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/07/31/bien-debuter-avec-vim-conseil-numero-sept/"/>
    <updated>2013-07-31T10:05:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/07/31/bien-debuter-avec-vim-conseil-numero-sept</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<h2>Lisez et utilisez la documentation</h2>

<p>La documentation de Vim est énorme. Elle comporte plusieurs
dizaines de chapitres répartis sur deux manuels: le manuel utilisateur
et le manuel de référence. On y accède avec la touche F1.
La documentation est complète et accessible pour tous les niveaux.
Dans l'idéal, vous devriez la lire entièrement…</p>

<!-- more -->


<p>Alors je ne suis pas naïf et
je sais bien que vous ne le ferez pas. Moi même je ne l'ai évidemment pas fait.
Je dis juste ce que devrait être l'idéal.</p>

<p>Pour rester réaliste, dans un premier
temps, parcourez la documentation entièrement mais en diagonale. Vite fait.
Simplement pour savoir où trouver quoi.
Donnez vous un objectif simple, comme un chapitre par jour.
N'apprenez rien par coeur. Prenez plutôt des notes
quand vous tombez sur un truc qui vous plait.
Parcourir un seul chapitre en diagonale tout en jetant quelques notes
sur une feuille de papier vous prendra entre 5 et 10 minutes.</p>

<p>Dans un second temps, essayez d'étudier à fond au moins les deux premières
parties du manuel utilisateur:
<em>Getting Started</em> et <em>Editing Effectively</em>.
Cette fois ci, il n'est plus question de lire en diagonale, mais bien
d'étudier la bête.</p>

<p>Lire, apprendre, comprendre et digérer la documentation de Vim vous prendra
beaucoup de temps. Certainement
des mois. Au minimum. C'est une bonne raison pour vous y mettre dès
aujourd'hui.</p>

<p>À demain.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Comment écrire un plugin Octopress - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/07/30/comment-ecrire-un-plugin-octopress-partie-2/"/>
    <updated>2013-07-30T08:18:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/07/30/comment-ecrire-un-plugin-octopress-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Dans <a href="http://lkdjiin.github.io/blog/2013/07/27/comment-ecrire-un-plugin-octopress/">la première partie</a>,
je m'étais arrêté sur le code suivant:</p>

<p>``` ruby
module Jekyll
  class LevelTag &lt; Liquid::Tag</p>

<pre><code>def initialize(tagname, level, tokens)
  @level = level
end

def render(context)
  "Niveau : #{@level}"
end
</code></pre>

<p>  end
end
Liquid::Template.register_tag(&lsquo;level&rsquo;, Jekyll::LevelTag)
```</p>

<p>Aujourd'hui je montre comment permettre à l'utilisateur de personnaliser
le contenu du code Html produit.</p>

<!-- more -->


<p>Tout d'abord, voici le code du plugin terminé. Je vous rappelle que vous
pouvez trouver <a href="https://github.com/lkdjiin/octopress-level-tag">ce plugin sur Github</a>.</p>

<p>``` ruby
module Jekyll
  class LevelTag &lt; Liquid::Tag</p>

<pre><code>def initialize(tagname, level, tokens)
  @level = level.strip
end

def render(context)
  config = context.registers[:site].config
  label = config['level_tag_level'] || "Level: "
  level = case @level
  when "1" then config['level_tag_level_1'] || "easy"
  when "2" then config['level_tag_level_2'] || "medium"
  when "3" then config['level_tag_level_3'] || "hard"
  else
    "unknown"
  end
  classes = "class='level-tag level-tag-#{@level}'"
  "&lt;div #{classes}&gt;#{label}&lt;span&gt;#{level}&lt;/span&gt;&lt;/div&gt;"
end
</code></pre>

<p>  end</p>

<p>end
Liquid::Template.register_tag(&lsquo;level&rsquo;, Jekyll::LevelTag)
```</p>

<p>L'appel du plugin dans les articles sera maintenant réalisé comme ceci:</p>

<p><code>ruby
<div class='level-tag level-tag-1'>Niveau : <span>facile</span></div>
</code></p>

<p>Par rapport à la première version, la méthode <code>render</code> a bien enflée. &ndash;
<em>Je trouve qu'il y a trop de code dedans, mais ce sera peut-être le sujet
d'un prochain article sur le refactoring.</em> &ndash; C'est cette méthode qui fait
tout le travail, voici les explications:</p>

<p>``` ruby</p>

<pre><code>def render(context)
  config = context.registers[:site].config
  label = config['level_tag_level'] || "Level: "
</code></pre>

<p>```</p>

<p>C'est l'objet <code>context</code> qui va permettre de récupérer les informations
nécéssaires dans le fichier de configuration <code>_config.yml</code>. Voici par
exemple ce que j'ai ajouté dans mon <code>_config.yml</code>:</p>

<p>``` yaml</p>

<h1>LevelTag plugin</h1>

<p>level_tag_level: &ldquo;Niveau : &rdquo;
level_tag_level_1: &ldquo;facile&rdquo;
level_tag_level_2: &ldquo;intermédiaire&rdquo;
level_tag_level_3: &ldquo;avancé&rdquo;
```</p>

<p>La ligne suivante:</p>

<pre><code>label = config['level_tag_level'] || "Level: "
</code></pre>

<p>initialise la
variable <code>label</code> avec le contenu de <code>level_tag_level</code>, trouvé dans le
<code>_config.yml</code>. La partie du code <code>|| "Level: "</code> est là pour s'assurer que
si <code>level_tag_level</code> n'existe pas dans le fichier de configuration, <code>label</code>
sera bien initialisé avec une valeur par défaut.</p>

<p>``` ruby</p>

<pre><code>  level = case @level
  when "1" then config['level_tag_level_1'] || "easy"
  when "2" then config['level_tag_level_2'] || "medium"
  when "3" then config['level_tag_level_3'] || "hard"
  else
    "unknown"
  end
</code></pre>

<p>```</p>

<p>C'est la même logique que précédement. La variable <code>level</code> sera initialisée
avec du contenu trouvé dans <code>_config.yml</code> ou bien, avec une valeur par
défaut.</p>

<p>``` ruby</p>

<pre><code>  classes = "class='level-tag level-tag-#{@level}'"
  "&lt;div #{classes}&gt;#{label}&lt;span&gt;#{level}&lt;/span&gt;&lt;/div&gt;"
</code></pre>

<p>```</p>

<p>Finalement, comme dans <a href="http://lkdjiin.github.io/blog/2013/07/27/comment-ecrire-un-plugin-octopress/">la première partie</a>,
on retrouve en fin de méthode la production du code Html.</p>

<p>À demain.</p>
]]></content>
  </entry>
  
</feed>
