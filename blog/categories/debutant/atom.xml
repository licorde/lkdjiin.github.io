<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : débutant | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/debutant/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-08-22T16:59:50+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Un plugin Octopress pour les articles connexes]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/22/un-plugin-octopress-pour-les-articles-connexes/"/>
    <updated>2013-08-22T15:56:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/22/un-plugin-octopress-pour-les-articles-connexes</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Je cherchais un plugin Octopress pour embarquer une section d'articles
connexes (<em>related posts</em>) dans certains articles et, curieusement, je
n'en ai pas trouvé. C'est donc l'occasion d'écrire mon second plugin pour
Octopress.</p>

<!-- more -->


<p>Pour voir ce que fait ce plugin, il vous suffit de regarder la section
«Articles connexes» à la fin de cet article. Le code est sur Github:
<a href="https://github.com/lkdjiin/octopress-connexe">octopress-connexe</a>.</p>

<p>Je vais commenter quelques unes des méthodes:</p>

<p>``` ruby
def my_categories(context)
  context.environments.first[&ldquo;page&rdquo;][&ldquo;categories&rdquo;]
end</p>

<p>def my_url(context)
  context.environments.first[&ldquo;page&rdquo;][&ldquo;url&rdquo;]
end
```</p>

<p>J'ai séché un certain temps là-dessus. Pour connaitre les informations
relative à l'article courant, on se sert de
<code>context.environments.first["page"]</code>.</p>

<p>Et voici comment je fais la sélection des articles connexes:</p>

<p>``` ruby
def build_posts(context)
  remove_unrelated_posts
  remove_current_post(context)
  sort_posts
end</p>

<p>def remove_unrelated_posts
  @posts = @posts.select do |post|</p>

<pre><code>result = false
@categories.each do |category|
  result = true if post.categories.include?(category)
end
result
</code></pre>

<p>  end
end</p>

<p>def remove_current_post(context)
  @posts.delete_if {|post| post.url == my_url(context)}
end</p>

<p>def sort_posts
  @posts = @posts.map do |post|</p>

<pre><code>weight = 0
@categories.each do |category|
  weight += 1 if post.categories.include?(category)
end
[weight, post]
</code></pre>

<p>  end
  @posts = @posts.sort.reverse
end
```</p>

<p>Dans un premier temps, j'écarte les articles qui n'ont pas au moins
une catégorie commune avec l'article courant. C'est le rôle de la méthode
<code>remove_unrelated_posts</code>. Puis après avoir écarter de la liste l'article
courant, il ne reste plus qu'à trier avec la méthode <code>sort_posts</code>. Dans cette
méthode, j'attribue un poid à chaque article en fonction du nombre de
catégories communes. C'est ce poid qui sert de référence pour le tri.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bien débuter avec Vim: la touche Escape]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/15/bien-debuter-avec-vim-la-touche-escape/"/>
    <updated>2013-08-15T10:45:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/15/bien-debuter-avec-vim-la-touche-escape</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Vim a été développé sur des machines dont les claviers avaient une
disposition des touches autres que celle de nos claviers modernes. Comme par
exemple le terminal ADM-3A:</p>

<p><img src="/images/KB_Terminal_ADM3A.png"></p>

<!-- more -->


<p>Le plus frappant c'est l'endroit de la touche <em>Escape</em> à l'époque. On pouvait
y accéder avec une simple extension du petit doigt gauche, sans avoir à
bouger la main. De nos jours, cette touche a été reléguée aux confins de
l'univers. Sachant que c'est une touche qu'on utilise sans cesse, y a de
quoi choper une tendinite. Je vais vous donner 3 trucs pour remédier à ce
problème, choisissez celui qui vous conviendra le mieux.</p>

<h2>Control c</h2>

<p>C'est le truc le plus simple, rien à configurer. La combinaison <code>&lt;Ctrl-c&gt;</code>
fonctionne naturellement comme une touche <em>Escape</em>. Il y a bien
quelques différences, et vous vous en rendrez compte à l'occasion, mais
la plupart du temps ça fonctionne. Commencez donc par là avant de vous
attaquer à d'autres trucs, celui-ci est peut être amplement suffisant.</p>

<h2>Une combinaison personnalisée</h2>

<p>Il semble que <code>jj</code> soit une combinaison de remplacement populaire en
mode insertion:</p>

<p><code>vim
inoremap jj &lt;Esc&gt;
</code></p>

<p>L'idée c'est d'utiliser une combinaison de deux caractères qui n'existe
pas dans votre langue/langage, et qui bien sûr soit simple et rapide a
taper. J'ai essayé pendant un moment ce genre de chose, mais je n'ai
jamais réussi à m'y faire.</p>

<h2>Échanger caps lock et esc</h2>

<p>Si pour vous la touche <em>caps lock</em> (verrou majuscule) est un mystère, voici
le truc qu'il vous faut. Mettez donc votre système d'exploitation à
contribution pour:</p>

<ul>
<li>soit échanger la touche <em>caps lock</em> et <em>esc</em></li>
<li>soit faire de <em>caps lock</em> une touche <em>esc</em> supplémentaire</li>
</ul>


<p>Quelque soit votre OS, vous devriez trouver ça dans un menu du genre
Système > Préférences > Clavier.</p>

<h2>Pour conclure</h2>

<p>Vous trouverez plein d'autres trucs sur internet, n'hesitez pas à en
essayer plusieurs avant d'adopter celui qui vous ressemblera.</p>

<p>À demain.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bien débuter avec Vim: conseil numéro neuf]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/08/bien-debuter-avec-vim-conseil-numero-neuf/"/>
    <updated>2013-08-08T08:53:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/08/bien-debuter-avec-vim-conseil-numero-neuf</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<h2>Apprenez à frapper en aveugle</h2>

<p>Ce conseil devrait plutôt s'appeler:</p>

<p><blockquote><p>Avant d'apprendre Vim, apprenez d'abord à frapper en aveugle.</p></blockquote></p>

<p>Mais si vous lisez cet article, il est certainement trop tard, vous avez
déjà commencé Vim.</p>

<!-- more -->


<p>Si vous regardez vos doigts pendant que vous tapez, votre tête suit le
mouvement, et passe constamment d'une sorte de position clavier à une
position écran. D'où fatigue musculaire, occulaire et perte de temps.</p>

<p>Apprendre à frapper en aveugle est un sacré défi, comme apprendre Vim.
Ça ne s'acquiert pas en 2 jours. Il faut du temps.</p>

<p>Dans quelques mois, quand vous serez
assez à l'aise avec vim, installez un logiciel d'apprentissage de la
dactylographie (il y en a plein de libre) et apprenez à écrire sans regarder
votre clavier. Vous aurez alors accès à toute la puissance de Vim.</p>

<p>À demain.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elixir et les paramètres par défaut]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/07/elixir-et-les-parametres-par-defaut/"/>
    <updated>2013-08-07T08:46:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/07/elixir-et-les-parametres-par-defaut</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Pour définir un paramètre par défaut dans une fonction de module, Elixir
fournit l'opérateur <code>//</code>:</p>

<p>``` elixir test.exs
defmodule M do
  def foo(a // &ldquo;a&rdquo;) do</p>

<pre><code>IO.puts(a)
</code></pre>

<p>  end
end</p>

<p>M.foo()
M.foo(&ldquo;z&rdquo;)
```</p>

<!-- more -->


<pre><code>$ elixir test.exs 
a
z
</code></pre>

<p>Beaucoup d'autres langages permettent la même chose, en général à l'aide
de l'opérateur d'affection <code>=</code>. Si Elixir utilise <code>//</code> à la place de <code>=</code>,
ça n'est pas par goût de l'étrange ou par snobisme. Avec Elixir l'opérateur
<code>=</code> fait plus que de l'affectation, <code>=</code> fait aussi du
<a href="http://lkdjiin.github.io/blog/2013/07/28/pattern-matching-avec-elixir-une-premiere-approche/">pattern matching</a>.
Et d'après ce que j'ai pu voir, le <em>pattern matching</em> est interdit dans
la définition des paramètres.</p>

<p>On peut bien sûr mixer paramètre <em>normal</em> et paramètre par défaut:</p>

<p>``` elixir test.exs
defmodule M do
  def foo(a, b // &ldquo;b&rdquo;) do</p>

<pre><code>IO.puts "#{a} #{b}"
</code></pre>

<p>  end
end</p>

<p>M.foo(&ldquo;a&rdquo;)
M.foo(&ldquo;a&rdquo;, &ldquo;z&rdquo;)
```</p>

<pre><code>$ elixir test.exs 
a b
a z
</code></pre>

<p>Encore une fois c'est comme avec un tas d'autres langages. On place les
paramètres par défaut à la fin. Mais Elixir va plus loin en permettant
de placer les paramètres par défaut n'importe où:</p>

<p>``` elixir test.exs
defmodule M do
  def foo(a // &ldquo;a&rdquo;, b) do</p>

<pre><code>IO.puts "#{a} #{b}"
</code></pre>

<p>  end
end</p>

<p>M.foo(&ldquo;z&rdquo;)
```</p>

<pre><code>$ elixir test.exs 
a z
</code></pre>

<p>C'est peut-être un classique de la programmation fonctionnelle, mais moi, c'est
la première fois que je vois ça. Je ne sais pas encore si c'est utile, mais
au moins c'est possible. Si vous connaissez d'autres langages qui permettent
ce truc, laissez moi un commentaire, je suis curieux.</p>

<p>À demain.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Comment lire et écrire un fichier texte avec Elixir]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/06/comment-lire-et-ecrire-un-fichier-texte-avec-elixir/"/>
    <updated>2013-08-06T08:43:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/06/comment-lire-et-ecrire-un-fichier-texte-avec-elixir</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Quand j'aborde un nouveau langage j'aime bien regarder l'API pour les
entrées/sorties. Je trouve que ça donne le ton.
Aujourd'hui on voit comment ouvrir, lire et écrire des fichiers texte.</p>

<!-- more -->


<h2>Lire un fichier</h2>

<p><code>elixir
{result, device} = File.open("file.ext", [:read, :utf8])
data = IO.read(device, :line)
File.close(device)
</code></p>

<p><code>result</code> contiendra <code>:ok</code> ou <code>:error</code>. On peut tester ce résultat après
coup ou bien se servir du
<a href="http://lkdjiin.github.io/blog/2013/07/28/pattern-matching-avec-elixir-une-premiere-approche/">pattern matching</a> ainsi:</p>

<p><code>elixir
{:ok, device} = File.open("file.ext", [:read, :utf8])
</code></p>

<p>Lorsque la fin du fichier est atteinte, <code>IO.read</code> retourne <code>:eof</code>.
Si on veut lire un certain nombre de caractères au lieu d'une ligne
complète, on passe le nombre de caractères à lire à la fonction <code>IO.read</code>:</p>

<p><code>elixir
chars = IO.read(device, 3)
</code></p>

<p>On notera qu'il faut penser à fermer le fichier après utilisation, ce que
je trouve toujours bizarre avec un langage moderne. J'attends vraiment que
le runtime fasse ça pour moi.</p>

<h2>Écrire un fichier</h2>

<p><code>elixir
{:ok, device} = File.open("test", [:write, :utf8])
IO.write(device, "foo\n")
IO.puts(device, "bar")
File.close(device)
</code></p>

<p>Pas grand chose à dire, c'est clair. La seule différence entre <code>IO.write</code>
et <code>IO.puts</code> est que cette dernière ajoute le caractère de fin de ligne.</p>

<h2>Les entrées/sorties console</h2>

<p>Pour lire sur la console on utilise <code>IO.gets</code>. Le <em>device</em> est <code>:stdio</code>
par défaut:</p>

<p><code>iex
iex(46)&gt; str = IO.gets(:stdio, "Votre nom: ")
Votre nom: xavier
"xavier\n"
iex(47)&gt; str = IO.gets("Votre nom: ")        
Votre nom: foobar
"foobar\n"
</code></p>

<p>Pour écrire sur la console on utilise <code>IO.puts</code>, mais ça vous le saviez déjà.</p>

<p>``` iex
iex(48)> IO.puts(:stdio, str)      <br/>
foobar</p>

<p>:ok
iex(49)> IO.puts(str)      <br/>
foobar</p>

<p>:ok
```</p>

<h2>Pour finir</h2>

<p>Voilà, c'est suffisant pour commencer à bidouiller. Pour aller plus loin,
on pourra lire la documentation des modules IO et File, qui permettent de
faire bien d'autres choses…</p>

<p>À demain.</p>
]]></content>
  </entry>
  
</feed>
