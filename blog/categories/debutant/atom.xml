<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : débutant | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/debutant/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-08-05T09:07:25+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Bien débuter avec Vim: conseil numéro huit]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/05/bien-debuter-avec-vim-conseil-numero-huit/"/>
    <updated>2013-08-05T08:53:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/05/bien-debuter-avec-vim-conseil-numero-huit</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<h2>N'utilisez pas (encore) de plugins</h2>

<p><em>Ce conseil là, personne ne va le suivre…</em></p>

<p>Très vite, au bout de quelques heures, au mieux quelques jours, vous allez
vouloir installer des plugins. La raison principale est
que vous voudrez vous sentir à l'aise avec Vim.
Et pour cela vous chercherez a reproduire (voir simuler) le
comportement de votre ex éditeur/EDI.
C'est normal, c'est humain, mais à mon avis c'est une erreur.</p>

<!-- more -->


<p>Un plugin est fait pour pallier un manque dans une application, pour l'étendre.
Or en tant que débutant, on n'est pas à même de savoir ce que Vim peut ou ne
peut pas faire pour nous. C'est pourquoi vous devriez attendre au moins un
mois avant d'installer votre
premier plugin. Pendant ce temps là, si quelque chose vous manque, cherchez le
dans l'aide de vim ou avec google. La plupart du temps vous finirez par trouver
une façon de faire <em>à la vim</em>.</p>

<p>Surround your pullquote like this {" text to be quoted "}</p>

<pre><code>^&lt;C-v&gt;}I#&lt;Esc&gt;
</code></pre>

<p>Et ça pour décommenter:</p>

<pre><code>^&lt;C-v&gt;}d&lt;Esc&gt;
</code></pre>

<p>Je vous accorde que ça n'est pas aussi agréable que d'utiliser un plugin,
mais ça marche. Et ça peut être utile quand on doit utiliser un Vim de base.</p>

<p>À demain.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bien débuter avec Vim: conseil numéro sept]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/07/31/bien-debuter-avec-vim-conseil-numero-sept/"/>
    <updated>2013-07-31T10:05:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/07/31/bien-debuter-avec-vim-conseil-numero-sept</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<h2>Lisez et utilisez la documentation</h2>

<p>La documentation de Vim est énorme. Elle comporte plusieurs
dizaines de chapitres répartis sur deux manuels: le manuel utilisateur
et le manuel de référence. On y accède avec la touche F1.
La documentation est complète et accessible pour tous les niveaux.
Dans l'idéal, vous devriez la lire entièrement…</p>

<!-- more -->


<p>Alors je ne suis pas naïf et
je sais bien que vous ne le ferez pas. Moi même je ne l'ai évidemment pas fait.
Je dis juste ce que devrait être l'idéal.</p>

<p>Pour rester réaliste, dans un premier
temps, parcourez la documentation entièrement mais en diagonale. Vite fait.
Simplement pour savoir où trouver quoi.
Donnez vous un objectif simple, comme un chapitre par jour.
N'apprenez rien par coeur. Prenez plutôt des notes
quand vous tombez sur un truc qui vous plait.
Parcourir un seul chapitre en diagonale tout en jetant quelques notes
sur une feuille de papier vous prendra entre 5 et 10 minutes.</p>

<p>Dans un second temps, essayez d'étudier à fond au moins les deux premières
parties du manuel utilisateur:
<em>Getting Started</em> et <em>Editing Effectively</em>.
Cette fois ci, il n'est plus question de lire en diagonale, mais bien
d'étudier la bête.</p>

<p>Lire, apprendre, comprendre et digérer la documentation de Vim vous prendra
beaucoup de temps. Certainement
des mois. Au minimum. C'est une bonne raison pour vous y mettre dès
aujourd'hui.</p>

<p>À demain.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Comment écrire un plugin Octopress - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/07/30/comment-ecrire-un-plugin-octopress-partie-2/"/>
    <updated>2013-07-30T08:18:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/07/30/comment-ecrire-un-plugin-octopress-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Dans <a href="http://lkdjiin.github.io/blog/2013/07/27/comment-ecrire-un-plugin-octopress/">la première partie</a>,
je m'étais arrêté sur le code suivant:</p>

<p>``` ruby
module Jekyll
  class LevelTag &lt; Liquid::Tag</p>

<pre><code>def initialize(tagname, level, tokens)
  @level = level
end

def render(context)
  "Niveau : #{@level}"
end
</code></pre>

<p>  end
end
Liquid::Template.register_tag(&lsquo;level&rsquo;, Jekyll::LevelTag)
```</p>

<p>Aujourd'hui je montre comment permettre à l'utilisateur de personnaliser
le contenu du code Html produit.</p>

<!-- more -->


<p>Tout d'abord, voici le code du plugin terminé. Je vous rappelle que vous
pouvez trouver <a href="https://github.com/lkdjiin/octopress-level-tag">ce plugin sur Github</a>.</p>

<p>``` ruby
module Jekyll
  class LevelTag &lt; Liquid::Tag</p>

<pre><code>def initialize(tagname, level, tokens)
  @level = level.strip
end

def render(context)
  config = context.registers[:site].config
  label = config['level_tag_level'] || "Level: "
  level = case @level
  when "1" then config['level_tag_level_1'] || "easy"
  when "2" then config['level_tag_level_2'] || "medium"
  when "3" then config['level_tag_level_3'] || "hard"
  else
    "unknown"
  end
  classes = "class='level-tag level-tag-#{@level}'"
  "&lt;div #{classes}&gt;#{label}&lt;span&gt;#{level}&lt;/span&gt;&lt;/div&gt;"
end
</code></pre>

<p>  end</p>

<p>end
Liquid::Template.register_tag(&lsquo;level&rsquo;, Jekyll::LevelTag)
```</p>

<p>L'appel du plugin dans les articles sera maintenant réalisé comme ceci:</p>

<p><code>ruby
<div class='level-tag level-tag-1'>Niveau : <span>facile</span></div>
</code></p>

<p>Par rapport à la première version, la méthode <code>render</code> a bien enflée. &ndash;
<em>Je trouve qu'il y a trop de code dedans, mais ce sera peut-être le sujet
d'un prochain article sur le refactoring.</em> &ndash; C'est cette méthode qui fait
tout le travail, voici les explications:</p>

<p>``` ruby</p>

<pre><code>def render(context)
  config = context.registers[:site].config
  label = config['level_tag_level'] || "Level: "
</code></pre>

<p>```</p>

<p>C'est l'objet <code>context</code> qui va permettre de récupérer les informations
nécéssaires dans le fichier de configuration <code>_config.yml</code>. Voici par
exemple ce que j'ai ajouté dans mon <code>_config.yml</code>:</p>

<p>``` yaml</p>

<h1>LevelTag plugin</h1>

<p>level_tag_level: &ldquo;Niveau : &rdquo;
level_tag_level_1: &ldquo;facile&rdquo;
level_tag_level_2: &ldquo;intermédiaire&rdquo;
level_tag_level_3: &ldquo;avancé&rdquo;
```</p>

<p>La ligne suivante:</p>

<pre><code>label = config['level_tag_level'] || "Level: "
</code></pre>

<p>initialise la
variable <code>label</code> avec le contenu de <code>level_tag_level</code>, trouvé dans le
<code>_config.yml</code>. La partie du code <code>|| "Level: "</code> est là pour s'assurer que
si <code>level_tag_level</code> n'existe pas dans le fichier de configuration, <code>label</code>
sera bien initialisé avec une valeur par défaut.</p>

<p>``` ruby</p>

<pre><code>  level = case @level
  when "1" then config['level_tag_level_1'] || "easy"
  when "2" then config['level_tag_level_2'] || "medium"
  when "3" then config['level_tag_level_3'] || "hard"
  else
    "unknown"
  end
</code></pre>

<p>```</p>

<p>C'est la même logique que précédement. La variable <code>level</code> sera initialisée
avec du contenu trouvé dans <code>_config.yml</code> ou bien, avec une valeur par
défaut.</p>

<p>``` ruby</p>

<pre><code>  classes = "class='level-tag level-tag-#{@level}'"
  "&lt;div #{classes}&gt;#{label}&lt;span&gt;#{level}&lt;/span&gt;&lt;/div&gt;"
</code></pre>

<p>```</p>

<p>Finalement, comme dans <a href="http://lkdjiin.github.io/blog/2013/07/27/comment-ecrire-un-plugin-octopress/">la première partie</a>,
on retrouve en fin de méthode la production du code Html.</p>

<p>À demain.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bien débuter avec Vim: conseil numéro six]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/07/29/bien-debuter-avec-vim-conseil-numero-six/"/>
    <updated>2013-07-29T08:05:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/07/29/bien-debuter-avec-vim-conseil-numero-six</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<h2>Ne mettez pas n'importe quoi dans votre .vimrc</h2>

<p>Le fichier <code>.vimrc</code> est LE fichier de configuration de Vim. C'est dans ce fichier
que vous personnaliserez votre Vim. C'est donc un fichier très important et on
peut être tenté d'utiliser celui de quelqu'un d'autre. Ne le faites surtout pas
!</p>

<!-- more -->


<p>Vim est un éditeur hautement configurable, paramétrable et personnalisable.
Je peux utiliser le Netbeans ou le Notepad++ de mon collègue mais
j'aurai du mal à utiliser son Vim, tellement il est différent du mien. C'est ce
qui fait la force de Vim, il fini par vous ressembler… À la fin du tutoriel
intégré, vous aurez un fichier <code>.vimrc</code> très suffisant pour commencer. Et vous
devriez suivre une règle simple :</p>

<p><blockquote><p>Ajoutez une ligne à votre .vimrc uniquement si vous comprenez cette ligne.</p></blockquote></p>

<p>Il y a bien sûr des exceptions. Par exemple, si votre clavier est loin
de la disposition <em>azerty</em> ou <em>qwerty</em> (comme moi qui suis en <em>bépo</em>) vous
serez bien
obligé de remapper un certain nombre de touches dès le début. Je vous conseille
aussi fortement de désactiver les touches fléchées. En effet leur usage est
tellement ancré dans nos têtes que vous les utiliserez sans vous en rendre
compte, ce qui ne pourrait que vous ralentir dans votre progression.
Pour cela, ajoutez les lignes suivantes dans votre <code>.vimrc</code> :</p>

<p><code>vim
" Les touches fléchées sont désactivées.
" Utile pour apprendre vim.
"
" En mode normal, vous pourrez les utiliser plus tard
" pour faire quelque chose d'utile.
nnoremap &lt;up&gt; &lt;nop&gt;
nnoremap &lt;down&gt; &lt;nop&gt;
nnoremap &lt;left&gt; &lt;nop&gt;
nnoremap &lt;right&gt; &lt;nop&gt;
" En mode insertion, vous pourrez enlever la
" désactivation dans quelques semaines.
inoremap &lt;up&gt; &lt;nop&gt;
inoremap &lt;down&gt; &lt;nop&gt;
inoremap &lt;left&gt; &lt;nop&gt;
inoremap &lt;right&gt; &lt;nop&gt;
</code></p>

<p>N'hésitez pas à consulter l'aide de vim pour bien comprendre ce que font ces
lignes de code <em>avant</em> de les ajouter dans votre <code>.vimrc</code> ;)</p>

<p>À demain.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pattern matching avec Elixir: une première approche]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/07/28/pattern-matching-avec-elixir-une-premiere-approche/"/>
    <updated>2013-07-28T13:32:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/07/28/pattern-matching-avec-elixir-une-premiere-approche</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Une tâche réccurente quand on utilise la récursivité pour résoudre un problème
est de séparer une liste en deux parties. La première partie étant le premier
élément de la liste et la seconde partie étant ce qui reste. Pour faire cela,
on peut utiliser le <em>pattern matching</em>, qu'on peut traduire par filtrage à
l'aide de motifs.</p>

<!-- more -->


<p>Voyons la syntaxe pour séparer une liste en deux:</p>

<p><code>elixir
[head | tail] = [1, 2, 3]
</code></p>

<p>Après ça, <code>head</code> (la tête) vaut 1 et <code>tail</code> (la queue) vaut [2, 3].
Maintenant les cas exceptionnels: Si on passe une liste d'un seul élément,
<code>tail</code> sera une liste vide ([]). Si on passe une liste vide, et bien c'est
une erreur. Voici une capture d'écran qui montre le résultat:</p>

<p><img src="/images/2013-07-28-1.jpg" width="890" height="577" title="pattern matching avec Elixir" ></p>

<p>Pour illustrer le <em>pattern matching</em> je vais écrire un module avec une fonction
<code>minimum</code> qui doit trouver le plus petit élément dans une liste de nombres
entiers.</p>

<p>``` elixir
defmodule Stats do
  def minimum([head|tail]) do</p>

<pre><code>minimum tail, head
</code></pre>

<p>  end</p>

<p>  defp minimum([], candidate) do</p>

<pre><code>candidate
</code></pre>

<p>  end</p>

<p>  defp minimum([head|tail], candidate) when head &lt; candidate do</p>

<pre><code>minimum tail, head
</code></pre>

<p>  end</p>

<p>  defp minimum([_|tail], candidate) do</p>

<pre><code>minimum tail, candidate
</code></pre>

<p>  end
end
```</p>

<p>On peut l'utiliser comme ceci:</p>

<p><code>elixir
IO.puts Stats.minimum([1, 2, -9, 3])
</code></p>

<p>Voici une explication des différentes fonctions:</p>

<p>``` elixir
  def minimum([head|tail]) do</p>

<pre><code>minimum tail, head
</code></pre>

<p>  end
```</p>

<p>Le <em>pattern matching</em> s'applique directement dans les arguments de la
fonction. Pour cette première passe, on considère que <code>head</code> est à priori
la plus petite valeur de la série.</p>

<p>``` elixir
  defp minimum([], candidate) do</p>

<pre><code>candidate
</code></pre>

<p>  end
```</p>

<p>Là, c'est la clause de sortie de la fonction <code>minimum</code>. Si la liste est
vide, c'est qu'on à trouvé la valeur minimum (<code>candidate</code>).</p>

<p>``` elixir
  defp minimum([head|tail], candidate) when head &lt; candidate do</p>

<pre><code>minimum tail, head
</code></pre>

<p>  end
```</p>

<p>Quand la liste est encore remplie, on compare la valeur de tête à notre
valeur candidate. Je rappelle que <code>candidate</code> est à ce moment la plus petite
valeur trouvée jusqu'ici. Si la valeur de <code>head</code> est plus petite que
la valeur de <code>candidate</code>, la première remplace la dernière.</p>

<p>``` elixir
  defp minimum([_|tail], candidate) do</p>

<pre><code>minimum tail, candidate
</code></pre>

<p>  end
```</p>

<p>Dans les autres cas, la valeur de tête n'a pas d'intérêt, ce que souligne
le caractère <code>_</code> dans <code>[_|tail]</code>. On remplace une variable par <code>_</code>
lorsque cette variable est inutilisée.</p>

<p>Nouveau venu en programmation fonctionnelle, je pense que je n'entrevois là
que la surface du <em>pattern matching</em>.</p>

<p>À demain.</p>
]]></content>
  </entry>
  
</feed>
