<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : débutant | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/debutant/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-07-22T08:11:05+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Mon premier programme Elixir]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/07/22/mon-premier-programme-elixir/"/>
    <updated>2013-07-22T07:52:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/07/22/mon-premier-programme-elixir</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Pour apprendre Elixir, j'ai décidé de faire quelques tâches tirées du
<a href="http://rosettacode.org/wiki/Category:Programming_Tasks">rosetta code</a>.
Pour mon tout premier programme, je commence avec un classique: 99 bottles of beer.</p>

<!-- more -->


<p>Vous connaissez la chanson ? Le but du jeu est d'obtenir ça:</p>

<pre><code>99 bottles of beer on the wall
99 bottles of beer
Take one down, pass it around
98 bottle of beer on the wall

...

1 bottle of beer on the wall
1 bottle of beer
Take one down, pass it around
0 bottles of beer on the wall
</code></pre>

<p>C'est parti. &ndash; <em>N'oubliez pas que c'est mon premier programme Elixir, le code
sera forcement maladroit.</em> &ndash; D'abord une version sans tenir compte du pluriel de &ldquo;bottle&rdquo;.</p>

<p><code>elixir 99_bottle_of_beer_v1.exs
Enum.each 99..1, fn idx -&gt;
  IO.puts "#{idx} bottles of beer on the wall"
  IO.puts "#{idx} bottles of beer"
  IO.puts "Take one down, pass it around"
  IO.puts "#{idx - 1} bottles of beer on the wall"
  IO.puts ""
end
</code></p>

<p>On lance le programme comme ça:</p>

<pre><code>elixir 99_bottle_of_beer_v1.exs
</code></pre>

<p>Il y a pas mal de ressemblance avec Ruby. Notamment, l'interpolation
des chaînes de caractères est identique:</p>

<p><code>elixir
IO.puts "#{idx} bottles of beer on the wall"
</code></p>

<p>La fameuse méthode <code>puts</code> de Ruby est utilisée pour sortir du texte.
Le fait que <code>puts</code> soit appelée d'un module <code>IO</code> me rappelle un peu
Java.
Voyons maintenant l'itération:</p>

<p><code>elixir
Enum.each 99..1, fn idx -&gt;
  # ...
end
</code></p>

<p>Tiens, on a déjà un truc qui ressemble à un pattern: <code>Module.méthode</code>. On
a vu <code>IO.puts</code>, on a maintenant <code>Enum.each</code>. On va donc itérer sur un <em>range</em>
<code>99..1</code>, et appliquer une fonction à chaque élément de ce <em>range</em>. La
fonction, anonyme, avec un argument, débute par <code>fn idx -&gt;</code> ; <code>idx</code> prenant
à chaque itération la valeur de l'élément courant du <em>range</em>.</p>

<p>Je m'intéresse maintenant à une version qui tient compte du pluriel.</p>

<p>``` elixir 99_bottle_of_beer_v2.exs
defmodule Bottles do
  def run do</p>

<pre><code>Enum.each 99..1, fn idx -&gt;
  IO.puts "#{idx} bottle#{plural(idx)} of beer on the wall"
  IO.puts "#{idx} bottle#{plural(idx)} of beer"
  IO.puts "Take one down, pass it around"
  IO.puts "#{idx - 1} bottle#{plural(idx-1)} of beer on the wall"
  IO.puts ""
end
</code></pre>

<p>  end</p>

<p>  def plural num do</p>

<pre><code>if num == 1 do
  ""
else
  "s"
end
</code></pre>

<p>  end
end</p>

<p>Bottles.run
```</p>

<p>J'ai du enfermer mes fonctions dans un module, avec <code>defmodule</code>, puisqu'il
n'est pas permis d'utiliser <code>def</code> en dehors d'un module. L'intérieur de
la fonction <code>run</code> ne diffère pas vraiment de la version précédente.
La fonction <code>plural</code> est intéressante à commenter:</p>

<p>``` elixir
def plural num do
  if num == 1 do</p>

<pre><code>""
</code></pre>

<p>  else</p>

<pre><code>"s"
</code></pre>

<p>  end
end
```</p>

<p>Comme avec Ruby, les arguments n'ont pas besoin d'être enfermés entre
parenthèses, mais on peut le faire. Pas besoin non plus d'un mot-clé
<code>return</code>, une fonction renvoie toujours une valeur, même de manière
implicite. Pour définir une fonction on utilise:
<code>def name args do</code>. Le <code>if</code> prends aussi un <code>do</code> à la fin. Elixir semble
en fait être assez cohérent et homogène:</p>

<pre><code>defmodule ... do ... end
def       ... do ... end
if        ... do ... end
</code></pre>

<p>Enfin, l'appel de la fonction <code>run</code> est sans surprise: <code>Bottles.run</code>. Je note
que je ne sais pas encore à quoi j'ai affaire avec les modules. Est-ce-qu'un
module est juste un espace de nommage ? Est-ce-qu'un module est plus qu'un
espace de nommage ?</p>

<p>Voilà pour une première approche d'Elixir, un langage qui ressemble
beaucoup à Ruby, et en même temps pas vraiment ;)</p>

<p>À demain.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Installer le langage Elixir]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/07/21/installer-le-langage-elixir/"/>
    <updated>2013-07-21T08:56:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/07/21/installer-le-langage-elixir</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Ça fait quelques jours que j'essaie de faire des petits programmes avec
Elixir. J'entends parler de ce nouveau langage depuis plusieurs mois déjà, et
je n'avais pas encore eu le temps de m'amuser un peu avec. C'est chose
faite. Elixir est un langage dynamique, fonctionnel, concurrent, immuable
et on dit qu'il ressemble beaucoup à Ruby. C'est l'occasion pour moi de
débuter une série d'articles consacrés à Elixir. Ça commence aujourd'hui
avec l'installation.</p>

<!-- more -->


<p><em>Je vais décrire l'installation pour Debian, mais ça ne semble pas être
bien différent sur d'autres OS.</em></p>

<h2>Installer d'abord Erlang</h2>

<p>Elixir est bati au-dessus du langage Erlang, il faut donc tout d'abord
installer le compilateur Erlang avant d'installer Elixir à proprement parler.
La version R16B minimum est requise.
La marche à suivre est indiqué sur la page
<a href="https://www.erlang-solutions.com/downloads/download-erlang-otp">download-erlang-otp</a>.
Pour résumer, on ajoute la ligne suivante au fichier <code>/etc/apt/sources.list</code>:</p>

<pre><code>deb http://binaries.erlang-solutions.com/debian squeeze contrib
</code></pre>

<p>Puis on installe la clé:</p>

<pre><code>wget -O - http://binaries.erlang-solutions.com/debian/erlang_solutions.asc \ 
| sudo apt-key add -
</code></pre>

<p>Après y-a-pu-ka:</p>

<pre><code>apt-get update
apt-get install esl-erlang
</code></pre>

<p>On s'assure que l'installation est bien réalisée:</p>

<p>``` bash
xavier:~$ erl
Erlang R16B01 (erts-5.10.2) [source-bdf5300] [smp:2:2] [async-threads:10] [hipe] [kernel-poll:false]</p>

<p>Eshell V5.10.2  (abort with ^G)
1>
```</p>

<h2>Installer Elixir</h2>

<p>Voilà Erlang est installé, c'est maintenant au tour d'Elixir proprement dit.
Pas de chance, il n'y a pas de package pour Debian, je dois donc installer
à partir des <a href="https://github.com/elixir-lang/elixir/tags">sources</a>. C'est
aussi simple que de décompresser l'archive et de taper <code>make</code>. À ce moment
là j'ai quand même un petit doute: pas de dépendances, de lib à installer ?
Mais je comprends vite que c'est Erlang qui est en train de compiler Elixir.
Donc non, tout va bien et ça marche du premier coup. Un petit truc quand
même, Elixir étant installé en local, il faut modifier la variable <code>PATH</code>
du shell pour pas galérer:</p>

<p><code>bash .bashrc
PATH=$PATH:/home/xavier/local/bin/elixir-0.9.3/bin/
</code></p>

<p>Reste à voir si ça fonctionne vraiment:</p>

<p>``` bash
xavier:~$ iex
Erlang R16B01 (erts-5.10.2) [source-bdf5300] [smp:2:2] [async-threads:10] [hipe] [kernel-poll:false]</p>

<p>Interactive Elixir (0.9.3) &ndash; press Ctrl+C to exit (type h() ENTER for help)
iex(1)> 1+1
2
iex(2)>
```</p>

<p>Cool ! L'installation s'est déroulée à merveille, tout marche du premier
coup. C'est bon signe ou pas ?</p>

<h2>Mise à jour d'Elixir</h2>

<p>Il sort pratiquement une nouvelle version d'Elixir par mois ; je sens
que les mises à jour vont faire partie de ma vie d'elixiriste (oui je
l'ai inventé celui-là, comment vous diriez ? Elixirien ?)
En fait, en
écrivant cet article, je m'aperçois que la version 0.10.0 est sortie.
C'est donc ma première mise à jour. Après le téléchargement,
la décompression et le <code>make</code>, il suffit d'accommoder le <code>PATH</code>:</p>

<p><code>bash .bashrc
PATH=$PATH:/home/xavier/local/bin/elixir-0.10.0/bin/
</code></p>

<p>Et la nouvelle version est prête à l'emploi. Si Elixir est aussi sympa que son
installation, ça promet. Affaire à suivre.</p>

<p>À demain.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bien débuter avec Vim: conseil numéro quatre]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/07/19/bien-debuter-avec-vim-conseil-numero-quatre/"/>
    <updated>2013-07-19T07:46:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/07/19/bien-debuter-avec-vim-conseil-numero-quatre</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<h2>Utilisez une version graphique</h2>

<p>Utilisez une version graphique de vim, comme gVim sous Linux et Windows, ou
MacVim sous MacOS, plutôt que la version pour terminal.  À ceci 3 raisons:</p>

<!-- more -->


<p>Tout d'abord, une version graphique de Vim vous permettra d'utiliser votre
police de caractère et votre jeu de couleur préféré sans problème. Dans un
terminal, c'est pas gagné.</p>

<p>Ensuite, une version graphique vous donnera accès à une classique barre
de menu. C'est tout bête, mais au début ça rassure.</p>

<p>Enfin, la barre d'outils fournit trois icônes très utiles pour les
débutants: copier, couper, coller. Pendant la phase d'apprentissage,
vous serez très heureux d'avoir ces icônes sous la main pour
échanger du texte depuis Vim vers une autre application et vice-versa. C'est
donc une exception à mon conseil numéro 2:
<a href="http://lkdjiin.github.io/blog/2013/07/12/bien-debuter-avec-vim-conseil-numero-deux/">Abandonnez la souris</a>.
Bien sûr, Vim possède des commandes au
clavier pour faire ça, mais son système de clipboard/buffer très puissant est
complexe et s'avère franchement déroutant pour le novice.
En temps que débutant vous aurez
bien assez de choses à apprendre comme ça sans vous en rajouter une couche.</p>

<p>À demain.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Comment étendre Git avec ses propres scripts: la suite]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/07/18/comment-etendre-git-avec-ses-propres-scripts-la-suite/"/>
    <updated>2013-07-18T07:39:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/07/18/comment-etendre-git-avec-ses-propres-scripts-la-suite</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p><em>Hier j'ai montré comment ajouter une commande à Git à l'aide d'un script.
Aujourd'hui je fais quelque chose d'utile grâce à ce nouveau pouvoir.</em></p>

<p>Ce que je fais régulierement avec Git c'est:</p>

<ol>
<li>ajouter une fonctionnalité dans la branche <code>ma_branche</code></li>
<li>quand c'est terminé, passer sur la branche <code>master</code></li>
<li>fusionner <code>ma_branche</code> dans <code>master</code></li>
</ol>


<p>Comme je ne travaille jamais directement dans la branche master, ce genre
de <em>merge</em> n'offre jamais de conflits. J'aimerais regrouper les
étapes 2 et 3 en une seule commande: <code>git merge-me</code>.</p>

<!-- more -->


<h2>Trouver la branche courante</h2>

<p>La première étape consiste à retrouver
et retenir le nom de la branche courante. Étant un grand fan de Sed, je
procederais naturellement comme ça:</p>

<pre><code>git branch | sed -n '/\* /s///p'
</code></pre>

<p>Mais je sais que Sed n'a pas les faveurs de tout le monde. J'ai donc fais une
recherche sur StackOverflow pour trouver une autre manière d'obtenir le
même résultat:</p>

<pre><code>git rev-parse --abbrev-ref HEAD
</code></pre>

<p>Je pense que cette seconde solution est meilleure puisque moins fragile, même
si il y a peu de chance que Git change la sortie de <code>git branch</code>. Pour
retenir le nom de la branche, on place la sortie de cette commande dans une
variable Bash:</p>

<p>``` bash git-merge-me</p>

<h1>!/bin/bash</h1>

<p>BRANCH_TO_MERGE=<code>git rev-parse --abbrev-ref HEAD</code>
echo $BRANCH_TO_MERGE
```</p>

<p>Comme en Ruby, les backticks déclenchent la commande et retournent sa
sortie. Le résultat:</p>

<pre><code>xavier:~$ git merge-me
ma_branche
</code></pre>

<p>Maintenant que j'ai vu que ça fonctionnait bien, le reste est un jeu
d'enfant.</p>

<h2>Le script final</h2>

<p>On ajoute les deux commandes Git, ce qui donne:</p>

<p>``` bash git-merge-me</p>

<h1>!/bin/bash</h1>

<p>BRANCH_TO_MERGE=<code>git rev-parse --abbrev-ref HEAD</code>
git checkout master
git merge $BRANCH_TO_MERGE
```</p>

<p>Et voici le script en action:</p>

<pre><code>xavier:~$ git merge-me
Switched to branch 'master'
Updating 48540e6..c584593
Fast-forward
 TODO |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)
xavier:~$ git branch
* master
  ma_branche
</code></pre>

<p>Ma nouvelle commande fait bien le travail que je lui demande.</p>

<h2>Pour aller plus loin</h2>

<p>Vous n'êtes pas limité à l'utilisation de Bash. Vous pouvez utiliser le
langage que vous voulez. À titre d'exemple, voici l'équivalent du script
précédent, cette fois en Ruby.
Toutefois comme ce genre de script va utiliser beaucoup de commandes
système, Ruby n'est peut-être pas le mieux placé. À vous de voir.</p>

<p>``` ruby git-merge-me version Ruby</p>

<h1>!/usr/bin/env ruby</h1>

<p>branch_to_merge = <code>git rev-parse --abbrev-ref HEAD</code>
system &lsquo;git checkout master&rsquo;
system &ldquo;git merge #{branch_to_merge.chomp}&rdquo;
```</p>

<p>On peut aussi combiner script et alias. On donne un nom bien explicite
à notre fichier, comme <code>git-merge-me-into-master</code> et on crée un alias
<code>mm = merge-me-into-master</code>. Ainsi on a une commande rapide sous les
doigts et on peut facilement retrouver le fichier grâce à son nom quand
on doit le modifier.</p>

<p>À demain.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Comment étendre Git avec ses propres scripts]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/07/17/comment-etendre-git-avec-ses-propres-scripts/"/>
    <updated>2013-07-17T08:03:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/07/17/comment-etendre-git-avec-ses-propres-scripts</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Ces derniers jours j'ai montré comment étendre les fonctionnalités
de Git à l'aide des alias (voir les 2 articles précédents). Aujourd'hui
on passe à la suite logique avec la création de nos propres scripts pour
Git.</p>

<p><em>Ce qui suit fonctionne sur Linux et MacOS. Je ne sais pas si c'est
possible sur Windows.</em></p>

<!-- more -->


<p>Un exemple vaut parfois mieux qu'un long discours. Alors créez donc le fichier
<code>git-hello</code> suivant:</p>

<p>``` bash git-hello</p>

<h1>!/bin/bash</h1>

<p>echo Hello
```</p>

<p>Donnez lui les droits d'exécution (<code>chmod +x git-hello</code>) et placez le dans
votre PATH. Moi je le place dans <code>~/bin/</code> et j'ajoute la ligne suivante à
<code>~/.bashrc</code>:</p>

<p><code>bash
PATH=$PATH:/home/xavier/bin
</code></p>

<p>Si vous n'êtes pas sous Linux, vous devrez adapter ces directives pour
votre OS. Une fois que c'est fait, vérifiez si tout fonctionne
correctement:</p>

<pre><code>xavier:~$ git-hello 
Hello
</code></pre>

<p>Maintenant vous vous dites peut-être <em>«Bon d'accord, il vient d'écrire un
script bidon, et alors ? Je vois toujours pas le rapport avec Git !»</em>
Le fichier qu'on vient d'écrire n'est pas nommé n'importe comment. Il
commence par <code>git-</code>. C'est ce qui va permettre à la magie d'opérer:</p>

<pre><code>xavier:~$ git h[Tab]
hello   help    hist    
xavier:~$ git hello
Hello
</code></pre>

<p>La même chose en différé live &ndash;<em> c'est mon dixième article sur ce blog,
je fête ça avec mon tout premier gif, je m'amuse comme je veux…</em> &ndash;</p>

<p><img src="/images/2013-07-17-1.gif"></p>

<p>La règle est simple:</p>

<p><blockquote><p>Un fichier nommé <code>git-foo</code> sera vu par Git comme étant une de ses propres<br/>commandes, nommée <code>foo</code>.</p></blockquote></p>

<p>C'est possible grâce à l'auto complétion programmable de Bash, dont je
parlerais une prochaine fois. Si vous avez défini des alias un peu
complexe, vous auriez peut-être avantage à les placez dans un script pour
profiter de la coloration syntaxique.
Demain, je montrerais un script un
peu plus utile et étoffé que celui-ci :) En attendant, testez vos propres idées.</p>

<p>À demain.</p>
]]></content>
  </entry>
  
</feed>
