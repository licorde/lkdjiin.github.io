<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : elixir | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/elixir/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-08-21T14:54:11+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Une définition de la programmation fonctionnelle avec Elixir]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/16/une-definition-de-la-programmation-fonctionnelle-avec-elixir/"/>
    <updated>2013-08-16T09:17:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/16/une-definition-de-la-programmation-fonctionnelle-avec-elixir</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<h2>Ou ma tentative désespérée de comprendre la non mutabilité</h2>

<p>Cet article est un article égoiste ! Depuis que je joue un peu avec Elixir, je
m'aperçois que j'ai des soucis à comprendre <em>vraiment</em> la programmation
fonctionnelle.
J'ai entre autres, des difficultés à me faire au coté immuable, non-mutable,
de la chose (<em>immutable</em> en anglais). Je tente donc aujourd'hui de
mettre au clair mes idées sur la question. Ce qui suit peut ressembler
à un dialogue de fou, vous êtes prévenus.</p>

<!-- more -->


<p>Revoici le module Somme, que j'ai utilisé dans un <a href="http://lkdjiin.github.io/blog/2013/07/24/elixir-calculer-la-somme-des-n-premiers-entiers-suite-et-fin/">précédent article</a>.</p>

<p><code>elixir somme.exs
defmodule Somme do
  def run(0, acc), do: acc
  def run(n, acc), do: run(n - 1, n + acc)
end
IO.puts Somme.run(5, 0)
</code></p>

<p>Je vais l'écrire dans un bon vieux langage procédural, et analyser ce qu'il
s'y passe.</p>

<p>``` c somme.c</p>

<h1>include&lt;stdio.h></h1>

<p>int main(void)
{</p>

<pre><code>int somme = 0;
for(int n = 5 ; n &gt; 0 ; n--) {
    somme += n;
} 
printf("%i\n", somme);
return 0;
</code></pre>

<p>}
```</p>

<p>On compile et on lance:</p>

<pre><code>$ gcc somme.c -std=c99
$ ./a.out 
15
</code></pre>

<p>Ici pas de récursivité mais une simple itération. Une boucle qui change la
variable <code>somme</code> à chaque passage. Je crois qu'on devrait d'abord définir
ce qu'est une variable. Une variable, c'est un concept. Une variable définit
à la fois un contenant, un contenu et un type, tout cela accessible par un
nom. Notre variable a ici pour nom <code>somme</code>. Son type est <code>int</code>. Son contenu,
ou encore sa valeur est initialement 0 et change à chaque itération. Son
contenant est un emplacement en mémoire, qui lui ne change pas. «<em>Et tu sais ça
comment que ça change pas ?</em>» Bon, puisque j'ai besoin d'une preuve,
j'ajoute un traceur qui affiche l'emplacement mémoire de <code>somme</code>:</p>

<p>``` c</p>

<h1>include&lt;stdio.h></h1>

<p>int main(void)
{</p>

<pre><code>int somme = 0;
printf("%d\n", &amp;somme);
for(int n = 5 ; n &gt; 0 ; n--) {
    somme += n;
    printf("%d\n", &amp;somme);
} 
printf("%i\n", somme);
return 0;
</code></pre>

<p>}
```</p>

<pre><code>$ gcc somme.c -std=c99
$ ./a.out 
-1081032008
-1081032008
-1081032008
-1081032008
-1081032008
-1081032008
15
</code></pre>

<p>Voilà, on le sait maintenant: la <em>valeur</em> de <code>somme</code> change, mais son
<em>emplacement</em> (son contenant) reste identique.</p>

<p>Si je tente maintenant de mimer ce comportement avec Elixir, je serais tenté
d'écrire:</p>

<p><code>elixir
somme = 0
Enum.each 5..1, fn n -&gt;
  somme = somme + n
end
IO.puts somme
</code></p>

<pre><code>$ elixir somme.exs 
/home/xavier/somme.exs:3: variable somme is unused
0
</code></pre>

<p>Comme Elixir est sympa, il tente de me prévenir que quelque chose ne
tourne pas rond. On peut penser à un problème de <em>scope</em>, se dire que le
<code>somme</code> à l'intérieur de la fonction anonyme n'est pas le même que le
<code>somme</code> à l'extérieur de cette fonction. Mais c'est pas ça. Ou
plus exactement ce n'est pas <em>seulement</em> ça:</p>

<p><code>elixir
somme = 100
Enum.each 5..1, fn n -&gt;
  somme = somme + n
  IO.puts somme
end
IO.puts somme
</code></p>

<pre><code>$ elixir somme.exs 
105
104
103
102
101
100
</code></pre>

<p>La valeur du <code>somme</code> de l'intérieur est initialisée à chaque
itération par la valeur du <code>somme</code> de l'extérieur.
Donc le <code>somme</code> extérieur est connu dans la fonction anonyme.
Ce comportement me
fais m'arracher les cheveux, je sens que je passe complètement à coté
d'un truc essentiel. Je sais qu'on n'écrirait pas cette fonction de
cette manière, mais je veux comprendre <em>pourquoi</em> ce comportement
quand je fais ça. En fait donner le même nom à ces deux variables est
une illusion.
Pour Elixir le contenu de <code>somme</code> est immuable, il ne peut pas changer.
Il serait donc plus juste d'écrire ça:</p>

<p><code>elixir
somme = 0
Enum.each 5..1, fn n -&gt;
  temp = somme + n
end
IO.puts somme
</code></p>

<p>Ce qui, évidemment, ne mène à rien. Je commence peut-être à comprendre.
Si je reprend le programme du départ:</p>

<p><code>elixir somme.exs
defmodule Somme do
  def run(0, acc), do: acc
  def run(n, acc), do: run(n - 1, n + acc)
end
IO.puts Somme.run(5, 0)
</code></p>

<p>On voit bien que les variables ne changent (ne mutent) jamais. Ce sont à
chaque fois de <em>nouvelle création</em> qui sont passées dans les paramètres.</p>

<p><code>elixir
def run(n, acc), do: run(n - 1, n + acc)
</code></p>

<p>Lors d'un passage précis dans cette fonction, on se fiche royalement de savoir
quel était l'état de <code>n</code> et de <code>acc</code> lors des passages précédents. Ce qui
n'est pas le cas dans l'exemple en C:</p>

<p>``` c
for(int n = 5 ; n > 0 ; n&mdash;) {</p>

<pre><code>somme += n;
</code></pre>

<p>}
```</p>

<p>À chaque passage dans la boucle, il faut connaître l'état de <code>somme</code> dans
l'itération précédente.</p>

<p>On m'avait pourtant bien dit que la programmation fonctionnelle s'occupait
des <em>transformations</em> et pas des <em>états</em>. Mais je ne voyais pas du tout
ce que ça pouvait bien signifier. C'est maintenant un peu plus clair,
même s'il me reste encore du chemin à parcourir pour bien saisir tout
ce qu'implique la programmation fonctionnelle…</p>

<p>À demain.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elixir et les paramètres par défaut]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/07/elixir-et-les-parametres-par-defaut/"/>
    <updated>2013-08-07T08:46:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/07/elixir-et-les-parametres-par-defaut</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Pour définir un paramètre par défaut dans une fonction de module, Elixir
fournit l'opérateur <code>//</code>:</p>

<p>``` elixir test.exs
defmodule M do
  def foo(a // &ldquo;a&rdquo;) do</p>

<pre><code>IO.puts(a)
</code></pre>

<p>  end
end</p>

<p>M.foo()
M.foo(&ldquo;z&rdquo;)
```</p>

<!-- more -->


<pre><code>$ elixir test.exs 
a
z
</code></pre>

<p>Beaucoup d'autres langages permettent la même chose, en général à l'aide
de l'opérateur d'affection <code>=</code>. Si Elixir utilise <code>//</code> à la place de <code>=</code>,
ça n'est pas par goût de l'étrange ou par snobisme. Avec Elixir l'opérateur
<code>=</code> fait plus que de l'affectation, <code>=</code> fait aussi du
<a href="http://lkdjiin.github.io/blog/2013/07/28/pattern-matching-avec-elixir-une-premiere-approche/">pattern matching</a>.
Et d'après ce que j'ai pu voir, le <em>pattern matching</em> est interdit dans
la définition des paramètres.</p>

<p>On peut bien sûr mixer paramètre <em>normal</em> et paramètre par défaut:</p>

<p>``` elixir test.exs
defmodule M do
  def foo(a, b // &ldquo;b&rdquo;) do</p>

<pre><code>IO.puts "#{a} #{b}"
</code></pre>

<p>  end
end</p>

<p>M.foo(&ldquo;a&rdquo;)
M.foo(&ldquo;a&rdquo;, &ldquo;z&rdquo;)
```</p>

<pre><code>$ elixir test.exs 
a b
a z
</code></pre>

<p>Encore une fois c'est comme avec un tas d'autres langages. On place les
paramètres par défaut à la fin. Mais Elixir va plus loin en permettant
de placer les paramètres par défaut n'importe où:</p>

<p>``` elixir test.exs
defmodule M do
  def foo(a // &ldquo;a&rdquo;, b) do</p>

<pre><code>IO.puts "#{a} #{b}"
</code></pre>

<p>  end
end</p>

<p>M.foo(&ldquo;z&rdquo;)
```</p>

<pre><code>$ elixir test.exs 
a z
</code></pre>

<p>C'est peut-être un classique de la programmation fonctionnelle, mais moi, c'est
la première fois que je vois ça. Je ne sais pas encore si c'est utile, mais
au moins c'est possible. Si vous connaissez d'autres langages qui permettent
ce truc, laissez moi un commentaire, je suis curieux.</p>

<p>À demain.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Comment lire et écrire un fichier texte avec Elixir]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/06/comment-lire-et-ecrire-un-fichier-texte-avec-elixir/"/>
    <updated>2013-08-06T08:43:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/06/comment-lire-et-ecrire-un-fichier-texte-avec-elixir</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Quand j'aborde un nouveau langage j'aime bien regarder l'API pour les
entrées/sorties. Je trouve que ça donne le ton.
Aujourd'hui on voit comment ouvrir, lire et écrire des fichiers texte.</p>

<!-- more -->


<h2>Lire un fichier</h2>

<p><code>elixir
{result, device} = File.open("file.ext", [:read, :utf8])
data = IO.read(device, :line)
File.close(device)
</code></p>

<p><code>result</code> contiendra <code>:ok</code> ou <code>:error</code>. On peut tester ce résultat après
coup ou bien se servir du
<a href="http://lkdjiin.github.io/blog/2013/07/28/pattern-matching-avec-elixir-une-premiere-approche/">pattern matching</a> ainsi:</p>

<p><code>elixir
{:ok, device} = File.open("file.ext", [:read, :utf8])
</code></p>

<p>Lorsque la fin du fichier est atteinte, <code>IO.read</code> retourne <code>:eof</code>.
Si on veut lire un certain nombre de caractères au lieu d'une ligne
complète, on passe le nombre de caractères à lire à la fonction <code>IO.read</code>:</p>

<p><code>elixir
chars = IO.read(device, 3)
</code></p>

<p>On notera qu'il faut penser à fermer le fichier après utilisation, ce que
je trouve toujours bizarre avec un langage moderne. J'attends vraiment que
le runtime fasse ça pour moi.</p>

<h2>Écrire un fichier</h2>

<p><code>elixir
{:ok, device} = File.open("test", [:write, :utf8])
IO.write(device, "foo\n")
IO.puts(device, "bar")
File.close(device)
</code></p>

<p>Pas grand chose à dire, c'est clair. La seule différence entre <code>IO.write</code>
et <code>IO.puts</code> est que cette dernière ajoute le caractère de fin de ligne.</p>

<h2>Les entrées/sorties console</h2>

<p>Pour lire sur la console on utilise <code>IO.gets</code>. Le <em>device</em> est <code>:stdio</code>
par défaut:</p>

<p><code>iex
iex(46)&gt; str = IO.gets(:stdio, "Votre nom: ")
Votre nom: xavier
"xavier\n"
iex(47)&gt; str = IO.gets("Votre nom: ")        
Votre nom: foobar
"foobar\n"
</code></p>

<p>Pour écrire sur la console on utilise <code>IO.puts</code>, mais ça vous le saviez déjà.</p>

<p>``` iex
iex(48)> IO.puts(:stdio, str)      <br/>
foobar</p>

<p>:ok
iex(49)> IO.puts(str)      <br/>
foobar</p>

<p>:ok
```</p>

<h2>Pour finir</h2>

<p>Voilà, c'est suffisant pour commencer à bidouiller. Pour aller plus loin,
on pourra lire la documentation des modules IO et File, qui permettent de
faire bien d'autres choses…</p>

<p>À demain.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pattern matching avec Elixir: une première approche]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/07/28/pattern-matching-avec-elixir-une-premiere-approche/"/>
    <updated>2013-07-28T13:32:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/07/28/pattern-matching-avec-elixir-une-premiere-approche</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Une tâche réccurente quand on utilise la récursivité pour résoudre un problème
est de séparer une liste en deux parties. La première partie étant le premier
élément de la liste et la seconde partie étant ce qui reste. Pour faire cela,
on peut utiliser le <em>pattern matching</em>, qu'on peut traduire par filtrage à
l'aide de motifs.</p>

<!-- more -->


<p>Voyons la syntaxe pour séparer une liste en deux:</p>

<p><code>elixir
[head | tail] = [1, 2, 3]
</code></p>

<p>Après ça, <code>head</code> (la tête) vaut 1 et <code>tail</code> (la queue) vaut [2, 3].
Maintenant les cas exceptionnels: Si on passe une liste d'un seul élément,
<code>tail</code> sera une liste vide ([]). Si on passe une liste vide, et bien c'est
une erreur. Voici une capture d'écran qui montre le résultat:</p>

<p><img src="/images/2013-07-28-1.jpg" width="890" height="577" title="pattern matching avec Elixir" ></p>

<p>Pour illustrer le <em>pattern matching</em> je vais écrire un module avec une fonction
<code>minimum</code> qui doit trouver le plus petit élément dans une liste de nombres
entiers.</p>

<p>``` elixir
defmodule Stats do
  def minimum([head|tail]) do</p>

<pre><code>minimum tail, head
</code></pre>

<p>  end</p>

<p>  defp minimum([], candidate) do</p>

<pre><code>candidate
</code></pre>

<p>  end</p>

<p>  defp minimum([head|tail], candidate) when head &lt; candidate do</p>

<pre><code>minimum tail, head
</code></pre>

<p>  end</p>

<p>  defp minimum([_|tail], candidate) do</p>

<pre><code>minimum tail, candidate
</code></pre>

<p>  end
end
```</p>

<p>On peut l'utiliser comme ceci:</p>

<p><code>elixir
IO.puts Stats.minimum([1, 2, -9, 3])
</code></p>

<p>Voici une explication des différentes fonctions:</p>

<p>``` elixir
  def minimum([head|tail]) do</p>

<pre><code>minimum tail, head
</code></pre>

<p>  end
```</p>

<p>Le <em>pattern matching</em> s'applique directement dans les arguments de la
fonction. Pour cette première passe, on considère que <code>head</code> est à priori
la plus petite valeur de la série.</p>

<p>``` elixir
  defp minimum([], candidate) do</p>

<pre><code>candidate
</code></pre>

<p>  end
```</p>

<p>Là, c'est la clause de sortie de la fonction <code>minimum</code>. Si la liste est
vide, c'est qu'on à trouvé la valeur minimum (<code>candidate</code>).</p>

<p>``` elixir
  defp minimum([head|tail], candidate) when head &lt; candidate do</p>

<pre><code>minimum tail, head
</code></pre>

<p>  end
```</p>

<p>Quand la liste est encore remplie, on compare la valeur de tête à notre
valeur candidate. Je rappelle que <code>candidate</code> est à ce moment la plus petite
valeur trouvée jusqu'ici. Si la valeur de <code>head</code> est plus petite que
la valeur de <code>candidate</code>, la première remplace la dernière.</p>

<p>``` elixir
  defp minimum([_|tail], candidate) do</p>

<pre><code>minimum tail, candidate
</code></pre>

<p>  end
```</p>

<p>Dans les autres cas, la valeur de tête n'a pas d'intérêt, ce que souligne
le caractère <code>_</code> dans <code>[_|tail]</code>. On remplace une variable par <code>_</code>
lorsque cette variable est inutilisée.</p>

<p>Nouveau venu en programmation fonctionnelle, je pense que je n'entrevois là
que la surface du <em>pattern matching</em>.</p>

<p>À demain.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le problème des 100 portes en Elixir]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/07/25/le-probleme-des-100-portes-en-elixir/"/>
    <updated>2013-07-25T07:35:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/07/25/le-probleme-des-100-portes-en-elixir</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Je continue mon périple parmi le <a href="http://rosettacode.org/wiki/">rosetta code</a>
en m'attaquant au problème des «100 doors».</p>

<p><blockquote><p>Problem: You have 100 doors in a row that are all initially closed. You make 100 passes by the doors. The first time through, you visit every door and toggle the door (if the door is closed, you open it; if it is open, you close it). The second time you only visit every 2nd door (door #2, #4, #6, &hellip;). The third time, every 3rd door (door #3, #6, #9, &hellip;), etc, until you only visit the 100th door.</p></p><p><p>Question: What state are the doors in after the last pass? Which are open, which are closed?</p><footer><strong>Rosetta Code <a href="http://rosettacode.org/wiki/100_doors">http://rosettacode.org/wiki/100_doors</a> 100 doors</strong></footer></blockquote></p>

<!-- more -->


<p>Je me dis que je vais d'abord le faire dans un langage que je connais bien
pour voir de quoi il retourne, et si il n'y a pas de pièges cachés. En
quelques lignes de Ruby, le tour est joué:</p>

<p>``` ruby 100 doors en Ruby
doors = Array.new(100)</p>

<p>(1..100).each do |interval|
  doors.map!.with_index do |elem, idx|</p>

<pre><code>(idx+1) % interval == 0 ? !elem : elem
</code></pre>

<p>  end
end</p>

<h1>Écrire le numéro des portes ouvertes.</h1>

<p>doors.each_with_index {|e, i| puts i+1 if e }
```</p>

<p>Voyant cela j'ai pensé que ça allait être assez simple à implémenter en
Elixir. Pas du tout. J'ai galéré longtemps avant de trouver la solution qui
va suivre. Mon plus gros problème avec Elixir est que les variables sont
non-mutables. Une fois définie, une variable ne change pas. Il faut donc
faire appel constament à la récursivité. Je ne nie pas les avantages d'un
tel système (pas d'effets de bords) mais ce n'est pas évident de s'y faire quand
on vient comme moi du monde procédural ou objet. Trêve de baratin, voici
ma solution avec Elixir:</p>

<p>``` elixir 100 doors en Elixir
defmodule Doors do</p>

<p>  def soluce do</p>

<pre><code>doors = Enum.map 1..100, fn _ -&gt; false end
run(doors, 1)
</code></pre>

<p>  end</p>

<p>  defp run(doors, interval) when interval > 100 do</p>

<pre><code>doors
</code></pre>

<p>  end</p>

<p>  defp run doors, interval do</p>

<pre><code>run(switch_doors(doors,interval), interval + 1)
</code></pre>

<p>  end</p>

<p>  defp switch_doors(doors, interval) do</p>

<pre><code>stream = Stream.with_index(doors)
list = Enum.to_list(stream)
Enum.map list, fn e -&gt;
  door = elem e, 0
  index = elem(e, 1) + 1
  switch_door rem(index, interval), door
end
</code></pre>

<p>  end</p>

<p>  defp switch_door(0, door), do: not door
  defp switch_door(_, door), do: door
end</p>

<p>soluce = Doors.soluce
Enum.each Enum.to_list(Stream.with_index(soluce)), fn e &ndash;>
  if elem(e, 0) == true, do: IO.puts elem(e, 1) + 1
end
```</p>

<p>Plutôt long comparé à la version Ruby, hein ? Quoiqu'il en soit, j'en suis
fier, j'ai mis du temps à la pondre, cette version. Je pense que quelqu'un
connaissant bien Elixir doit pouvoir nettement améliorer mon code. Je
vais le poster sur la mailing-list et demander ce qu'il en
pense. Si j'ai des retours (ce dont je ne doute pas) je mettrais la
version améliorée dans un prochain article. En attendant je vais
commenter un peu mon code pour l'expliquer.</p>

<p><code>elixir
def soluce do
  doors = Enum.map 1..100, fn _ -&gt; false end
  run(doors, 1)
end
</code></p>

<p><code>soluce</code> est la seule fonction publique du module. Elle initialise une liste
de 100 éléments avec la valeur <code>false</code>. Puis elle commence le travail avec
<code>run(doors, 1)</code>, <code>1</code> étant le premier intervalle de la série, c'est à dire
qu'on passe par toutes les portes. Une fois la solution découverte, elle est
renvoyée explicitement. Si vous connaissez Ruby, vous savez à quoi je fais
référence, sinon, sachez qu'en Elixir toutes les fonctions renvoie une valeur,
et qu'on a pas besoin de l'indiquer. C'est implicite, la dernière évaluation
est renvoyée. Notez aussi l'usage de <code>_</code> qui indique qu'on se fiche du contenu
de la variable.</p>

<p>``` elixir
defp run(doors, interval) when interval > 100 do
  doors
end</p>

<p>defp run doors, interval do
  run(switch_doors(doors,interval), interval + 1)
end
```</p>

<p>La première version de <code>run</code> comporte un <em>guard</em>. Elle n'est utilisée que
lorsque <code>interval</code> est supérieur à 100. C'est notre clause de sortie de la
fonction récursive.</p>

<p>La seconde version de <code>run</code> est utilisée dans tout les autres cas. Elle se
contente de s'appeller elle-même (récursivité) avec une liste des portes
mise à jour et un intervalle incrémenté.</p>

<p>``` elixir
defp switch_doors(doors, interval) do
  stream = Stream.with_index(doors)
  list = Enum.to_list(stream)
  Enum.map list, fn e &ndash;></p>

<pre><code>door = elem e, 0
index = elem(e, 1) + 1
switch_door rem(index, interval), door
</code></pre>

<p>  end
end
```</p>

<p><code>switch_doors</code> est responsable de fabriquer une nouvelle liste de portes.
C'est la fonction qui m'a tenu en échec pendant des heures, jusqu'à ce que
je découvre le module <code>Stream</code>. Voyons <code>switch_doors</code> en détails:</p>

<p><code>elixir
stream = Stream.with_index(doors)
list = Enum.to_list(stream)
</code></p>

<p>Je crée une nouvelle liste qui va embarquer les valeurs de <code>doors</code>
en les associant aux indexs. <code>list</code> va ressembler à ça:</p>

<pre><code>[{false, 0}, {false, 1}, {false, 2}, ... {false, 99}]
</code></pre>

<p>Qui en Elixir peut aussi être représenté ainsi:</p>

<pre><code>[false: 0, false: 1 ...
</code></pre>

<p><code>elixir
Enum.map list, fn e -&gt;
  door = elem e, 0
  index = elem(e, 1) + 1
  switch_door rem(index, interval), door
end
</code></p>

<p><code>Enum.map</code> fabrique et renvoie une nouvelle version de la liste des portes.
Chaque élément de <code>list</code> (chaque <code>{false, 0}</code>) passe à travers une fonction
anonyme qui renvoie false ou true, selon le résultat de index modulo interval.</p>

<p><code>elixir
defp switch_door(0, door), do: not door
defp switch_door(_, door), do: door
</code></p>

<p>Si le modulo égal zéro, on inverse l'état de la porte. Sinon la porte doit
rester dans le même état.</p>

<p><code>elixir
Enum.each Enum.to_list(Stream.with_index(soluce)), fn e -&gt;
  if elem(e, 0) == true, do: IO.puts elem(e, 1) + 1
end
</code></p>

<p>J'écris les numéros des portes ouvertes. Avec mes explications qui précèdent,
j'espère que vous pourrez comprendre comment ça marche.</p>

<p>À demain.</p>
]]></content>
  </entry>
  
</feed>
