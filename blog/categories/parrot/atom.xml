<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : parrot | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/parrot/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-08-02T09:37:15+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Implémenter un langage sur la machine virtuelle Parrot: partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/02/implementer-un-langage-sur-la-machine-virtuelle-parrot-partie-2/"/>
    <updated>2013-08-02T09:07:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/02/implementer-un-langage-sur-la-machine-virtuelle-parrot-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p><em>Aujourd'hui je m'intéresse à</em>
<a href="http://www.parrot.org/">Parrot</a>.
<em>Après une brève description de cette
machine virtuelle, on l'installe et on écrit un premier programme.</em></p>

<!-- more -->


<h2>Présentation de Parrot</h2>

<p>La machine virtuelle Parrot offre un nombre illimité de registre,
qui sont de 4 types différents:</p>

<ul>
<li>Integer, pour les nombres entiers</li>
<li>Number, pour les nombres réels</li>
<li>String, pour les chaînes de caractères</li>
<li>PMC, pour, en gros, les objets (Polymorphic container)</li>
</ul>


<p>Les instructions peuvent être entrées sous 4 formes différentes, du plus
haut-niveau vers le plus bas:</p>

<ol>
<li>PIR, <em>Parrot Intermediate Representation</em>, qui ressemble à un assembleur
de haut-niveau.</li>
<li>PASM, <em>Parrot Assembly</em>, qui est un assembleur classique, sans fioritures.</li>
<li>PAST, <em>Parrot Abstract Syntax Tree</em>, qui accepte un
<a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree">AST</a> en entrée.</li>
<li>PBC, <em>Parrot Byte Code</em>, le code machine de Parrot.</li>
</ol>


<p>Est-ce-que j'ai vraiment besoin de dire que, si possible, je me limiterais
à PIR ?</p>

<p>Enfin, Parrot possède un
<a href="http://fr.wikipedia.org/wiki/Ramasse-miettes_%28informatique%29">Garbage Collector</a>.
On aura pas besoin de s'acharner
à libérer la mémoire, Parrot le fait pour nous.</p>

<h2>Installation de Parrot</h2>

<p>Avant de pouvoir jouer avec Parrot, il faut l'installer.
Le point de départ est sur
<a href="http://www.parrot.org/source.html">www.parrot.org/source.html</a>.
Sur ma machine Debian, j'ai d'abord installé la version de Parrot qui se
trouve dans les dépots. Le problème c'est que pas mal d'outils annexes
demandent à avoir un <em>working repository</em>, ils ne sont pas inclus dans les
paquets. De plus, les sources ont l'air de contenir pas mal d'exemples.
J'ai donc désinstallé le package pour Debian et rapatrié les sources depuis
Github : <a href="https://github.com/parrot/parrot">github.com/parrot/parrot</a>.
L'installation s'est déroulée sans soucis particuliers. Comme je trouve la
documentation un peu confuse sur ce point, voilà comment j'ai fait ; si ça
peut vous éviter de chercher…</p>

<pre><code>perl Configure.pl
make
make test
sudo make install
</code></pre>

<h2>Hello Parrot</h2>

<p>On s'attaque enfin à l'écriture du classique <em>hello world</em>:</p>

<p><code>nasm hello.pir
.sub main
  say "Hello world"
.end
</code></p>

<p>On le lance ainsi:</p>

<pre><code>parrot hello.pir
</code></pre>

<p>Maintenant que Parrot est installé et fonctionnel, on va pouvoir écrire quelques
petits programmes en PIR.</p>

<p>À demain.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Implémenter un langage sur la machine virtuelle Parrot: partie 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/01/implementer-un-langage-sur-la-machine-virtuelle-parrot-partie-1/"/>
    <updated>2013-08-01T07:59:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/01/implementer-un-langage-sur-la-machine-virtuelle-parrot-partie-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Cela fait quelques années que j'ai envie d'essayer la
<a href="https://fr.wikipedia.org/wiki/Machine_virtuelle">machine virtuelle</a>
<a href="http://www.parrot.org/">Parrot</a> et j'ai toujours reporté à plus tard.
Jusqu'à maintenant. Aujourd'hui, je commence à écrire un
<a href="http://en.wikipedia.org/wiki/Toy_language">toy language</a>
qui tournera sur Parrot.</p>

<p>Pour implémenter un langage sur Parrot, il faut d'abord … un langage.
Simple de préférence, avec peu de fonctionnalités, au moins pour
démarrer.
Je vais en inventer un pour l'occasion, ce qui sera bien plus drôle que
d'utiliser un sous-ensemble d'un langage déjà existant.</p>

<!-- more -->


<h2>Le langage naam</h2>

<p>Naam signifie No Assignment, Automatic Memoization.
Je rappelle qu'il s'agit d'un <em>toy language</em>, l'objectif étant
d'expérimenter, et non de produire le prochain succès planétaire.
Pour le moment, et peut-être pour toujours, le langage sera limité
à l'utilisation des nombres entiers. Pas de nombres à virgule, pas de
chaînes, pas d'objets… Je viens de passer quelques jours à envisager
une syntaxe. Mais la reflexion n'est pas terminée et elle pourrait
changer d'ici à l'implémentation de naam. Voici des exemples:</p>

<pre><code>sign(n)=
1  if n &gt; 0
-1 if n &lt; 0
0  else

print sign(3)
</code></pre>

<p>Les détails:</p>

<pre><code>sign(n)=
</code></pre>

<p>C'est la définition d'une fonction <code>sign</code>.</p>

<pre><code>1  if n &gt; 0
-1 if n &lt; 0
</code></pre>

<p>Si <code>n</code> est positif on renvoie 1. Si <code>n</code> est négatif on renvoie -1.</p>

<pre><code>0  else
</code></pre>

<p>Dans les autres cas (il reste le cas du zéro) on renvoie 0. Le mot <code>else</code>
marque aussi la fin de la fonction.</p>

<p>Voici maintenant ce que pourrait être la fonction factorielle:</p>

<pre><code>!(n)=
1            if 0
n * .(n - 1) if n &gt; 0
else

print !(7)
</code></pre>

<p>Et le détail:</p>

<pre><code>!(n)=
</code></pre>

<p>On définit la fonction <code>!</code>. Le nom d'une fonction n'a pas à être composé
de lettres. Des signes font aussi bien l'affaire.</p>

<pre><code>1            if 0
</code></pre>

<p>Quand l'argument vaut zéro, on renvoie 1.</p>

<pre><code>n * .(n - 1) if n &gt; 0
</code></pre>

<p>Dans les cas où <code>n</code> est positif, on renvoie <code>n</code> multiplié
par la factorielle de <code>n - 1</code>.
Le point (<code>.</code>) signifie «la fonction elle-même».</p>

<pre><code>else
</code></pre>

<p>Enfin, dans les autres cas (qui ici sont <code>n</code> est négatif) on renvoie du
vide, rien, nada. Comme une fonction est dans l'obligation de renvoyer
une valeur, cela provoquera une erreur (ce qui est voulu).</p>

<p>Un dernier exemple pour terminer, la fonction d'Ackermann. Je ne vais pas
la commenter, la seule différence avec ce que j'ai montré avant est
qu'il y a deux arguments :</p>

<pre><code>ackermann(m, n)=
n + 1                 if 0, n
.(m - 1, 1)           if m &gt; 0, 0
.(m - 1, .(m, n - 1)) else

print ackermann(2, 3)
</code></pre>

<p>On pourrait aussi écrire la même fonction de la manière suivante (je n'ai
pas encore décidé si naam supporterait les deux syntaxes ou non):</p>

<pre><code>ackermann(0, n)     = n + 1
ackermann(m &gt; 0, 0) = .(m - 1, 1)
ackermann(m, n)     = .(m - 1, .(m, n - 1))
</code></pre>

<p>Alors, qu'en pensez vous. Est-ce-que ça vous dit de voir naître un
<em>toy language</em> au jour le jour ? Que pensez vous de naam ?</p>

<p>La prochaine fois on installe Parrot et on joue un peu avec pour sentir le truc.</p>

<p>À demain.</p>
]]></content>
  </entry>
  
</feed>
