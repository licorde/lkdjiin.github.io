<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : intermédiaire | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/intermediaire/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-08-11T10:54:13+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Parrot 5: un plan pour écrire un compilateur]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/11/parrot-5-un-plan-pour-ecrire-un-compilateur/"/>
    <updated>2013-08-11T10:47:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/11/parrot-5-un-plan-pour-ecrire-un-compilateur</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Après avoir fini le tour d'horizon de l'assembleur PIR dans
<a href="http://lkdjiin.github.io/blog/2013/08/10/implementer-un-langage-sur-la-machine-virtuelle-parrot-partie-4/">la quatrième partie</a>
je digresse un peu sur ce qui nous attends dans les prochains épisodes.</p>

<!-- more -->


<h2>Un plan pour écrire un compilateur</h2>

<p>Maintenant qu'on sait écrire des programmes en PIR suffisament
évolués pour fournir un début de support au magnifique langage Naam,
il est plus que temps d'écrire le compilateur Naam vers PIR.
Pour ça, il y a plusieurs solutions.</p>

<p>La première est d'utiliser les outils fournis avec Parrot sous le nom
de PCT: Parrot Compiler Tools. PCT a vraiment l'air très bien et devrait
faire l'affaire pour certains. Malheureusement pour moi, les outils PCT
sont écrits en Perl, langage que je ne connais vraiment pas assez. J'ai
essayé mais y a pas eu moyen. Si vous connaissez bien Perl, je pense que
vous serez très heureux avec les PCT. Sinon, il faut se tourner
vers autre chose.</p>

<p>La seconde solution est plus old-school. On écrit un compilateur en C à l'aide
de Lex et Yacc,
<a href="http://flex.sourceforge.net/">Flex</a>
et <a href="http://www.gnu.org/software/bison/">Bison</a>, etc. Encore une fois, comme
pour PCT, ce sont de très bons outils. Mais j'ai déjà donné, ils
sont aussi ennuyeux qu'ils sont excellents. Pour mémoire,
j'écris un <em>toy language</em> pour le fun.</p>

<p>Ça me laisse une troisième solution: tout écrire <em>from scratch</em> en Ruby.
Ça c'est fun.</p>

<p>J'ai une certaine expérience dans le domaine. J'ai écrit des assembleurs,
des compilateurs, des interpréteurs. En C, en python, en Java, en Ruby.
Avec ou sans outils tiers. Certains projets ont aboutis et d'autres ont
échoués mais à chaque fois j'appris quelque chose. Tout ça pour vous dire
que je sais assez bien dans quoi je m'embarque. Naam est, et restera, un
langage très simple. Comme je sais où je vais, écrire un compilateur
Naam vers PIR en Ruby ne sera pas trop difficile.
Je n'écrirais surement pas un code performant. Au contraire, je
m'attacherais uniquement à produire un code facile à lire.
Il nous faudra un analyseur lexical (un <em>tokenizer</em> et un <em>lexer</em>), un
analyseur syntaxique (pour les fameuses <em>Syntax Error</em>). On aura peut-être
besoin de produire un AST (<em>Abstract Syntax Tree</em>) mais surement pas dès
le début. On aura aussi intêret à écrire la grammaire du langage. Il y
arrivera un moment où il faudra se pencher sur les messages d'erreurs
du compilateur. Après ça on avisera.</p>

<p>Un compilateur est après tout un programme comme un autre, donc je ne vois
pas de raisons de ne pas l'écrire par améliorations successives. L'objectif
initial sera donc simplement de compiler et faire tourner le programme suivant:</p>

<pre><code>sign(n)=
1  if n &gt; 0
-1 if n &lt; 0
0  else

print sign(-123)
</code></pre>

<p>La prochaine fois on commence par le commencement en écrivant le
<a href="http://en.wikipedia.org/wiki/Tokenization">tokenizer</a>.</p>

<p>À demain.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Implémenter un langage sur la machine virtuelle Parrot - partie 4]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/10/implementer-un-langage-sur-la-machine-virtuelle-parrot-partie-4/"/>
    <updated>2013-08-10T11:21:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/10/implementer-un-langage-sur-la-machine-virtuelle-parrot-partie-4</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Après avoir vu un premier
<a href="http://lkdjiin.github.io/blog/2013/08/03/implementer-un-langage-sur-la-machine-virtuelle-parrot-partie-3/">programme très simple</a>
en PIR la dernière fois, on s'attaque aujourd'hui au calcul de la
factorielle. C'est pas beaucoup plus compliqué, mais
on va employer les registres de la VM Parrot.</p>

<!-- more -->


<h2>La procédure factorial</h2>

<p>``` gas
.sub factorial
  .param int n
  .local int result</p>

<p>  if n == 0 goto ONE</p>

<p>  $I0 = n &ndash; 1
  $I1 = factorial($I0)
  result = n * $I1
  goto RETURN</p>

<p>ONE:
  result = 1</p>

<p>RETURN:
  .return(result)
.end</p>

<p>.sub main :main
  .local int out
  out = factorial(10)
  say out
.end
```</p>

<p>Ce qui est nouveau, c'est qu'ici j'utilise les registres:</p>

<pre><code>$I0 = n - 1
$I1 = factorial($I0)
result = n * $I1
goto RETURN
</code></pre>

<p>En PIR, il n'est pas possible d'écrire directement:</p>

<pre><code>factorial(n - 1)
</code></pre>

<p>et encore moins:</p>

<pre><code>result = n * factorial(n - 1)
</code></pre>

<p>J'utilise donc les registres pour stocker les résultats temporaires.
Ils sont simples à utiliser et leur nombre est illimité.</p>

<p>Il faut noter qu'il n'y a pas d'obligation à utiliser les registres ici.
J'aurais aussi bien pu écrire le programme ainsi:</p>

<p>``` gas
.sub factorial</p>

<pre><code>.param int n
.local int result, temp1, temp2

if n == 0 goto ONE

temp1 = n - 1
temp2 = factorial(temp1)
result = n * temp2
goto RETURN

...
</code></pre>

<p>```</p>

<p>Mais je voulais montrer l'utilisation des registres.</p>

<p>Voilà, même si PIR permet de faire d'autres choses, je pense que j'en sais
suffisament sur lui pour commencer à
<a href="http://lkdjiin.github.io/blog/2013/08/01/implementer-un-langage-sur-la-machine-virtuelle-parrot-partie-1/">implémenter Naam</a>.</p>

<p>À demain.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Implémenter un langage sur la machine virtuelle Parrot: partie 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/03/implementer-un-langage-sur-la-machine-virtuelle-parrot-partie-3/"/>
    <updated>2013-08-03T08:16:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/03/implementer-un-langage-sur-la-machine-virtuelle-parrot-partie-3</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Après avoir vu
<a href="http://lkdjiin.github.io/blog/2013/08/02/implementer-un-langage-sur-la-machine-virtuelle-parrot-partie-2/">l'installation de Parrot</a>,
il est temps d'écrire
notre premier programme en PIR. On va réaliser une version simpliste
d'une fonction qui renvoie le signe d'un nombre entier. On oublie
momentanément l'existence du zéro pour n'avoir que deux cas à traiter:
positif ou négatif.</p>

<pre><code>simple_sign(n) = 1 si n &gt; 0
simple_sign(n) = -1 sinon
</code></pre>

<!-- more -->


<h2>La procédure simple_sign</h2>

<p>Voici un programme PIR qui fait ça:</p>

<p>``` gas simple_sign.pir
.sub simple_sign
  .param int n</p>

<p>  .local int result</p>

<p>  if n > 0 goto POSITIVE</p>

<p>  result = -1
  goto RETURN</p>

<p>POSITIVE:
  result = 1</p>

<p>RETURN:
  .return(result)
.end</p>

<p>.sub main :main
  .local int f
  f = simple_sign(4)
  say f
.end
```</p>

<p>Pour le lancer:</p>

<pre><code>parrot simple_sign.pir
</code></pre>

<p>Comme c'est de l'assembleur, le plus simple est d'expliquer les lignes de
code une par une.</p>

<pre><code>.sub simple_sign
</code></pre>

<p>C'est la définition d'une procédure <code>simple_sign</code>.</p>

<pre><code>.param int n
</code></pre>

<p>On signale à l'assembleur que notre fonction <code>simple_sign</code> prend un
argument de type <code>int</code> et qu'on souhaite s'y réferer
par la suite à l'aide du nom <code>n</code>. Ça ressemble donc fortement à une
déclaration de variable.</p>

<pre><code>.local int result
</code></pre>

<p>Cette fois on déclare une variable locale nommée. Elle est de type <code>int</code> et
on pourra s'y réferer avec le nom <code>result</code>.</p>

<pre><code>if n &gt; 0 goto POSITIVE
</code></pre>

<p>Littéralement: Si la valeur de n est supérieur à zéro, sauter à l'adresse
réferencée par le label POSITIVE. Le saut conditionnel ou non est la seule
instruction de branchement dont on dispose avec PIR. Vous avez surement
appris que «goto c'est mal !». Oubliez le:</p>

<p><blockquote><p>En assembleur, goto est normal.</p></blockquote></p>

<p>Et c'est souvent la seule façon d'obtenir le résultat voulu.</p>

<pre><code>result = -1
</code></pre>

<p>Voilà comment affecter une valeur.</p>

<pre><code>goto RETURN
</code></pre>

<p>Voilà un saut inconditionnel vers l'adresse réferencée par le label
RETURN.</p>

<pre><code>POSITIVE:
  result = 1
</code></pre>

<p><code>POSITIVE:</code> définit une adresse. Chaque fois qu'on écrit <code>goto POSITIVE</code>, le
programme débranche à cette adresse (en fait à la ligne de code suivante).
Notez qu'on peut écrire les deux lignes précédentes en une seule :
<code>POSITIVE: result = 1</code>.</p>

<pre><code>RETURN:
  .return(result)
</code></pre>

<p>Définition du label RETURN puis renvoi du résultat avec la directive
<code>.return</code>. Les instructions qui commencent par un <code>.</code> sont des directives.
Ce qui veut dire qu'elles seront remplacées dans notre dos par plusieurs
instructions de plus bas niveau.</p>

<pre><code>.end
</code></pre>

<p>Fin de notre procédure <code>simple_sign</code>.</p>

<pre><code>.sub main :main
</code></pre>

<p>Nouvelle procédure, nommée <code>main</code>. Le <code>:main</code> dit à Parrot que c'est cette
procédure qu'il faut lancer à l'ouverture du programme. Si on ne le fait
pas, Parrot lance la première procédure qu'il rencontre.</p>

<pre><code>.local int f
f = simple_sign(4)
say f
.end
</code></pre>

<p>La fin du programme se comprend maintenant facilement.</p>

<p>Voilà, si vous avez déjà travaillé en assembleur, la syntaxe PIR ne
devrait pas vous poser de problèmes particuliers car c'est un
assembleur de plutôt haut niveau ; par exemple on n'a pas encore eu
besoin de manipuler directement les registres. Si au contraire c'est
votre première rencontre avec un assembleur, vous allez devoir apprendre
à décomposer vos actions/pensées. Par exemple vous pourriez être tenté
d'écrire la procédure <code>main</code> de cette façon:</p>

<pre><code>.sub main :main
  say simple_sign(4)
.end
</code></pre>

<p>Mais ça ne marcheras pas, il faut décomposer…</p>

<p>À demain.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Implémenter un langage sur la machine virtuelle Parrot: partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/02/implementer-un-langage-sur-la-machine-virtuelle-parrot-partie-2/"/>
    <updated>2013-08-02T09:07:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/02/implementer-un-langage-sur-la-machine-virtuelle-parrot-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p><em>Aujourd'hui je m'intéresse à</em>
<a href="http://www.parrot.org/">Parrot</a>.
<em>Après une brève description de cette
machine virtuelle, on l'installe et on écrit un premier programme.</em></p>

<!-- more -->


<h2>Présentation de Parrot</h2>

<p>La machine virtuelle Parrot offre un nombre illimité de registre,
qui sont de 4 types différents:</p>

<ul>
<li>Integer, pour les nombres entiers</li>
<li>Number, pour les nombres réels</li>
<li>String, pour les chaînes de caractères</li>
<li>PMC, pour, en gros, les objets (Polymorphic container)</li>
</ul>


<p>Les instructions peuvent être entrées sous 4 formes différentes, du plus
haut-niveau vers le plus bas:</p>

<ol>
<li>PIR, <em>Parrot Intermediate Representation</em>, qui ressemble à un assembleur
de haut-niveau.</li>
<li>PASM, <em>Parrot Assembly</em>, qui est un assembleur classique, sans fioritures.</li>
<li>PAST, <em>Parrot Abstract Syntax Tree</em>, qui accepte un
<a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree">AST</a> en entrée.</li>
<li>PBC, <em>Parrot Byte Code</em>, le code machine de Parrot.</li>
</ol>


<p>Est-ce-que j'ai vraiment besoin de dire que, si possible, je me limiterais
à PIR ?</p>

<p>Enfin, Parrot possède un
<a href="http://fr.wikipedia.org/wiki/Ramasse-miettes_%28informatique%29">Garbage Collector</a>.
On aura pas besoin de s'acharner
à libérer la mémoire, Parrot le fait pour nous.</p>

<h2>Installation de Parrot</h2>

<p>Avant de pouvoir jouer avec Parrot, il faut l'installer.
Le point de départ est sur
<a href="http://www.parrot.org/source.html">www.parrot.org/source.html</a>.
Sur ma machine Debian, j'ai d'abord installé la version de Parrot qui se
trouve dans les dépots. Le problème c'est que pas mal d'outils annexes
demandent à avoir un <em>working repository</em>, ils ne sont pas inclus dans les
paquets. De plus, les sources ont l'air de contenir pas mal d'exemples.
J'ai donc désinstallé le package pour Debian et rapatrié les sources depuis
Github : <a href="https://github.com/parrot/parrot">github.com/parrot/parrot</a>.
L'installation s'est déroulée sans soucis particuliers. Comme je trouve la
documentation un peu confuse sur ce point, voilà comment j'ai fait ; si ça
peut vous éviter de chercher…</p>

<pre><code>perl Configure.pl
make
make test
sudo make install
</code></pre>

<h2>Hello Parrot</h2>

<p>On s'attaque enfin à l'écriture du classique <em>hello world</em>:</p>

<p><code>nasm hello.pir
.sub main
  say "Hello world"
.end
</code></p>

<p>On le lance ainsi:</p>

<pre><code>parrot hello.pir
</code></pre>

<p>Maintenant que Parrot est installé et fonctionnel, on va pouvoir écrire quelques
petits programmes en PIR.</p>

<p>À demain.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Implémenter un langage sur la machine virtuelle Parrot: partie 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/01/implementer-un-langage-sur-la-machine-virtuelle-parrot-partie-1/"/>
    <updated>2013-08-01T07:59:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/01/implementer-un-langage-sur-la-machine-virtuelle-parrot-partie-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Cela fait quelques années que j'ai envie d'essayer la
<a href="https://fr.wikipedia.org/wiki/Machine_virtuelle">machine virtuelle</a>
<a href="http://www.parrot.org/">Parrot</a> et j'ai toujours reporté à plus tard.
Jusqu'à maintenant. Aujourd'hui, je commence à écrire un
<a href="http://en.wikipedia.org/wiki/Toy_language">toy language</a>
qui tournera sur Parrot.</p>

<p>Pour implémenter un langage sur Parrot, il faut d'abord … un langage.
Simple de préférence, avec peu de fonctionnalités, au moins pour
démarrer.
Je vais en inventer un pour l'occasion, ce qui sera bien plus drôle que
d'utiliser un sous-ensemble d'un langage déjà existant.</p>

<!-- more -->


<h2>Le langage naam</h2>

<p>Naam signifie No Assignment, Automatic Memoization.
Je rappelle qu'il s'agit d'un <em>toy language</em>, l'objectif étant
d'expérimenter, et non de produire le prochain succès planétaire.
Pour le moment, et peut-être pour toujours, le langage sera limité
à l'utilisation des nombres entiers. Pas de nombres à virgule, pas de
chaînes, pas d'objets… Je viens de passer quelques jours à envisager
une syntaxe. Mais la reflexion n'est pas terminée et elle pourrait
changer d'ici à l'implémentation de naam. Voici des exemples:</p>

<pre><code>sign(n)=
1  if n &gt; 0
-1 if n &lt; 0
0  else

print sign(3)
</code></pre>

<p>Les détails:</p>

<pre><code>sign(n)=
</code></pre>

<p>C'est la définition d'une fonction <code>sign</code>.</p>

<pre><code>1  if n &gt; 0
-1 if n &lt; 0
</code></pre>

<p>Si <code>n</code> est positif on renvoie 1. Si <code>n</code> est négatif on renvoie -1.</p>

<pre><code>0  else
</code></pre>

<p>Dans les autres cas (il reste le cas du zéro) on renvoie 0. Le mot <code>else</code>
marque aussi la fin de la fonction.</p>

<p>Voici maintenant ce que pourrait être la fonction factorielle:</p>

<pre><code>!(n)=
1            if 0
n * .(n - 1) if n &gt; 0
else

print !(7)
</code></pre>

<p>Et le détail:</p>

<pre><code>!(n)=
</code></pre>

<p>On définit la fonction <code>!</code>. Le nom d'une fonction n'a pas à être composé
de lettres. Des signes font aussi bien l'affaire.</p>

<pre><code>1            if 0
</code></pre>

<p>Quand l'argument vaut zéro, on renvoie 1.</p>

<pre><code>n * .(n - 1) if n &gt; 0
</code></pre>

<p>Dans les cas où <code>n</code> est positif, on renvoie <code>n</code> multiplié
par la factorielle de <code>n - 1</code>.
Le point (<code>.</code>) signifie «la fonction elle-même».</p>

<pre><code>else
</code></pre>

<p>Enfin, dans les autres cas (qui ici sont <code>n</code> est négatif) on renvoie du
vide, rien, nada. Comme une fonction est dans l'obligation de renvoyer
une valeur, cela provoquera une erreur (ce qui est voulu).</p>

<p>Un dernier exemple pour terminer, la fonction d'Ackermann. Je ne vais pas
la commenter, la seule différence avec ce que j'ai montré avant est
qu'il y a deux arguments :</p>

<pre><code>ackermann(m, n)=
n + 1                 if 0, n
.(m - 1, 1)           if m &gt; 0, 0
.(m - 1, .(m, n - 1)) else

print ackermann(2, 3)
</code></pre>

<p>On pourrait aussi écrire la même fonction de la manière suivante (je n'ai
pas encore décidé si naam supporterait les deux syntaxes ou non):</p>

<pre><code>ackermann(0, n)     = n + 1
ackermann(m &gt; 0, 0) = .(m - 1, 1)
ackermann(m, n)     = .(m - 1, .(m, n - 1))
</code></pre>

<p>Alors, qu'en pensez vous. Est-ce-que ça vous dit de voir naître un
<em>toy language</em> au jour le jour ? Que pensez vous de naam ?</p>

<p>La prochaine fois on installe Parrot et on joue un peu avec pour sentir le truc.</p>

<p>À demain.</p>
]]></content>
  </entry>
  
</feed>
