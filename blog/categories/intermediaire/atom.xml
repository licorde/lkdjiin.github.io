<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : intermédiaire | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/intermediaire/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-09-24T10:10:11+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 21: Problème des 8 dames]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/24/les-algorithmes-genetiques-demystifies-21-probleme-des-8-dames/"/>
    <updated>2013-09-24T10:04:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/24/les-algorithmes-genetiques-demystifies-21-probleme-des-8-dames</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>On va tenter de résoudre le problème des 8 dames à l'aide d'un algorithme
génétique.</p>

<p><blockquote><p>Le but du problème des huit dames est de placer huit dames d'un jeu d'échecs sur un échiquier de 8 × 8 cases sans que les dames ne puissent se menacer mutuellement, conformément aux règles du jeu d'échecs (la couleur des pièces étant ignorée). Par conséquent, deux dames ne devraient jamais partager la même rangée, colonne, ou diagonale.</p><footer><strong>Wikipédia <a href="http://fr.wikipedia.org/wiki/Probl%C3%A8me_des_huit_dames">http://fr.wikipedia.org/wiki/Probl%C3%A8me_des_huit_dames</a></strong></footer></blockquote></p>

<!-- more -->


<p>Avant toute chose, il faut trouver comment nos chromosomes vont pouvoir
représenter une solution potentielle. On pourrait coder ça sous forme
d'une chaîne de 64 bits, un par case, les 0 étants des cases vides et
les 1 étants les cases occupées par les dames. On pourrait aussi les coder
comme un tableau à deux dimensions, soit 8 rangées multipliées par 8 colonnes.
En y regardant de plus près (ou simplement en relisant la définition du
problème), on remarque que pour qu'une solution soit
viable, il faut une seule dame par rangée, une seule par colonne et une
seule par diagonale. On peut donc se contenter d'une liste (un tableau) de
8 nombres entiers, ces nombres étants le numéro de la colonne. Ainsi, pour
un échiquier de 4 x 4 cases, la liste <code>[0, 2, 3, 3]</code> équivaut à la position
suivante:</p>

<pre><code>---------
|D| | | |
---------
| | |D| |
---------
| | | |D|
---------
| | | |D|
---------
</code></pre>

<p>Maintenant on peut s'occuper de la population. Je vais me servir du code
objet développé dans les derniers articles, en essayant de le modifier
le moins possible.</p>

<p>``` ruby
class Individual
  def self.random(chromosome_size)</p>

<pre><code>new(nil, chromosome_size)
</code></pre>

<p>  end</p>

<p>  def self.from_chromosome(chromosome)</p>

<pre><code>new(chromosome)
</code></pre>

<p>  end</p>

<p>  attr_accessor :score, :fitness
  attr_reader :chromosome</p>

<p>  def initialize(chromosome = nil, chromosome_size = nil)</p>

<pre><code>if chromosome
  @chromosome = chromosome
else
  @chromosome = []
  chromosome_size.times { @chromosome &lt;&lt; Gene.random(chromosome_size) }
end
</code></pre>

<p>  end
  private_class_method :new
end</p>

<p>class Gene
  def self.random(limit)</p>

<pre><code>rand(limit)
</code></pre>

<p>  end
end</p>

<p>class Population &lt; Array
  def initialize(chromosome_size, population_size)</p>

<pre><code>population_size.times { self &lt;&lt; Individual.random(chromosome_size) }
</code></pre>

<p>  end</p>

<p>  def best</p>

<pre><code>self.sort_by{|individual| individual.score}.last
</code></pre>

<p>  end
end
```</p>

<p>J'ai été obligé de modifier la méthode <code>initialize</code> de la classe <code>Individual</code>
ainsi que la classe <code>Gene</code>. Il faudra en tenir compte si on veut qu'un
framework sorte de tout ça…</p>

<p>Le prochain article traitera de l'évaluation du problème des 8 dames.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 20]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/23/les-algorithmes-genetiques-demystifies-20/"/>
    <updated>2013-09-23T18:41:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/23/les-algorithmes-genetiques-demystifies-20</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>C'est le vingtième article de cette série sur les algorithmes génétiques et
j'aimerai en profiter pour dresser un petit bilan provisoire.</p>

<!-- more -->


<p>On a vu le fonctionnement d'un algorithme génétique à l'aide de deux exemples
simples. Dans le premier exemple il s'agissait de trouver une expression comme
«123+54x3» et dans le second il fallait trouver la chaîne «Mon royaume pour un
cheval».</p>

<p>On a appris à représenter une population d'individus. Chaque individu étant une
solution potentielle du problême posé. Cette solution est codée dans le
chromosome d'un individu. On a vu l'utilisation «historique» d'une chaîne de
bits pour réprésenter les chromosomes, mais aussi qu'on pouvait utiliser une
chaîne de caractères quelconques. En fait, il ne faut pas hésiter à représenter
les chromosomes comme bon vous semble.</p>

<p>On a vu ensuite la phase d'évaluation de la population. Il s'agit d'abord
d'évaluer un chromosome seul en lui affectant un score, puis de l'évaluer par
rapport aux autres chromosomes, en lui affectant un <em>fitness</em> (aptitude).  Le
fitness permettant d'être plus fin lors de l'étape de sélection.</p>

<p>Pour l'étape de la sélection, nous avons vu deux manières de faire :
l'élitisme et la roue de la fortune. L'élitisme consiste à ne conserver
qu'un pourcentage des meilleurs spécimens d'une génération. La roue de la
fortune consiste à donner à chaque individu une chance plus ou moins
grande de se reproduire en rapport avec son <em>fitness</em>.</p>

<p>Nous avons fait se reproduire les individus/solutions selectionnés par
croisement de leurs chromosomes. À partir de deux parents, nous avons
obtenu un ou deux enfants. On a utilisé la méthode du croisement en
un point, du croisement en deux points et du croisement uniforme.</p>

<p>Enfin, la mutation (ou l'apport de matériel génétique inédit d'une façon ou d'une
autre) a joué un rôle déterminant pour éviter à nos algorithmes de tomber dans
un extremum local.</p>

<p>En résumé, on a abordé pas mal de choses. Mais ce n'est que la surface
de l'iceberg.</p>

<p>Pour les articles à venir, je pense me pencher sur le
<a href="http://fr.wikipedia.org/wiki/Probl%C3%A8me_des_huit_dames">problème des 8 dames</a>.
Ça permettra de voir une autre façon de coder un chromosome et aussi de
confronter les classes développées dans les derniers articles à un
problème bien différent. Ensuite, j'aimerais résoudre un problème visuel.
Du genre : «Si je dispose de 1000 carrés de taille et de couleur quelconque,
quelle est la meilleure disposition pour s'approcher au mieux d'une
image donnée ?». C'est typiquement le genre de problème qui pourrait
tourner dans les navigateurs et être codé en Javascript. Avez-vous
d'autres idées/envies pour la suite ?</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 19]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/20/les-algorithmes-genetiques-demystifies-19/"/>
    <updated>2013-09-20T09:31:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/20/les-algorithmes-genetiques-demystifies-19</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Suite et fin de la transformation en code orienté objet de l'algorithme
génétique sur le paradoxe du singe savant.</p>

<!-- more -->


<p>Le rôle de la classe <code>MatingPool</code> est de sélectionner les individus pour
la reproduction, suivant la méthode de la roue de la fortune:</p>

<p>``` ruby
class MatingPool
  def initialize(population)</p>

<pre><code>@mating_pool = []
population.each do |individual|
  integer_part = individual.fitness.to_i
  real_part = individual.fitness - integer_part
  integer_part.times { @mating_pool &lt;&lt; individual.dup }
  @mating_pool &lt;&lt; individual.dup if rand &lt; real_part
end
@size = @mating_pool.size
</code></pre>

<p>  end</p>

<p>  def random</p>

<pre><code>@mating_pool[rand(@size)]
</code></pre>

<p>  end
end
```</p>

<p>Au passage, la méthode <code>random</code> permettra de choisir un parent au hasard.</p>

<p>Les classes <code>Crossover</code> et <code>Mutator</code> s'occupent bien sûr de la partie
reproduction:</p>

<p>``` ruby
class Crossover
  def initialize(chromosome_size, mutation_rate)</p>

<pre><code>@size = chromosome_size
@rate = mutation_rate
@mutator = Mutator.new(@size, @rate)
</code></pre>

<p>  end</p>

<p>  def two_point(parent1, parent2)</p>

<pre><code>child = assemble(parent1, parent2, two_cut_points)
child = @mutator.mutate(child)
Individual.from_chromosome(child)
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def two_cut_points</p>

<pre><code>point1 = cut_point
point2 = cut_point
point1, point2 = point2, point1 if point1 &gt; point2
[point1, point2]
</code></pre>

<p>  end</p>

<p>  def cut_point</p>

<pre><code>rand(@size)
</code></pre>

<p>  end</p>

<p>  def assemble(parent1, parent2, points)</p>

<pre><code>point1, point2 = points
parent1.chromosome[0...point1] + parent2.chromosome[point1..point2] +
  parent1.chromosome[point2+1..-1]
</code></pre>

<p>  end
end</p>

<p>class Mutator
  def initialize(chromosome_size, mutation_rate)</p>

<pre><code>@size = chromosome_size
@rate = mutation_rate
</code></pre>

<p>  end</p>

<p>  def mutate(chromosome)</p>

<pre><code>@size.times {|index| chromosome[index] = Gene.random if rand &lt; @rate }
chromosome
</code></pre>

<p>  end
end
```</p>

<p>Le code de ces trois classes reprends plus ou moins le code développé en
style procédural dans les articles précédents et je ne vois pas tellement
ce que je pourrais en dire de plus. Il reste donc à lancer la machine:</p>

<p><code>ruby
generations = 500
search = "Mon royaume pour un cheval"
population = Population.new(search.size, 1000)
mutation = 0.001
GeneticAlgorithm.new(generations, population, search, mutation).run
</code></p>

<p>Voilà, c'est terminé pour le code objet. Quand j'aurais présenter 2 ou 3
algorithmes génétiques de plus, on verra quelles classes résistent et peuvent
être réutilisées et lesquelles doivent être repensées. Ça nous conduira
éventuellement vers la création d'un framework…</p>

<p>À demain</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 18]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/19/les-algorithmes-genetiques-demystifies-18/"/>
    <updated>2013-09-19T18:14:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/19/les-algorithmes-genetiques-demystifies-18</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>On continue la transformation en code orienté objet de l'algorithme génétique
sur le paradoxe du singe savant.</p>

<!-- more -->


<p>D'abord la classe <code>Evaluator</code>, dont le rôle est d'évaluer la population:</p>

<p>``` ruby
class Evaluator
  def initialize(search_value, population)</p>

<pre><code>@search_value = search_value
@population = population
</code></pre>

<p>  end</p>

<p>  def evaluate</p>

<pre><code>@population.each {|individual| score(individual) }
fitness
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def score(individual)</p>

<pre><code>score = 0
individual.chromosome.split('').each_with_index do |character, index|
  score += 1 if @search_value[index] == character
end
individual.score = score
</code></pre>

<p>  end</p>

<p>  def fitness</p>

<pre><code>total = @population.inject(0) {|sum, individual| sum + individual.score }
size = @population.size
@population.each do |individual|
  individual.fitness = individual.score.to_f / total * size
end
</code></pre>

<p>  end
end
```</p>

<p>On voit le découpage entre <em>score</em> et <em>fitness</em>, dont on a parlé hier.</p>

<p>Ensuite, voici la classe <code>GeneticAlgorithm</code>:</p>

<p>``` ruby
class GeneticAlgorithm
  def initialize(generations, population, search_value, mutation_rate)</p>

<pre><code>@generations = generations
@population = population
@search_value = search_value
@mutation_rate = mutation_rate
@crossover = Crossover.new(search_value.size, mutation_rate)
</code></pre>

<p>  end</p>

<p>  def run</p>

<pre><code>@generations.times do |generation|
  Evaluator.new(@search_value, @population).evaluate
  best = @population.best
  display(generation, best)
  exit if best.score == @search_value.size
  next_generation
end
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def display(generation, best)</p>

<pre><code>puts "----------------------"
puts "Gen: #{generation}"
puts "Best: #{best.chromosome}"
</code></pre>

<p>  end</p>

<p>  def next_generation</p>

<pre><code>pool = MatingPool.new(@population)
population_size = @population.size
@population.clear
population_size.times do
  @population &lt;&lt; @crossover.two_point(pool.random, pool.random)
end
</code></pre>

<p>  end
end
```</p>

<p>La méthode <code>run</code> remplace la fonction principale qu'on avait dans nos
scripts jusqu'ici. En écrivant l'article, je vois que la méthode <code>display</code>
me dérange : elle ne repose sur aucun membre, elle serait donc mieux dans
une classe à part entière.</p>

<p>Voilà, c'est un peu court en explication comme article et je m'en excuse
mais aujourd'hui je suis très préssé. La prochaine fois on parle des classes
<code>MatingPool</code>, <code>Crossover</code> et <code>Mutator</code>.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 17: Orienté Objet]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/18/les-algorithmes-genetiques-demystifies-17-oriente-objet/"/>
    <updated>2013-09-18T10:06:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/18/les-algorithmes-genetiques-demystifies-17-oriente-objet</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Il est temps de donner du code orienté objet, non ? C'est ce à quoi je vais
m'attacher dans cet article et les quelques qui suivront. Après ça, je
pense qu'on pourra en finir avec le paradoxe du singe savant et passer à
quelque chose de plus intéressant.</p>

<!-- more -->


<p>Aujourd'hui on voit la création de la population selon le paradigme OO.
Il nous faut d'abord pouvoir créer un individu:</p>

<p>``` ruby
class Individual
  def self.random(chromosome_size)</p>

<pre><code>new(nil, chromosome_size)
</code></pre>

<p>  end</p>

<p>  def self.from_chromosome(chromosome)</p>

<pre><code>new(chromosome)
</code></pre>

<p>  end</p>

<p>  attr_accessor :score, :fitness
  attr_reader :chromosome</p>

<p>  def initialize(chromosome = nil, chromosome_size = nil)</p>

<pre><code>if chromosome
  @chromosome = chromosome
else
  @chromosome = ""
  chromosome_size.times { @chromosome += Gene.random }
end
</code></pre>

<p>  end
  private_class_method :new
end
```</p>

<p>Il y a deux manières de créer un individu. Lors de l'initialisation de
la population, on utilisera <code>Individual.random</code> avec la taille du chromosome.
Lors d'un accouplement, on utilisera <code>Individual.from_chromosome</code> avec le
chromosome résultant des parents. On note aussi les deux attributs <code>score</code>
et <code>fitness</code>. Je ne vais pas m'étaler sur le <code>score</code>, 1 point par lettre
bien placée, voilà, vous avez compris. Par contre <code>fitness</code> demande
quelques explications puisque c'est la première fois que j'emploie ce terme,
pourtant courant en algorithme génétique.</p>

<p><em>Fitness</em> signifie aptitude. Quand le score mesure la performance d'un
individu face à un problème, le <em>fitness</em> mesure un individu par rapport
à son environnement, c'est à dire ici par rapport à la population. Il n'y
a rien de nouveau, on a déjà fait ça quand on normalisait les scores et
qu'on les transformaient en pourcentage (ou en fraction). Jusqu'ici
j'étais resté vague en parlant seulement d'évaluation et je profite du
code d'aujourd'hui pour introduire cette notion de <em>fitness</em>.</p>

<p>La production d'un gène est assurée par la classe <code>Gene</code>, qui ne demande
pas d'explications:</p>

<p>``` ruby
class Gene
  @@genes = &ldquo;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ &rdquo;</p>

<p>  def self.random</p>

<pre><code>@@genes[rand(@@genes.size)]
</code></pre>

<p>  end
end
```</p>

<p>Il reste à concevoir la population:</p>

<p>``` ruby
class Population &lt; Array
  def initialize(chromosome_size, population_size)</p>

<pre><code>population_size.times { self &lt;&lt; Individual.random(chromosome_size) }
</code></pre>

<p>  end</p>

<p>  def best</p>

<pre><code>self.sort_by{|individual| individual.score}.last
</code></pre>

<p>  end
end
```</p>

<p>La population étant basiquement une liste d'objets <code>Individual</code>, il me
semble logique d'hériter de <code>Array</code>. J'ai prévu une méthode <code>best</code> qui
permettra d'afficher la progression de l'algorithme et qui pourra aussi
servir pour la condition d'arrêt du programme quand <code>individual.score</code>
sera égal à la taille de la chaîne recherchée.</p>

<p>Demain ce sera au tour de l'évaluation d'être transformée en code objet.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
