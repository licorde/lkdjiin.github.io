<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : intermédiaire | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/intermediaire/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-07-25T09:27:12+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Le problème des 100 portes en Elixir]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/07/25/le-probleme-des-100-portes-en-elixir/"/>
    <updated>2013-07-25T07:35:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/07/25/le-probleme-des-100-portes-en-elixir</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Je continue mon périple parmi le <a href="http://rosettacode.org/wiki/">rosetta code</a>
en m'attaquant au problème des «100 doors».</p>

<p><blockquote><p>Problem: You have 100 doors in a row that are all initially closed. You make 100 passes by the doors. The first time through, you visit every door and toggle the door (if the door is closed, you open it; if it is open, you close it). The second time you only visit every 2nd door (door #2, #4, #6, &hellip;). The third time, every 3rd door (door #3, #6, #9, &hellip;), etc, until you only visit the 100th door.</p></p><p><p>Question: What state are the doors in after the last pass? Which are open, which are closed?</p><footer><strong>Rosetta Code <a href="http://rosettacode.org/wiki/100_doors">http://rosettacode.org/wiki/100_doors</a> 100 doors</strong></footer></blockquote></p>

<!-- more -->


<p>Je me dis que je vais d'abord le faire dans un langage que je connais bien
pour voir de quoi il retourne, et si il n'y a pas de pièges cachés. En
quelques lignes de Ruby, le tour est joué:</p>

<p>``` ruby 100 doors en Ruby
doors = Array.new(100)</p>

<p>(1..100).each do |interval|
  doors.map!.with_index do |elem, idx|</p>

<pre><code>(idx+1) % interval == 0 ? !elem : elem
</code></pre>

<p>  end
end</p>

<h1>Écrire le numéro des portes ouvertes.</h1>

<p>doors.each_with_index {|e, i| puts i+1 if e }
```</p>

<p>Voyant cela j'ai pensé que ça allait être assez simple à implémenter en
Elixir. Pas du tout. J'ai galéré longtemps avant de trouver la solution qui
va suivre. Mon plus gros problème avec Elixir est que les variables sont
non-mutables. Une fois définie, une variable ne change pas. Il faut donc
faire appel constament à la récursivité. Je ne nie pas les avantages d'un
tel système (pas d'effets de bords) mais ce n'est pas évident de s'y faire quand
on vient comme moi du monde procédural ou objet. Trêve de baratin, voici
ma solution avec Elixir:</p>

<p>``` elixir 100 doors en Elixir
defmodule Doors do</p>

<p>  def soluce do</p>

<pre><code>doors = Enum.map 1..100, fn _ -&gt; false end
run(doors, 1)
</code></pre>

<p>  end</p>

<p>  defp run(doors, interval) when interval > 100 do</p>

<pre><code>doors
</code></pre>

<p>  end</p>

<p>  defp run doors, interval do</p>

<pre><code>run(switch_doors(doors,interval), interval + 1)
</code></pre>

<p>  end</p>

<p>  defp switch_doors(doors, interval) do</p>

<pre><code>stream = Stream.with_index(doors)
list = Enum.to_list(stream)
Enum.map list, fn e -&gt;
  door = elem e, 0
  index = elem(e, 1) + 1
  switch_door rem(index, interval), door
end
</code></pre>

<p>  end</p>

<p>  defp switch_door(0, door), do: not door
  defp switch_door(_, door), do: door
end</p>

<p>soluce = Doors.soluce
Enum.each Enum.to_list(Stream.with_index(soluce)), fn e &ndash;>
  if elem(e, 0) == true, do: IO.puts elem(e, 1) + 1
end
```</p>

<p>Plutôt long comparé à la version Ruby, hein ? Quoiqu'il en soit, j'en suis
fier, j'ai mis du temps à la pondre, cette version. Je pense que quelqu'un
connaissant bien Elixir doit pouvoir nettement améliorer mon code. Je
vais le poster sur la mailing-list et demander ce qu'il en
pense. Si j'ai des retours (ce dont je ne doute pas) je mettrais la
version améliorée dans un prochain article. En attendant je vais
commenter un peu mon code pour l'expliquer.</p>

<p><code>elixir
def soluce do
  doors = Enum.map 1..100, fn _ -&gt; false end
  run(doors, 1)
end
</code></p>

<p><code>soluce</code> est la seule fonction publique du module. Elle initialise une liste
de 100 éléments avec la valeur <code>false</code>. Puis elle commence le travail avec
<code>run(doors, 1)</code>, <code>1</code> étant le premier intervalle de la série, c'est à dire
qu'on passe par toutes les portes. Une fois la solution découverte, elle est
renvoyée explicitement. Si vous connaissez Ruby, vous savez à quoi je fais
référence, sinon, sachez qu'en Elixir toutes les fonctions renvoie une valeur,
et qu'on a pas besoin de l'indiquer. C'est implicite, la dernière évaluation
est renvoyée. Notez aussi l'usage de <code>_</code> qui indique qu'on se fiche du contenu
de la variable.</p>

<p>``` elixir
defp run(doors, interval) when interval > 100 do
  doors
end</p>

<p>defp run doors, interval do
  run(switch_doors(doors,interval), interval + 1)
end
```</p>

<p>La première version de <code>run</code> comporte un <em>guard</em>. Elle n'est utilisée que
lorsque <code>interval</code> est supérieur à 100. C'est notre clause de sortie de la
fonction récursive.</p>

<p>La seconde version de <code>run</code> est utilisée dans tout les autres cas. Elle se
contente de s'appeller elle-même (récursivité) avec une liste des portes
mise à jour et un intervalle incrémenté.</p>

<p>``` elixir
defp switch_doors(doors, interval) do
  stream = Stream.with_index(doors)
  list = Enum.to_list(stream)
  Enum.map list, fn e &ndash;></p>

<pre><code>door = elem e, 0
index = elem(e, 1) + 1
switch_door rem(index, interval), door
</code></pre>

<p>  end
end
```</p>

<p><code>switch_doors</code> est responsable de fabriquer une nouvelle liste de portes.
C'est la fonction qui m'a tenu en échec pendant des heures, jusqu'à ce que
je découvre le module <code>Stream</code>. Voyons <code>switch_doors</code> en détails:</p>

<p><code>elixir
stream = Stream.with_index(doors)
list = Enum.to_list(stream)
</code></p>

<p>Je crée une nouvelle liste qui va embarquer les valeurs de <code>doors</code>
en les associant aux indexs. <code>list</code> va ressembler à ça:</p>

<pre><code>[{false, 0}, {false, 1}, {false, 2}, ... {false, 99}]
</code></pre>

<p>Qui en Elixir peut aussi être représenté ainsi:</p>

<pre><code>[false: 0, false: 1 ...
</code></pre>

<p><code>elixir
Enum.map list, fn e -&gt;
  door = elem e, 0
  index = elem(e, 1) + 1
  switch_door rem(index, interval), door
end
</code></p>

<p><code>Enum.map</code> fabrique et renvoie une nouvelle version de la liste des portes.
Chaque élément de <code>list</code> (chaque <code>{false, 0}</code>) passe à travers une fonction
anonyme qui renvoie false ou true, selon le résultat de index modulo interval.</p>

<p><code>elixir
defp switch_door(0, door), do: not door
defp switch_door(_, door), do: door
</code></p>

<p>Si le modulo égal zéro, on inverse l'état de la porte. Sinon la porte doit
rester dans le même état.</p>

<p><code>elixir
Enum.each Enum.to_list(Stream.with_index(soluce)), fn e -&gt;
  if elem(e, 0) == true, do: IO.puts elem(e, 1) + 1
end
</code></p>

<p>J'écris les numéros des portes ouvertes. Avec mes explications qui précèdent,
j'espère que vous pourrez comprendre comment ça marche.</p>

<p>À demain.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git et les alias: la suite]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/07/16/git-et-les-alias-la-suite/"/>
    <updated>2013-07-16T09:10:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/07/16/git-et-les-alias-la-suite</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p><em>Hier, j'abordai les bases de la
<a href="http://lkdjiin.github.io/blog/2013/07/15/git-completion-automatique-et-alias-pour-debutants/">création d'alias avec Git</a>.
Aujourd'hui je pousse un peu plus loin en montrant comment intégrer
des commandes externes dans ces alias.</em></p>

<p>J'ai constaté récemment que j'utilisai énormément Git:</p>

<p><code>bash
xavier:~$ wc -l .bash_history
500 .bash_history
xavier:~$ sed -n '/^git/p' .bash_history | wc -l
238
</code></p>

<p>Sur 500 lignes d'historique, 238 sont consacrées à Git ! Ça m'a décidé
à approfondir la question des alias.</p>

<!-- more -->


<h2>L'opérateur !</h2>

<p>Git permet d'utiliser des commandes externes dans la définitions des
alias à l'aide de l'opérateur <code>!</code>. L'exemple qui suit est parfaitement
inutile mais illustre bien ce qui est possible.</p>

<p><code>ini
[alias]
  ls = !ls
</code></p>

<p><code>bash
xavier:~$ git ls
bin    Documents  Images            Modèles    Téléchargements   www
[...]
</code></p>

<p>C'est pas tout, Git accepte aussi les arguments des commandes externes:</p>

<p><code>bash
xavier:~$ git ls -a
.          .fonts       .javafx_eula_accepted   .remmina
[...]
</code></p>

<p>Vous imaginez un peu ce qu'on va pouvoir faire avec ça ? Prenons un
workflow simple : nouvelle branche, ajout de fichier, commit, retour à au
master et merge.</p>

<p>``` bash</p>

<pre><code>git checkout -b new_branch
# Édition du code
git add . # 1 fois sur 2 j'oublie celle-là.
git commit -a
git checkout master
git merge new_branch
</code></pre>

<p>```</p>

<p>Il est clair que <code>git add . ; git commit -a</code> va se répéter plusieurs fois.
Je cherche donc a optimiser cette partie. Pour cela je modifie mon vieil
alias <code>ci</code> (<a href="http://lkdjiin.github.io/blog/2013/07/15/git-completion-automatique-et-alias-pour-debutants/">voir article précédent</a>).</p>

<p><em>Dans les exemples suivants, je n'écris plus <code>[alias]</code>, cette ligne est
désormais sous-entendue.</em></p>

<pre><code>ci = !git add . &amp;&amp; git commit -a
</code></pre>

<p>Git traite <code>git</code> comme une commande externe comme les autres &ndash;
<em>logique mais marrant</em> &ndash;, quant à <code>&amp;&amp;</code>, cela permet à Bash de n'exécuter
la commande de droite que si la commande de gauche réussie. Il n'y a pas
de raison de douter que <code>git add .</code> va crasher et vous pouvez remplacer
<code>&amp;&amp;</code> par <code>;</code> si vous voulez.</p>

<p>Pour finir sur une note d'humour de geek, voici la commande <code>la</code> (pour
list alias) qui va afficher tout les alias.</p>

<pre><code># Lister tout les alias.
la = !git config -l | sed -n '/alias/s/alias\\.//p' | sort
</code></pre>

<p>Tout d'abord <code>git</code> est utilisé pour lister le contenu du fichier .gitconfig.
Ensuite <code>sed</code> sélectionne seulement les lignes commençant par <code>alias</code> et en
même temps supprime <code>alias.</code> de la ligne. Et enfin <code>sort</code> nous trie tout
ça par ordre alphabétique. Notez au passage que le fichier <code>.gitconfig</code>
accepte les commentaires.</p>

<h2>Conclusion</h2>

<p>On a là un sacré terrain de jeu. Si vous aimez écrire des oneliners, vous
allez pouvoir vous amuser. Voici par exemple une page où vous trouverez
<a href="http://durdn.com/blog/2012/11/22/must-have-git-aliases-advanced-examples/">des définitions d'alias</a>
bien plus complexe que ce que j'ai montré ici.
Malgré tout, je ne pense pas que les alias de Git soient la réponse à tout
les problèmes.
Écrire une commande sur une seule ligne va vite devenir illisible si
vous avez besoin de faire quelque chose d'un peu élaboré. Dans un
prochain article je montrerais comment créer vos propres commandes Git
à l'aide de scripts, et non plus simplement d'alias.</p>

<p>À demain.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby et les eigenclass]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/07/11/ruby-et-les-eigenclass/"/>
    <updated>2013-07-11T10:24:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/07/11/ruby-et-les-eigenclass</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Dans l'
<a href="http://lkdjiin.github.io/blog/2013/07/10/quel-est-linteret-de-cette-syntaxe/">article d'hier</a>,
je cherchais un intérêt à <code>class &lt;&lt; self</code> dans la
définition d'une classe, et je n'en ai pas trouvé.
Aujourd'hui je vais appronfondir le sujet et parler des eigenclass(es) en Ruby.
Il se trouve que Ruby est un langage orienté objet, contrairement à…
(au hasard) Java…</p>

<!-- more -->


<p>Ok, c'est pour rire. Bien sûr que Java est un langage OO. Mais quand même,
par rapport à Ruby je dirais plutôt que Java est un langage orienté classe.
Avec Ruby, tout est objet, même les classes ! Je re-dis ça autrement
pour que ce soit
bien clair : en Ruby les classes sont des objets comme les autres.
Voyons comment ça fonctionne, au travers des eigenclass(es):</p>

<p>``` ruby
class Engin
  def roule</p>

<pre><code>"Je roule"
</code></pre>

<p>  end
end</p>

<p>voiture = Engin.new
moto = Engin.new</p>

<p>voiture.roule</p>

<h1>=> &ldquo;Je roule&rdquo;</h1>

<p>moto.roule</p>

<h1>=> &ldquo;Je roule&rdquo;</h1>

<p>```</p>

<p>On a créé une classe <code>Engin</code> et instancié deux objets à partir de cette
classe, <code>voiture</code> et <code>moto</code>. La classe a joué le rôle d'un moule, à partir
duquel les deux objets ont été fabriqués et leurs comportements sont
identiques. Maintenant, si on veut spécialiser le comportement de <code>moto</code>,
on pourrait utiliser l'héritage ou les mixins. Ce qui serait très bien si
on devait gérer des dizaines d'objets au comportement similaire. Mais si on
a un seul objet qui diffère, devoir écrire une nouvelle classe pour un seul
objet est un peu lourd. Grâce au eigenclass(es), Ruby permet de changer le
comportement d'un objet pendant l'execution.</p>

<p>``` ruby
class &lt;&lt; moto
  def wheeling</p>

<pre><code>"Wahooo"
</code></pre>

<p>  end
end
```</p>

<p>Ou bien avec la syntaxe suivante, qui fait la même chose:</p>

<p><code>ruby
def moto.wheeling
  "Wahooo"
end
</code></p>

<p>On vient d'ajouter une méthode à l'objet <code>moto</code> de classe <code>Engin</code>, mais pas
à l'objet <code>voiture</code>, pourtant lui aussi de classe <code>Engin</code>. Pour vérifier:</p>

<p>``` ruby
moto.wheeling</p>

<h1>=> &ldquo;Wahooo&rdquo;</h1>

<p>voiture.wheeling</p>

<h1>=> NoMethodError: undefined method `wheeling'</h1>

<p>voiture.class == moto.class</p>

<h1>=> true</h1>

<p>```</p>

<p>Comment Ruby gère ce système ? C'est surprenant de simplicité. Ruby interpose
une nouvelle classe, anonyme, entre l'objet et sa hiérarchie de classes. C'est
cette nouvelle classe, qu'on appelle eigenclass.
L'eigenclass ne comprend que les comportements ajoutés à «son» objet.  Dans
notre exemple, l'eigenclass de <code>moto</code> ne comporte que la méthode <code>wheeling</code>.
Le système de classe de Ruby est complexe, mais pour la partie qui nous
intéresse ici cela donne ça:</p>

<pre><code>moto &lt; eigenclass &lt; Engin &lt; Object
</code></pre>

<p>À la place de «eigenclass», on peut lire et entendre parfois «singleton» ou
«metaclass», c'est la même chose. D'ailleurs, pour obtenir la liste des
méthodes de la «ghost class» (encore un autre nom) on peut utiliser la
méthode <code>singleton_methods</code>:</p>

<p>``` ruby
moto.singleton_methods</p>

<h1>=> [</h1>

<h1>=>   [0] wheeling() #&lt;Engin:0xa05585c></h1>

<h1>=> ]</h1>

<p>```</p>

<p>J'ai dit au début qu'une classe est un objet comme un autre. Donc ce qui
fonctionne pour <code>moto</code> doit aussi fonctionner pour <code>Engin</code>:</p>

<p>``` ruby
def Engin.definition
  &ldquo;Un truc qui roule&rdquo;
end</p>

<p>Engin.definition</p>

<h1>=> &ldquo;un truc qui roule&rdquo;</h1>

<p>Engin.singleton_methods</p>

<h1>=> [</h1>

<h1>=>     [0] definition() Engin</h1>

<h1>=> ]</h1>

<p>```</p>

<p>Tout pareil ! <code>definition</code> a été ajouté à l'eigenclass de <code>Engin</code>.
Autrement dit, quand vous ajouter une méthode de classe à une classe, en fait
vous l'ajouter à son eigenclass.</p>

<p>À demain.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Quel est l'intérêt de cette syntaxe ?]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/07/10/quel-est-linteret-de-cette-syntaxe/"/>
    <updated>2013-07-10T09:04:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/07/10/quel-est-linteret-de-cette-syntaxe</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>En googlant sur <code>ruby design pattern factory</code> je suis tombé sur un
<a href="http://blog.rubybestpractices.com/posts/gregory/059-issue-25-creational-design-patterns.html">post intéressant</a>.
Non, je ne vais pas vous parler de design pattern dans cet article. L'exemple
qui m'a plus particulierment intrigué est le suivant:</p>

<p>``` ruby Exemple original
class AdjacencyMatrix<br/>
  class &lt;&lt; self</p>

<pre><code>def undirected(data)  
  new(data)  
end  

def directed(data)  
  new(data,true)  
end  

private :new  
</code></pre>

<p>  end</p>

<p>  def initialize(data, directed=false)</p>

<pre><code>#...  
</code></pre>

<p>  end<br/>
end</p>

<p>undirected_matrix = AdjacencyMatrix.undirected(data) <br/>
directed_matrix   = AdjacencyMatrix.directed(data)
```</p>

<p>Pourquoi cet exemple m'a intrigué ? Pas parce qu'il parle de matrice, je vous
rassure. Je ne comprends pas grand chose aux matrices, et je n'ai jamais
entendu parler d'«adjacency matrix». Si cet exemple m'intrigue, c'est parce que
je ne comprends pas, <em>à priori</em>, l'intérêt du <code>class &lt;&lt; self</code>.  Il me semble
que je peux réécrire ça sans <code>class &lt;&lt; self</code> et que le résultat serait le même.</p>

<!-- more -->


<p>Alors allons y. Voilà le nouveau bout de code qui fait la même chose que
le précédent:</p>

<p>``` ruby Seconde version
class AdjacencyMatrix<br/>
  def self.undirected(data)</p>

<pre><code>new(data)  
</code></pre>

<p>  end</p>

<p>  def self.directed(data)</p>

<pre><code>new(data,true)  
</code></pre>

<p>  end</p>

<p>  private_class_method :new</p>

<p>  def initialize(data, directed=false)</p>

<pre><code>#...  
</code></pre>

<p>  end
end</p>

<p>undirected_matrix = AdjacencyMatrix.undirected(data)
directed_matrix   = AdjacencyMatrix.directed(data)
```</p>

<p>Surround your pullquote like this {" text to be quoted "}</p>

<p>Surround your pullquote like this {" text to be quoted "}</p>

<h2>Quel est l'intérêt de <code>class &lt;&lt; self</code> ?</h2>

<p>Quoi qu'il en soit, je n'ai toujours pas de réponse à ma première question:
«quel est l'intérêt de <code>class &lt;&lt; self</code>» dans cet exemple précis.
Il est possible que dans une ancienne
version de Ruby, il n'y avait pas moyen de faire autrement et qu'on ai gardé
l'habitude ? Peut-être qu'il n'y a aucune réponse ? Je vais donc aller faire un
tour du coté de la divinité StackOverflow pour tenter d'y voir plus clair. Je
vous tient au courant dans un futur article si je trouve quelque chose.</p>

<p>À demain.</p>
]]></content>
  </entry>
  
</feed>
