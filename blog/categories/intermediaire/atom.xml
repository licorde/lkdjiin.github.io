<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : intermédiaire | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/intermediaire/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-09-16T13:32:42+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 15: croisement uniforme]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/16/les-algorithmes-genetiques-demystifies-15-croisement-uniforme/"/>
    <updated>2013-09-16T13:19:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/16/les-algorithmes-genetiques-demystifies-15-croisement-uniforme</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Après le croisement en un point et le croisement en deux points, on
discute aujourd'hui d'une troisième méthode: le croisement uniforme.</p>

<!-- more -->


<h2>Croisement uniforme (uniform crossover)</h2>

<p>Pourquoi s'arrêter au croisement en deux points ? Pourquoi pas trois points ?
Ou encore quatre ? Si on pousse cette démarche, on arrive au croisement
uniforme. Le principe est le suivant: on prend deux parents, A et B ; pour
chaque gènes on lance une pièce de monnaie ; si c'est face l'enfant prend
le gène du parent A ; si c'est pile l'enfant prend le gène du parent B.</p>

<p>`&ldquo; ruby
def uniform_crossover(parent1, parent2)
  child = &ldquo;&rdquo;
  parent1.last.split(&rdquo;).each_with_index do |bit, index|</p>

<pre><code>if 0.5 &gt;= rand
  child += parent2.last[index]
else
  child += parent1.last[index]
end
</code></pre>

<p>  end
  [nil, mutate(child)]
end
```</p>

<p>Alors voyons les performances pour un nombre d'individus égal et un taux de
mutation égal:</p>

<pre><code>=================================================
| méthode de croisement | génération | secondes |
=================================================
| un point              |         81 |        5 |
|-----------------------------------------------|
| deux points           |         54 |        3 |
|-----------------------------------------------|
| uniforme              |         47 |        6 |
|-----------------------------------------------|
</code></pre>

<p>Le nombre de générations nécéssaires pour trouver la solution diminue
significativement mais en même temps le nombre de secondes a doublé
par rapport au croisement en deux points. Est-ce qu'il faut jetter la
méthode du croisement uniforme aux oubliettes ? Je ne pense pas. On peut
imaginer que si le croisement uniforme prends 2 fois plus de temps que
le croisement en deux points, c'est parce que celle-ci (croisement uniforme)
génère un nombre aléatoire pour chaque gènes. Si la méthode d'évaluation
était plus gourmande en temps de calcul, les quelques générations gagnées
par le croisement uniforme s'avéreraient payantes.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés: le croisement en deux points]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/15/les-algorithmes-genetiques-demystifies-le-croisement-en-deux-points/"/>
    <updated>2013-09-15T11:40:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/15/les-algorithmes-genetiques-demystifies-le-croisement-en-deux-points</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Aujourd'hui on parle plus en détail de la méthode de reproduction
utilisé jusqu'ici, à savoir le «croisement» de deux individus, et
je décris la variante du «croisement en deux points».</p>

<!-- more -->


<h2>Croisement en un point (one point crossover)</h2>

<p>Pour l'instant on a utilisé la méthode du croisement en un point
(<em>one point crossover</em> in english). Pour mémoire, voici son
implémentation dans le dernier problème, le paradoxe du singe savant:</p>

<p><code>ruby
def crossover(parent1, parent2)
  point = rand(1..@search_value.size)
  child = parent1.last[0...point] + parent2.last[point..-1]
  [nil, mutate(child)]
end
</code></p>

<p>Et en voici une représentation, le caractère <code>:</code> représente le point
de croisement:</p>

<pre><code>parent A  123:45678
parent B  abc:defgh

enfant A  123:defgh
enfant B  abc:45678
</code></pre>

<p>On remarque que je prends garde d'éviter les valeurs extrèmes pour le
point de croisement. Si ce point était par exemple zéro,
il n'y aurait pas croisement mais une simple copie conforme d'un parent.
Malgré tout, je ne voudrais pas laisser croire que c'est très important,
et on pourrait très bien écrire:</p>

<pre><code>point = rand(0..@search_value.size+1)
</code></pre>

<p>Il y aurait copie, et non croisement, dans 2/<em>l</em> cas (où <em>l</em> est la longueur
du chromosome). Plus les chromosomes sont long et moins c'est un problème.</p>

<p>On peut remarquer aussi que je ne crée qu'un seul enfant sur les deux
possibles. Un code plus générique devrait créer et renvoyer les deux
enfants, libre à nous d'en utiliser un seul ou les deux.</p>

<h2>Croisement en deux points (two point crossover)</h2>

<p>Une autre méthode de croisement populaire est le croisement en deux
points. On intervertit le matériel génétique qui se trouve <em>entre</em> les
deux points de croisement. Voici une représentation de cette méthode:</p>

<pre><code>parent A  123:456:78
parent B  abc:def:gh

enfant A  123:def:78
enfant B  abc:456:gh
</code></pre>

<p>Et voici une implémentation (toujours avec la création d'un seul
enfant):</p>

<p>``` ruby
def two_point_crossover(parent1, parent2)
  point1 = rand(@search_value.size)
  point2 = rand(@search_value.size)
  point1, point2 = point2, point1 if point1 > point2
  child = parent1.last[0&hellip;point1] + parent2.last[point1..point2] +</p>

<pre><code>      parent1.last[point2+1..-1]
</code></pre>

<p>  [nil, mutate(child)]
end
```</p>

<p>À ce stade, vous vous demandez sûrement quel est l'intérêt de cette
méthode ? Pour le comprendre, prenons un exemple. Le chromosome qu'on
recherche est <code>bonjour</code> et dans notre population on a le chromosome
suivant:</p>

<pre><code>bacdefr
</code></pre>

<p>Seul ces deux gènes extrèmes sont bons. On peut aussi le noter de cette
façon:</p>

<pre><code>b*****r
</code></pre>

<p>Le <code>*</code> indique un emplacement dont la valeur n'est pas significative pour
la discussion en cours. Si on applique le croisement en un point, les deux
bons gènes vont être séparés dans presque tout les cas (et même dans tous
les cas si on ne permet pas que le point de croisement se fasse aux valeurs
extrèmes). Comparez avec le chromosome suivant:</p>

<pre><code>bo*****
</code></pre>

<p>Les deux gènes <code>bo</code> seront rarement séparés. La probabilité est de
1/<em>l</em>-1 si on ne permet pas les valeurs extrèmes (<em>l</em> est la longueur du
chromosome). Donc avec la méthode du croisement en un point, le premier
et le dernier gène sont traités différement des autres.
Reste à savoir quelle incidence cela a sur la performance de l'algorithme.
Voici les mesures pour l'algorithme précédent (avec taille de population
et taux de mutation égal):</p>

<pre><code>=================================================
| méthode de croisement | génération | secondes |
=================================================
| un point              |         81 |        5 |
|-----------------------------------------------|
| deux points           |         54 |        3 |
|-----------------------------------------------|
</code></pre>

<p>L'amélioration se lit clairement. En attendant le prochain article,
n'hésitez pas à expérimenter ce qui vous passe par la tête (par exemple,
pourquoi se limiter à 2 parents ?).</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 13]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/13/les-algorithmes-genetiques-demystifies-13/"/>
    <updated>2013-09-13T07:45:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/13/les-algorithmes-genetiques-demystifies-13</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Aujourd'hui on analyse ce qui arrive lorsqu'on joue avec les deux
variables dont on dispose pour l'instant : la taille de la population
et le taux de mutation.</p>

<!-- more -->


<h2>Une définition de la performance</h2>

<p>Comment mesurer les performances d'un algorithme génétique ? Le nombre de
générations nécessaires pour trouver la solution vient tout de suite à
l'esprit. C'est toujours une mesure intéressante mais la plus importante
mesure reste évident <strong>le temps</strong> écoulé avant de trouver la solution.</p>

<p>Les mesures que je propose ici n'ont rien de très <em>scientifique</em>. Pour
chaque mesure j'ai fait tourner l'algorithme génétique développé dans les
<a href="http://lkdjiin.github.io/blog/2013/09/08/les-algorithmes-genetiques-demystifies-8-le-paradoxe-du-singe-savant/">derniers articles</a> (le paradoxe du singe savant) 5 fois de suite.
C'est malgré tout suffisant pour dégager les tendances.</p>

<h2>Performances suivant la taille de la population</h2>

<p>Tout d'abord voyons ce qu'il se passe quand on augmente la taille de la
population.</p>

<pre><code>======================================
| population | génération | secondes |
======================================
|        150 |       3277 |       32 |
|------------------------------------|
|        500 |        363 |       12 |
|------------------------------------|
|      1.000 |         81 |        5 |
|------------------------------------|
|     10.000 |         50 |       33 |
|------------------------------------|
</code></pre>

<p>Ça ne devrait pas vous surprendre : plus la population augmente plus la
solution est trouvée en un minimum de générations. C'est presque la même
chose avec le temps, sauf que passé un certain point, il remonte en flêche.
C'est essentiellement du aux structures de données utilisées pour
construire le <em>mating pool</em>, évaluer les individus, etc. Et ça pose la
question de trouver un langage informatique adapté aux algorithmes
génétiques, langage qui soit un bon compromis entre facilité
d'écriture/lecture et performances brutes.</p>

<h2>Performances suivant le taux de mutation</h2>

<p>Voyons maintenant l'influence du taux de mutation.</p>

<pre><code>======================================
| taux de    | génération | secondes |
| mutation * |            |          |
======================================
|       0.02 |        293 |       20 |
|------------------------------------|
|       0.01 |         81 |        5 |
|------------------------------------|
|      0.005 |         75 |        5 |
|------------------------------------|
|      0.001 |         73 |        5 |
|------------------------------------|
|     0.0001 |         65 |        4 |
|------------------------------------|
|          0 |         ** |       ** |
|------------------------------------|
* Pour une population de 1000 individus.
** Aux environs de la 60ème génération si on a de la
   chance, sinon jamais car on atteint un extremum local.
</code></pre>

<p>Entre 1/100ème et 1/10.000ème la performance évolue, mais peu. À 2/100ème on
voit que la performance est déjà en train de chuter. En dessous de
1/10.000ème, le comportement se rapproche fortement d'un taux de zéro pourcent.
On considère généralement un taux de mutation de 1/<em>n</em> comme un bon
compromis (où <em>n</em> est la taille de la population).</p>

<p>Voilà, cette petite analyse est terminée.
Je ne sais pas de quoi je parlerais la prochaine fois, mais le sujet
est tellement vaste que j'ai l'impression que
cette série sur les algorithmes génétiques ne s'arretera jamais…</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 12]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/12/les-algorithmes-genetiques-demystifies-12/"/>
    <updated>2013-09-12T08:28:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/12/les-algorithmes-genetiques-demystifies-12</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Pour résoudre le paradoxe du singe savant, on a utilisé la méthode
de sélection dite de «la roue de la fortune», mais je n'avais pas
fournit l'algorithme complet de cette méthode. On en parle aujourd'hui.</p>

<!-- more -->


<p>Le problème avec la simulation de la roue de la fortune que j'ai
utilisé <a href="http://lkdjiin.github.io/blog/2013/09/10/les-algorithmes-genetiques-demystifies-10/">précédemment</a>,
c'est qu'elle n'est pas réaliste. Je n'utilisai que la partie entière des
scores d'évaluation pour placer des copies des individus dans le
<em>mating pool</em>. Ainsi un score de 0,99 était éliminatoire, et un score de 2,01
était vu comme deux fois plus adapté qu'un score de 1,99 !</p>

<h2>Une roue de la fortune réaliste</h2>

<p>L'idée, qui vient de <a href="http://en.wikipedia.org/wiki/John_Henry_Holland">John Holland</a>, est de donner une chance supplémentaire
au individus de placer une copie d'eux-mêmes en fonction de la partie
fractionnaire de leur score. Par exemple un individu évalué à 1,87 placera
d'office une copie dans le <em>mating pool</em> et aura 87 chances sur 100 de placer
une seconde copie. De même, un individu évalué à 0,49 aura 49 chances sur 100
de placer une copie. Simple, efficace et réaliste. Voici la méthode
<code>create_mating_pool</code> révisée:</p>

<p>``` ruby
def create_mating_pool
  mating_pool = []
  @population.each do |person|</p>

<pre><code>integer_part = person.first.to_i
fractional_part = person.first - integer_part
integer_part.times { mating_pool &lt;&lt; person }
mating_pool &lt;&lt; person if rand &lt; fractional_part
</code></pre>

<p>  end
  mating_pool
end
```</p>

<p>Pour que ça fonctionne avec n'importe quelle taille de population, et pas
seulement 100 individus, il faut aussi réviser la façon dont on
normalise les scores:</p>

<p>``` ruby
def normalize_population_score
  total = @population.inject(0) {|sum, person| sum + person.first }
  @population.map! do |person|</p>

<pre><code>[person.first.to_f / total * @population_size, person.last]
</code></pre>

<p>  end
end
```</p>

<p>Et voilà, on peut maintenant jouer avec nos deux variables que sont
<code>@population_size</code>, la taille de la population, et <code>@mutation_rate</code>, le
taux de mutation, pour rendre l'algorithme le plus rapide possible.</p>

<p>Il y a beaucoup de choses à propos des algorithmes génétiques sur
lesquelles j'ai encore envie d'écrire, notamment:</p>

<ul>
<li>analyse des variables</li>
<li>autres méthodes de reproduction</li>
<li>autres méthodes de sélection</li>
<li>mélange élitisme/roue de la fortune</li>
<li>code orienté objet (éventuellement création d'un framework)</li>
<li>algorithme dégénéré (Hill-climbing)</li>
<li>extremum local</li>
</ul>


<p>Chaque point de cette liste fera sûrement l'objet d'un (ou plusieurs)
futur article.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 11]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/11/les-algorithmes-genetiques-demystifies-11/"/>
    <updated>2013-09-11T09:04:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/11/les-algorithmes-genetiques-demystifies-11</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>La <a href="http://lkdjiin.github.io/blog/2013/09/10/les-algorithmes-genetiques-demystifies-10/">dernière fois</a>
on a assuré la sélection à l'aide d'une piscine
d'accouplement (je ne me lasse pas de ce terme…). Aujourd'hui, on peut
aller au bout de l'algorithme en ajoutant la reproduction.</p>

<!-- more -->


<h2>La reproduction des phrases</h2>

<p>Il n'y a rien de nouveau par rapport à <a href="http://lkdjiin.github.io/blog/2013/08/29/les-algorithmes-genetiques-demystifies-2/">l'algorithme précédent</a>,
c'est peut-être même plus simple. Voici la méthode <code>crossover</code>, qui
permet d'obtenir un enfant:</p>

<p><code>ruby
def crossover(parent1, parent2)
  point = rand(1..(@search_value.size - 1))
  child = parent1.last[0...point] + parent2.last[point..-1]
  [nil, mutate(child)]
end
</code></p>

<p><strong>Edit du 14 sept 2013</strong> Le code ci-dessus contient une erreur, à la
seconde ligne il faut lire: <code>point = rand(1..@search_value.size)</code>.</p>

<p><code>crossover</code> prends deux chromosomes en entrée (les parents). On définit
un point de croisement au hasard. On utilise ce point de croisement pour
<em>couper</em> les parents en deux parties. Un enfant est produit en concaténant
la première partie du premier parent avec la seconde partie du second
parent. Enfin on renvoie un chromosome, après avoir passer l'enfant/phrase
à la mutation. Voici justement la méthode chargée de la mutation:</p>

<p>``` ruby
def mutate(phrase)
  @search_value.size.times do |index|</p>

<pre><code>phrase[index] = random_gene if rand &lt; @mutation_rate
</code></pre>

<p>  end
  phrase
end
```</p>

<p>La différence avec <a href="http://lkdjiin.github.io/blog/2013/08/29/les-algorithmes-genetiques-demystifies-2/">l'algorithme précédent</a> est que cette fois chaque gène
peut muter. Avantage: on est plus proche du phénomène naturel et on pourrait
se retrouver avec un chromosome dont 2 ou 3 gènes sont mutants, ça semble
bon pour la diversité génétique. Inconvénient: Générer un nombre aléatoire
pour chaque gène peut faire tomber les performances si on a un millier de
gènes (ou plus) par chromosome et/ou une population importante. Comme
je dis d'habitude: «Si c'est de l'informatique, c'est une histoire de
compromis».</p>

<p>On peut maintenant créer une méthode <code>next_generation</code> qui englobe la
sélection et la reproduction:</p>

<p>``` ruby
def next_generation
  mating_pool = create_mating_pool
  pool_size = mating_pool.size
  @population = []
  @population_size.times do</p>

<pre><code>parent1 = mating_pool[rand(pool_size)]
parent2 = mating_pool[rand(pool_size)]
@population &lt;&lt; crossover(parent1, parent2)
</code></pre>

<p>  end
end
```</p>

<p>Je ne vais pas vous faire l'affront d'expliquer cette méthode, vous avez
toutes les cartes en main pour la comprendre. Sinon, c'est que j'ai mal
fait mon boulot…</p>

<p>Il reste à mettre tout ça ensemble, voici le code complet du programme:</p>

<p>``` ruby monkey.rb
def make_chromosome
  value = &ldquo;&rdquo;
  length = @search_value.size
  length.times { value += random_gene }
  [nil, value]
end</p>

<p>def random_gene
  @genes[rand(@genes.size)]
end</p>

<p>def make_population
  population = []
  @population_size.times { population &lt;&lt; make_chromosome }
  population
end</p>

<p>def score_population
  evaluate_population
  normalize_population_score
end</p>

<p>def evaluate_population
  @population.map! {|person| [evaluate(person.last), person.last] }
end</p>

<p>def evaluate(phrase)
  score = 0
  phrase.split(&lsquo;&rsquo;).each_with_index do |character, index|</p>

<pre><code>score += 1 if @search_value[index] == character
</code></pre>

<p>  end
  score
end</p>

<p>def normalize_population_score
  total = @population.inject(0) {|sum, person| sum + person.first }
  @population.map! {|person| [person.first.to_f / total * 100, person.last] }
end</p>

<p>def next_generation
  mating_pool = create_mating_pool
  pool_size = mating_pool.size
  @population = []
  @population_size.times do</p>

<pre><code>parent1 = mating_pool[rand(pool_size)]
parent2 = mating_pool[rand(pool_size)]
@population &lt;&lt; crossover(parent1, parent2)
</code></pre>

<p>  end
end</p>

<p>def create_mating_pool
  mating_pool = []
  @population.each do |person|</p>

<pre><code>person.first.to_i.times { mating_pool &lt;&lt; person }
</code></pre>

<p>  end
  mating_pool
end</p>

<p>def crossover(parent1, parent2)
  point = rand(1..@search_value.size)
  child = parent1.last[0&hellip;point] + parent2.last[point..-1]
  [nil, mutate(child)]
end</p>

<p>def mutate(phrase)
  @search_value.size.times do |index|</p>

<pre><code>phrase[index] = random_gene if rand &lt; @mutation_rate
</code></pre>

<p>  end
  phrase
end</p>

<p>def solution_found
  found = false
  @population.each do |person|</p>

<pre><code>found = true if person.last == @search_value
</code></pre>

<p>  end
  found
end</p>

<p>@search_value = &ldquo;Mon royaume pour un cheval&rdquo;
@genes = &ldquo;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ &rdquo;
@population_size = 100
@mutation_rate = 0.01
@population = make_population</p>

<p>1000.times do |generation|
  score_population
  puts &ldquo;Generation: #{generation}&rdquo;
  @population.each {|i| puts i.inspect }
  exit if solution_found
  next_generation
end
```</p>

<p>Et voilà le résultat:</p>

<pre><code>[~/genetic]⇒ ruby monkey.rb 
...
Generation: 869
[1.0092854259184496, "Mon royaume pour un chevaB"]
[1.0092854259184496, "Mon royaume pour un chevan"]
[1.0092854259184496, "Mon royaume pour un chevaB"]
...
[1.0496568429551878, "Mon royaume pour un cheval"]
...
[1.0092854259184496, "Mon royaume pour un chevan"]
[1.0092854259184496, "Mon royaume pour un chevaB"]
[0.9689140088817118, "Mon royaume pour un chNvaB"]
</code></pre>

<p>La prochaine fois on va améliorer notre méthode de sélection pour
tenir compte des chiffres après la virgule.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
