<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : intermédiaire | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/intermediaire/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-09-25T14:28:48+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 22]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/25/les-algorithmes-genetiques-demystifies-22/"/>
    <updated>2013-09-25T14:22:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/25/les-algorithmes-genetiques-demystifies-22</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Après avoir trouver comment représenter un chromosome pour le
problème des 8 dames (<a href="http://lkdjiin.github.io/blog/2013/09/24/les-algorithmes-genetiques-demystifies-21-probleme-des-8-dames/">article précédent</a>),
on regarde aujourd'hui comment réaliser l'évaluation de la population.</p>

<!-- more -->


<p>Sans plus attendre, voici la classe <code>Evaluator</code> dans toute sa
splendeur, on la détaille après:</p>

<p>``` ruby
class Evaluator
  def initialize(board_size, population)</p>

<pre><code>@board_size = board_size
@population = population
</code></pre>

<p>  end</p>

<p>  def evaluate</p>

<pre><code>@population.each {|individual| score(individual) }
fitness
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def score(individual)</p>

<pre><code>individual.score = 1.0 / conflicts(individual)
</code></pre>

<p>  end</p>

<p>  def conflicts(individual)</p>

<pre><code># Calcule et renvoie le nombre de paires de dames en conflits.
</code></pre>

<p>  end</p>

<p>  def fitness</p>

<pre><code>total = @population.inject(0) {|sum, individual| sum + individual.score }
@population.each do |individual|
  individual.fitness = individual.score.to_f / total * @population.size
end
</code></pre>

<p>  end
end
```</p>

<p>Tout d'abord le constucteur:</p>

<p><code>ruby
  def initialize(board_size, population)
</code></p>

<p>Il prends comme paramêtre la taille de l'échiquier et la population à
évaluer. Trouver une solution pour un échiquier de 8 x 8 cases ne
devrait pas être trop difficile et il sera plus intéressant de voir
comment l'algorithme se débrouille avec des échiquiers de plus grande
taille.</p>

<p>La méthode <code>evalute</code> est identique à celle de la
<a href="http://lkdjiin.github.io/blog/2013/09/19/les-algorithmes-genetiques-demystifies-18/">dernière fois</a>:
elle calcule le <em>score</em> puis le <em>fitness</em> de chaque individu.</p>

<p>Passons à la méthode <code>conflicts</code>, qui n'est pas encore implémentée:</p>

<p>``` ruby
  def conflicts(individual)</p>

<pre><code># Calcule et renvoie le nombre de paires de dames en conflits.
</code></pre>

<p>  end
```</p>

<p>C'est en calculant le nombre de paires de dames en conflits qu'on pourra
évaluer les différentes positions. Plus il y a de conflits, plus on est
loin d'une solution. À l'inverse, une solution possède zéro conflits.
L'implémentation sera pour la prochaine fois.</p>

<p>Voyons maintenant la méthode <code>score</code>:</p>

<p>``` ruby
  def score(individual)</p>

<pre><code>individual.score = 1.0 / conflicts(individual)
</code></pre>

<p>  end
```</p>

<p>Pourquoi diviser 1 par le nombre de conflits ? Pourquoi ne pas avoir écrit
simplement <code>individual.score = conflicts(individual)</code> ?
Parce que je ne trouve pas naturel qu'un score de zéro soit meilleur qu'un
score de 5, 10, 20, etc. Je préfère donc calculer l'inverse du nombre de
conflits. De cette manière si il y a 10 conflits, le score sera 0,1 et si il
y a 2 conflits le score sera 0,5. Et si il y a zéro conflits ? Ruby ne pose
pas de problème avec les nombres réèls:</p>

<p>``` irb
[~]⇒ irb</p>

<blockquote><blockquote><p>1.0 / 0
Infinity
```</p></blockquote></blockquote>

<p>Je saurais donc que j'ai trouvé une solution quand un score sera supérieur
à 1. Avec d'autres langages on peut gérer ça avec des exceptions, des erreurs,
détecter la division par zéro avant de la faire, etc. Ou encore ajouter
une petite valeur au nombre de conflits, par exemple:</p>

<pre><code>score = 1.0 / (nombre_de_conflits + 0.1)
</code></pre>

<p>La prochaine fois on verra comment calculer le nombre de conflits.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 21: Problème des 8 dames]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/24/les-algorithmes-genetiques-demystifies-21-probleme-des-8-dames/"/>
    <updated>2013-09-24T10:04:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/24/les-algorithmes-genetiques-demystifies-21-probleme-des-8-dames</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>On va tenter de résoudre le problème des 8 dames à l'aide d'un algorithme
génétique.</p>

<p><blockquote><p>Le but du problème des huit dames est de placer huit dames d'un jeu d'échecs sur un échiquier de 8 × 8 cases sans que les dames ne puissent se menacer mutuellement, conformément aux règles du jeu d'échecs (la couleur des pièces étant ignorée). Par conséquent, deux dames ne devraient jamais partager la même rangée, colonne, ou diagonale.</p><footer><strong>Wikipédia <a href="http://fr.wikipedia.org/wiki/Probl%C3%A8me_des_huit_dames">http://fr.wikipedia.org/wiki/Probl%C3%A8me_des_huit_dames</a></strong></footer></blockquote></p>

<!-- more -->


<p>Avant toute chose, il faut trouver comment nos chromosomes vont pouvoir
représenter une solution potentielle. On pourrait coder ça sous forme
d'une chaîne de 64 bits, un par case, les 0 étants des cases vides et
les 1 étants les cases occupées par les dames. On pourrait aussi les coder
comme un tableau à deux dimensions, soit 8 rangées multipliées par 8 colonnes.
En y regardant de plus près (ou simplement en relisant la définition du
problème), on remarque que pour qu'une solution soit
viable, il faut une seule dame par rangée, une seule par colonne et une
seule par diagonale. On peut donc se contenter d'une liste (un tableau) de
8 nombres entiers, ces nombres étants le numéro de la colonne. Ainsi, pour
un échiquier de 4 x 4 cases, la liste <code>[0, 2, 3, 3]</code> équivaut à la position
suivante:</p>

<pre><code>---------
|D| | | |
---------
| | |D| |
---------
| | | |D|
---------
| | | |D|
---------
</code></pre>

<p>Maintenant on peut s'occuper de la population. Je vais me servir du code
objet développé dans les derniers articles, en essayant de le modifier
le moins possible.</p>

<p>``` ruby
class Individual
  def self.random(chromosome_size)</p>

<pre><code>new(nil, chromosome_size)
</code></pre>

<p>  end</p>

<p>  def self.from_chromosome(chromosome)</p>

<pre><code>new(chromosome)
</code></pre>

<p>  end</p>

<p>  attr_accessor :score, :fitness
  attr_reader :chromosome</p>

<p>  def initialize(chromosome = nil, chromosome_size = nil)</p>

<pre><code>if chromosome
  @chromosome = chromosome
else
  @chromosome = []
  chromosome_size.times { @chromosome &lt;&lt; Gene.random(chromosome_size) }
end
</code></pre>

<p>  end
  private_class_method :new
end</p>

<p>class Gene
  def self.random(limit)</p>

<pre><code>rand(limit)
</code></pre>

<p>  end
end</p>

<p>class Population &lt; Array
  def initialize(chromosome_size, population_size)</p>

<pre><code>population_size.times { self &lt;&lt; Individual.random(chromosome_size) }
</code></pre>

<p>  end</p>

<p>  def best</p>

<pre><code>self.sort_by{|individual| individual.score}.last
</code></pre>

<p>  end
end
```</p>

<p>J'ai été obligé de modifier la méthode <code>initialize</code> de la classe <code>Individual</code>
ainsi que la classe <code>Gene</code>. Il faudra en tenir compte si on veut qu'un
framework sorte de tout ça…</p>

<p>Le prochain article traitera de l'évaluation du problème des 8 dames.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 20]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/23/les-algorithmes-genetiques-demystifies-20/"/>
    <updated>2013-09-23T18:41:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/23/les-algorithmes-genetiques-demystifies-20</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>C'est le vingtième article de cette série sur les algorithmes génétiques et
j'aimerai en profiter pour dresser un petit bilan provisoire.</p>

<!-- more -->


<p>On a vu le fonctionnement d'un algorithme génétique à l'aide de deux exemples
simples. Dans le premier exemple il s'agissait de trouver une expression comme
«123+54x3» et dans le second il fallait trouver la chaîne «Mon royaume pour un
cheval».</p>

<p>On a appris à représenter une population d'individus. Chaque individu étant une
solution potentielle du problême posé. Cette solution est codée dans le
chromosome d'un individu. On a vu l'utilisation «historique» d'une chaîne de
bits pour réprésenter les chromosomes, mais aussi qu'on pouvait utiliser une
chaîne de caractères quelconques. En fait, il ne faut pas hésiter à représenter
les chromosomes comme bon vous semble.</p>

<p>On a vu ensuite la phase d'évaluation de la population. Il s'agit d'abord
d'évaluer un chromosome seul en lui affectant un score, puis de l'évaluer par
rapport aux autres chromosomes, en lui affectant un <em>fitness</em> (aptitude).  Le
fitness permettant d'être plus fin lors de l'étape de sélection.</p>

<p>Pour l'étape de la sélection, nous avons vu deux manières de faire :
l'élitisme et la roue de la fortune. L'élitisme consiste à ne conserver
qu'un pourcentage des meilleurs spécimens d'une génération. La roue de la
fortune consiste à donner à chaque individu une chance plus ou moins
grande de se reproduire en rapport avec son <em>fitness</em>.</p>

<p>Nous avons fait se reproduire les individus/solutions selectionnés par
croisement de leurs chromosomes. À partir de deux parents, nous avons
obtenu un ou deux enfants. On a utilisé la méthode du croisement en
un point, du croisement en deux points et du croisement uniforme.</p>

<p>Enfin, la mutation (ou l'apport de matériel génétique inédit d'une façon ou d'une
autre) a joué un rôle déterminant pour éviter à nos algorithmes de tomber dans
un extremum local.</p>

<p>En résumé, on a abordé pas mal de choses. Mais ce n'est que la surface
de l'iceberg.</p>

<p>Pour les articles à venir, je pense me pencher sur le
<a href="http://fr.wikipedia.org/wiki/Probl%C3%A8me_des_huit_dames">problème des 8 dames</a>.
Ça permettra de voir une autre façon de coder un chromosome et aussi de
confronter les classes développées dans les derniers articles à un
problème bien différent. Ensuite, j'aimerais résoudre un problème visuel.
Du genre : «Si je dispose de 1000 carrés de taille et de couleur quelconque,
quelle est la meilleure disposition pour s'approcher au mieux d'une
image donnée ?». C'est typiquement le genre de problème qui pourrait
tourner dans les navigateurs et être codé en Javascript. Avez-vous
d'autres idées/envies pour la suite ?</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 19]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/20/les-algorithmes-genetiques-demystifies-19/"/>
    <updated>2013-09-20T09:31:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/20/les-algorithmes-genetiques-demystifies-19</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Suite et fin de la transformation en code orienté objet de l'algorithme
génétique sur le paradoxe du singe savant.</p>

<!-- more -->


<p>Le rôle de la classe <code>MatingPool</code> est de sélectionner les individus pour
la reproduction, suivant la méthode de la roue de la fortune:</p>

<p>``` ruby
class MatingPool
  def initialize(population)</p>

<pre><code>@mating_pool = []
population.each do |individual|
  integer_part = individual.fitness.to_i
  real_part = individual.fitness - integer_part
  integer_part.times { @mating_pool &lt;&lt; individual.dup }
  @mating_pool &lt;&lt; individual.dup if rand &lt; real_part
end
@size = @mating_pool.size
</code></pre>

<p>  end</p>

<p>  def random</p>

<pre><code>@mating_pool[rand(@size)]
</code></pre>

<p>  end
end
```</p>

<p>Au passage, la méthode <code>random</code> permettra de choisir un parent au hasard.</p>

<p>Les classes <code>Crossover</code> et <code>Mutator</code> s'occupent bien sûr de la partie
reproduction:</p>

<p>``` ruby
class Crossover
  def initialize(chromosome_size, mutation_rate)</p>

<pre><code>@size = chromosome_size
@rate = mutation_rate
@mutator = Mutator.new(@size, @rate)
</code></pre>

<p>  end</p>

<p>  def two_point(parent1, parent2)</p>

<pre><code>child = assemble(parent1, parent2, two_cut_points)
child = @mutator.mutate(child)
Individual.from_chromosome(child)
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def two_cut_points</p>

<pre><code>point1 = cut_point
point2 = cut_point
point1, point2 = point2, point1 if point1 &gt; point2
[point1, point2]
</code></pre>

<p>  end</p>

<p>  def cut_point</p>

<pre><code>rand(@size)
</code></pre>

<p>  end</p>

<p>  def assemble(parent1, parent2, points)</p>

<pre><code>point1, point2 = points
parent1.chromosome[0...point1] + parent2.chromosome[point1..point2] +
  parent1.chromosome[point2+1..-1]
</code></pre>

<p>  end
end</p>

<p>class Mutator
  def initialize(chromosome_size, mutation_rate)</p>

<pre><code>@size = chromosome_size
@rate = mutation_rate
</code></pre>

<p>  end</p>

<p>  def mutate(chromosome)</p>

<pre><code>@size.times {|index| chromosome[index] = Gene.random if rand &lt; @rate }
chromosome
</code></pre>

<p>  end
end
```</p>

<p>Le code de ces trois classes reprends plus ou moins le code développé en
style procédural dans les articles précédents et je ne vois pas tellement
ce que je pourrais en dire de plus. Il reste donc à lancer la machine:</p>

<p><code>ruby
generations = 500
search = "Mon royaume pour un cheval"
population = Population.new(search.size, 1000)
mutation = 0.001
GeneticAlgorithm.new(generations, population, search, mutation).run
</code></p>

<p>Voilà, c'est terminé pour le code objet. Quand j'aurais présenter 2 ou 3
algorithmes génétiques de plus, on verra quelles classes résistent et peuvent
être réutilisées et lesquelles doivent être repensées. Ça nous conduira
éventuellement vers la création d'un framework…</p>

<p>À demain</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 18]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/19/les-algorithmes-genetiques-demystifies-18/"/>
    <updated>2013-09-19T18:14:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/19/les-algorithmes-genetiques-demystifies-18</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>On continue la transformation en code orienté objet de l'algorithme génétique
sur le paradoxe du singe savant.</p>

<!-- more -->


<p>D'abord la classe <code>Evaluator</code>, dont le rôle est d'évaluer la population:</p>

<p>``` ruby
class Evaluator
  def initialize(search_value, population)</p>

<pre><code>@search_value = search_value
@population = population
</code></pre>

<p>  end</p>

<p>  def evaluate</p>

<pre><code>@population.each {|individual| score(individual) }
fitness
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def score(individual)</p>

<pre><code>score = 0
individual.chromosome.split('').each_with_index do |character, index|
  score += 1 if @search_value[index] == character
end
individual.score = score
</code></pre>

<p>  end</p>

<p>  def fitness</p>

<pre><code>total = @population.inject(0) {|sum, individual| sum + individual.score }
size = @population.size
@population.each do |individual|
  individual.fitness = individual.score.to_f / total * size
end
</code></pre>

<p>  end
end
```</p>

<p>On voit le découpage entre <em>score</em> et <em>fitness</em>, dont on a parlé hier.</p>

<p>Ensuite, voici la classe <code>GeneticAlgorithm</code>:</p>

<p>``` ruby
class GeneticAlgorithm
  def initialize(generations, population, search_value, mutation_rate)</p>

<pre><code>@generations = generations
@population = population
@search_value = search_value
@mutation_rate = mutation_rate
@crossover = Crossover.new(search_value.size, mutation_rate)
</code></pre>

<p>  end</p>

<p>  def run</p>

<pre><code>@generations.times do |generation|
  Evaluator.new(@search_value, @population).evaluate
  best = @population.best
  display(generation, best)
  exit if best.score == @search_value.size
  next_generation
end
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def display(generation, best)</p>

<pre><code>puts "----------------------"
puts "Gen: #{generation}"
puts "Best: #{best.chromosome}"
</code></pre>

<p>  end</p>

<p>  def next_generation</p>

<pre><code>pool = MatingPool.new(@population)
population_size = @population.size
@population.clear
population_size.times do
  @population &lt;&lt; @crossover.two_point(pool.random, pool.random)
end
</code></pre>

<p>  end
end
```</p>

<p>La méthode <code>run</code> remplace la fonction principale qu'on avait dans nos
scripts jusqu'ici. En écrivant l'article, je vois que la méthode <code>display</code>
me dérange : elle ne repose sur aucun membre, elle serait donc mieux dans
une classe à part entière.</p>

<p>Voilà, c'est un peu court en explication comme article et je m'en excuse
mais aujourd'hui je suis très préssé. La prochaine fois on parle des classes
<code>MatingPool</code>, <code>Crossover</code> et <code>Mutator</code>.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
