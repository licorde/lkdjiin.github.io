<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : intermédiaire | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/intermediaire/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-08-28T09:57:56+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/28/les-algorithmes-genetiques-demystifies/"/>
    <updated>2013-08-28T09:49:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/28/les-algorithmes-genetiques-demystifies</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p><strong>démystifié</strong>:
<blockquote><p>Enlever le caractère mystérieux.</p></blockquote></p>

<p>Un algorithme génétique c'est quoi ? Comment ça marche ? À quoi ça sert ?
Si vous vous posez une de ces questions, cette
nouvelle série d'articles peut vous
intéresser.</p>

<!-- more -->


<h2>Une définition simple</h2>

<p>Tout d'abord, un algorithme génétique est un <em>algorithme</em>. Autrement dit
c'est une suite d'instructions, ou encore une recette, pour résoudre un
problème. C'est peut-être bidon pour certains d'entre vous, mais ça va mieux
en le disant.</p>

<p>Ensuite, pourquoi génétique ? Et bien parce que pour résoudre un problème,
cette catégorie d'algorithmes s'inspire de la biologie, de la génétique,
et notamment du mécanisme de la séléction naturelle et/ou artificielle.</p>

<h2>La démarche</h2>

<p>Pour faire court:</p>

<ol>
<li>On crée une population au hasard. Chaque individu représente une solution
possible au problème posé.</li>
<li>On évalue chaque individu (solution) de la population. En clair, on leur
donne une note.</li>
<li>On selectionne certains individus parmi les plus adaptés.</li>
<li>Les individus (solutions) sélectionnés se reproduisent pour donner
naissance à la nouvelle génération, qui est globalement plus adaptée.</li>
<li>On recommence au point 2 jusqu'à ce qu'on trouve la solution du
problème.</li>
</ol>


<h2>Les domaines d'application</h2>

<p>Tous, ou presque. Trouver le meilleur profil pour une hélice de bateau ou
une aile d'avion, apprendre à marcher à un robot, adapter le comportement
d'un personnage dans un jeu vidéo, maximiser l'exploitation du volume
d'un hangar, etc. Comme chaque nouvelle génération produit globalement
une meilleure solution, les algorithmes génétiques peuvent être très
intéressants lorsqu'on veut obtenir une <em>bonne</em> solution rapidement (et
pas forcement la <em>meilleure</em> solution).</p>

<p>Dans mes prochains articles, je parlerais plus en détails de ces
algorithmes et je montrerais notamment comment les coder.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un langage sur Parrot - partie 11: Arbre syntaxique abstrait]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/26/un-langage-sur-parrot-partie-11-arbre-syntaxique-abstrait/"/>
    <updated>2013-08-26T08:48:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/26/un-langage-sur-parrot-partie-11-arbre-syntaxique-abstrait</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Dans le dernier épisode, je me suis rendu compte que j'aurais intéret
à utiliser un arbre syntaxique abstrait pour mon petit langage. En
voici une première implémentation.</p>

<!-- more -->


<p>Un arbre syntaxique abstrait (<em>Abstract Syntax Tree</em> en anglais, ou AST)
est avant tout une manière de structurer des données:</p>

<pre><code>    A
   / \
  B   C
 / \   \
D   E   F
   /
  G
</code></pre>

<p>On part d'un noeud racine (ici <code>A</code>) et on ajoute des branches qui mènent à
d'autres noeuds. On peut distinguer les noeuds terminaux (<code>D</code>, <code>F</code> et <code>G</code>) des
noeuds non-terminaux.
Les noeuds terminaux, aussi appelés feuilles, contiennent une valeur. Les noeuds
non-terminaux contiennent d'autres noeuds.
C'est une manière pratique de représenter un code source,
l'AST étant (assez) facilement manipulable. Il est dit abstrait dans le sens
où il ne contient pas chaque éléments du langage source. Par exemple, les
parenthèses, les virgules, ou encore les débuts et fins de blocs sont
souvent absents de l'AST. Si vous voulez en savoir plus sur les AST:
<a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree">http://en.wikipedia.org/wiki/Abstract_syntax_tree</a>.</p>

<p>Le code qui suit est sur <a href="https://github.com/lkdjiin/naam">Github</a>,
à la version 0.0.5.</p>

<p>L'objectif est de créer l'AST et de le visualiser ainsi:</p>

<pre><code>program
  function definition
    header
      name ::= sign
      argument ::= n
    if clause
      return value ::= 1
      test
        left value ::= n
        operator value ::= &gt;
        right value ::= 0
    if clause
      return value ::= -1
      test
        left value ::= n
        operator value ::= &lt;
        right value ::= 0
    else clause
      return value ::= 0
  print statement ::= sign(4)
</code></pre>

<p>Voici la classe de base de l'AST:</p>

<p>``` ruby
module Naam::AST
  class Node</p>

<pre><code>def initialize name
  @name = name
  @children = []
end

attr_reader :children, :name

def add_child child; @children &lt;&lt; child; end

def leaf?; @children.empty?; end

def display(indent = 0)
  print " " * indent + @name
  print " ::= #{@value}" if leaf?
  puts
  @children.each {|child| child.display(indent + 2) }
end
</code></pre>

<p>  end
end
```</p>

<p>Elle permet entre autres d'ajouter un noeud enfant avec <code>add_child</code> et de
déterminer si un noeud est une feuille avec <code>leaf?</code>. La méthode <code>display</code>,
appliquée sur le noeud racine permettra d'afficher l'arbre complet.</p>

<p>Un noeud non-terminal ressemblera à ça:</p>

<p>``` ruby
module Naam::AST
  class Program &lt; Node</p>

<pre><code>def initialize
  super("program")
end
</code></pre>

<p>  end
end
```</p>

<p>Pour un noeud terminal (une feuille), on ajoutera simplement une valeur:</p>

<p>``` ruby
module Naam::AST
  class Argument &lt; Node</p>

<pre><code>def initialize value
  super("argument")
  @value = value
end
</code></pre>

<p>  end
end
```</p>

<p>Comment appliquer tout ça ? Directement dans le <em>syntaxer</em>. En voici
quelques extraits:</p>

<p>``` ruby
module Naam::Parser
  class Syntaxer</p>

<pre><code>def initialize
  # ...
  @ast = Naam::AST::Program.new
end

# ...

def function_def
  node = Naam::AST::FunctionDef.new
  @ast.add_child node
  function_header(node)
  if_clause(node) while if_clause?
  else_clause(node)
end

def function_header(node)
  @series = []
  accept_series(:word, :paro, :word, :parc, :affect, :eol)
  f_header = Naam::AST::FunctionHeader.new
  f_header.add_child(Naam::AST::Name.new(@series[0].value))
  f_header.add_child(Naam::AST::Arg.new(@series[2].value))
  node.add_child(f_header)
end

# ...
</code></pre>

<p>  end
end
```</p>

<p>L'AST va me permettre de faire un truc plus propre (même si cette classe
<code>Syntaxer</code> demande toujours un gros <em>refactoring</em>) et de manipuler plus
aisement le code source.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Implémenter un langage sur Parrot - partie 10: émettre le code assembleur]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/20/implementer-un-langage-sur-parrot-partie-10-emettre-le-code-assembleur/"/>
    <updated>2013-08-20T10:01:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/20/implementer-un-langage-sur-parrot-partie-10-emettre-le-code-assembleur</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Maintenant qu'on a
<a href="http://lkdjiin.github.io/blog/2013/08/18/implementer-un-langage-sur-parrot-partie-9-la-syntaxe/">vérifié la syntaxe</a>
de notre petit programme, on peut sortir le code assembleur PIR:</p>

<p><code>ruby lib/naam/main.rb
def self.run(filename)
  # ...
  comp = Compiler.new
  comp.compile(units.dup)
end
</code></p>

<!-- more -->


<p>Voici le module Emitter:</p>

<p>``` ruby lib/naam/emitter.rb
module Naam
  module Emitter</p>

<pre><code># Output the main procedure.
#
# series - An Array of String.
#
# Examples
#
#   Emitter.main(["foo(4)", "bar(-1)"]
#   # =&gt; .sub main :main
#   # =&gt;     .local int f
#   # =&gt;     f = foo(4)
#   # =&gt;     say f
#   # =&gt;     f = bar(-1)
#   # =&gt;     say f
#   # =&gt; .end
#
# Returns nothing.
def self.main(series)
  unless series.empty?
    puts
    puts ".sub main :main"
    puts "    .local int f"
    series.each do |str|
      puts "    f = #{str}"
      puts "    say f"
    end
    puts ".end"
  end
end

# Dispatch different kind of emit message.
#
# type   - A Symbol in :function_header, :function_footer,
#          :if_clause, :else_clause and :label.
# series - An Array of LexicalUnit.
# label  - Hash like { label: "NAME", value: "123" }. Could be nil.
#
# Returns nothing.
def self.emit(type, series, label)
  case type
  when :function_header then function_header(series)
  when :function_footer then function_footer
  when :if_clause then if_clause(series, label)
  when :else_clause then else_clause(series)
  when :label then label(series, label)
  else
    raise Error
  end
end

def self.function_header(series)
  puts ".sub " + series[0].value
  puts "    .param int " + series[2].value
  puts "    .local int result"
  puts
end

def self.function_footer
  puts "RETURN:"
  puts "    .return(result)"
  puts ".end"
end

def self.if_clause(series, label)
  puts "    if #{series[2].value} #{series[3].value} #{series[4].value} " +
       "goto #{label[:label]}"
end

def self.else_clause(series)
  puts "    result = #{series[0].value}"
  puts "    goto RETURN"
end

def self.label(series, label)
  puts label[:label] + ":"
  puts "    result = #{label[:value]}"
  puts "    goto RETURN"
end
</code></pre>

<p>  end
end
```</p>

<p>Et voilà quelques morceaux choisis dans la class Compiler pour montrer
son utilisation:</p>

<p>``` ruby lib/naam/compiler.rb
module Naam</p>

<p>  # Public: Here we transform a list of lexical units in a PIR source
  # code. At least this is the goal.
  #
  # The logic of this class try follow the grammar of Naam (see the file
  # grammar.md).
  class Compiler</p>

<pre><code>def initialize
  @series = []
  @current_label = "LABEL0000"
  @labels = []
  @main = []
end

# Public: Compile lexical units from a Naam program in a PIR
# program.
#
# units - Array of LexicalUnits
#
# Returns nothing.
def compile units
  @units = units
  program
end

private

# This is the entry rule.
#
# Returns nothing.
def program
  while @units.size &gt; 0
    @series = []
    case @units.first.type
    when :eol then accept(:eol)
    else
      instruction
    end
  end
  @labels.each {|lbl| emit(:label, lbl) }
  emit(:function_footer)
  Emitter.main(@main)
end

# ...

# Returns nothing.
def function_def
  accept_series(:word, :paro, :word, :parc, :affect, :eol)
  emit(:function_header)
  if_clause while if_clause?
  else_clause
end

# ...

# Send a message to Emitter module.
#
# type  - A Symbol (see Emitter).
# label - A Hash composed of:
#         :label - The label name as a String.
#         :value - The String value that will be returned by
#                  PIR instructions for this label.
#         By default, label is nil and unused.
#
# Returns nothing.
def emit(type, label = nil)
  Emitter.emit(type, @series, label)
  @series = []
end

# Get a label.
#
# value - String value associated to the label.
#
# Examples
#
#   next_label("123")
#   # =&gt; { label: "LABEL0000", value: "123" }
#   next_label("-9")
#   # =&gt; { label: "LABEL0001", value: "-9" }
#
# Returns the Hash label.
def next_label(value)
  temp = { label: @current_label, value: value }
  @labels &lt;&lt; temp
  @current_label = @current_label.next
  temp
end
</code></pre>

<p>  end
end
```</p>

<p>Maintenant que je le montre, je me rends compte que ce code n'est pas
terrible. Bien que le fichier source à compiler soit extremement simple,
je suis déjà obligé de faire un tas de contorsions, notamment pour sortir
la procédure main. Je pensais que c'était une bonne idée de méler
vérification de la syntaxe et production du code assembleur pour montrer
les relations entre ces deux phases, mais visiblement ça n'aide pas
à la clarté du code. La meilleure solution pour m'en sortir est, je pense,
de me servir d'un AST (Arbre syntaxique abstrait). La prochaine fois je
parlerais donc de l'AST.</p>

<p>À demain.</p>

<p></p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Implémenter un langage sur Parrot - partie 9: la syntaxe]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/18/implementer-un-langage-sur-parrot-partie-9-la-syntaxe/"/>
    <updated>2013-08-18T08:01:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/18/implementer-un-langage-sur-parrot-partie-9-la-syntaxe</id>
    <content type="html"><![CDATA[<p>Après avoir écrit un
<a href="http://lkdjiin.github.io/blog/2013/08/12/parrot-6-ecrire-le-tokenizer/">tokenizer</a>,
avoir produit les <a href="http://lkdjiin.github.io/blog/2013/08/13/implementer-un-langage-sur-parrot-partie-7-le-lexer/">unités lexicales</a>
et avoir défini
<a href="http://lkdjiin.github.io/blog/2013/08/17/implementer-un-langage-sur-parrot-partie-8-la-grammaire/">une grammaire</a>
pour le langage Naam, je passe maintenant à la vérification de la syntaxe.</p>

<!-- more -->


<p>La vérification de la syntaxe se passe dans la classe <code>Compiler</code>. <em>&ndash; C'est pas
le meilleur choix de nom et ça changera par la suite &ndash;</em>. Basiquement, cette
classe ne fait que suivre la logique de la grammaire.</p>

<p>``` ruby lib/naam/compiler.rb
class Compiler</p>

<p>  # units &ndash; Array of LexicalUnits
  def compile units</p>

<pre><code>@units = units
program
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def program</p>

<pre><code>while @units.size &gt; 0
  case @units.first.type
  when :eol then accept(:eol)
  else
    instruction
  end
end
</code></pre>

<p>  end</p>

<p>  def instruction</p>

<pre><code>case @units.first.type
when :keyword then print_statement
when :word then function_def
else
  raise Error
end
</code></pre>

<p>  end</p>

<p>  def print_statement</p>

<pre><code>accept(:keyword, 'print')
accept_series(:word, :paro, :int, :parc, :eol)
</code></pre>

<p>  end</p>

<p>  def function_def</p>

<pre><code>accept_series(:word, :paro, :word, :parc, :affect, :eol)
if_clause while if_clause?
else_clause
</code></pre>

<p>  end</p>

<p>  def if_clause</p>

<pre><code>accept(:int)
accept(:keyword, 'if')
test
accept(:eol)
</code></pre>

<p>  end</p>

<p>  def else_clause</p>

<pre><code>accept(:int)
accept(:keyword, 'else')
accept(:eol)
</code></pre>

<p>  end</p>

<p>  def test</p>

<pre><code>accept_series(:word, :op, :int)
</code></pre>

<p>  end</p>

<p>  def accept(type, value = &lsquo;&rsquo;)</p>

<pre><code>unit = @units.slice!(0)
raise Error unless unit.type == type
if value != ''
  raise Error unless unit.value == value
end
</code></pre>

<p>  end</p>

<p>  def accept_series(*args)</p>

<pre><code>args.each {|arg| accept(arg) }
</code></pre>

<p>  end</p>

<p>  def if_clause?</p>

<pre><code>@units[1].type == :keyword &amp;&amp; @units[1].value == 'if'
</code></pre>

<p>  end
end
```</p>

<p>Quelques commentaires sur ce code:</p>

<p>``` ruby
def instruction
  # &hellip;
  else</p>

<pre><code>raise Error
</code></pre>

<p>  end
end
```</p>

<p>Plusieurs fois j'utilise la classe <code>Error</code>, qui n'existe pas. C'est parce que
je ne veux pas encore réfléchir à la gestion des erreurs. Les seuls cas qui
m'intéressent pour l'instant sont ceux où ça fonctionne.</p>

<p>`&ldquo; ruby
def accept(type, value = &rdquo;)
  unit = @units.slice!(0)
  raise Error unless unit.type == type
  if value != &lsquo;&rsquo;</p>

<pre><code>raise Error unless unit.value == value
</code></pre>

<p>  end
end
```</p>

<p>C'est la méthode <code>accept</code>, toute simple, qui effectue la vérification
de la syntaxe en comparant l'unité lexicale attendue avec celle réellement
disponible. On constate que les unités lexicales (représentées par <code>@units</code>)
sont détruites au fur et à mesure de leur consommation.</p>

<p>La prochaine, il sera enfin temps d'émettre le code PIR.</p>

<p>À demain.
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Implémenter un langage sur Parrot - partie 8: la grammaire]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/17/implementer-un-langage-sur-parrot-partie-8-la-grammaire/"/>
    <updated>2013-08-17T09:29:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/17/implementer-un-langage-sur-parrot-partie-8-la-grammaire</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Écrire un langage sans en spécificier la grammaire c'est un peu comme se
tirer une balle dans le pied. Même quand le langage est aussi simple et
petit que
Naam (voir l'<a href="http://lkdjiin.github.io/blog/2013/08/01/implementer-un-langage-sur-la-machine-virtuelle-parrot-partie-1/">article originel</a>),
c'est un gain de temps pour la suite.</p>

<!-- more -->


<p>Pour spécificier la grammaire d'un langage informatique, on utilise
généralement la
<a href="http://fr.wikipedia.org/wiki/Forme_de_Backus-Naur">BNF</a>,
(Backus Naur Form) ou l'une de ses extensions. Il n'est pas rare qu'un auteur
utilise une version personnalisée de la BNF, et c'est ce que je vais faire
pour Naam.</p>

<p>Voici les quelques règles de la méta-syntaxe:</p>

<pre><code>{foo}         zero or more foo
foo | bar     foo or bar
foo           a non-terminal foo
'foo'         keyword foo
[foo]         zero or one foo
---           free speech
</code></pre>

<p>Et voici la grammaire de Naam:</p>

<pre><code>program           ::= {instruction | eol}

instruction       ::= function_def | print_statement

print_statement   ::= 'print' word ( int ) eol

function_def      ::= word ( word ) = eol {if_clause} else_clause

if_clause         ::= int 'if' test eol

test              ::= word op int

else_clause       ::= int 'else' eol

op                ::= &lt; | &gt;

eol               ::= --- End of line
int               ::= --- Integer
word              ::= --- Anything else
</code></pre>

<p>Cette grammaire est vraiment toute petite, mais suffisante pour spécifier
le programme suivant, qui est ce que j'ai choisi pour commencer à écrire
le compilateur Naam:</p>

<pre><code>sign(n)=
1 if n &gt; 0
-1 if n &lt; 0
0 else
</code></pre>

<p>Alors pourquoi écrire une grammaire ? Pourquoi ne pas commencer à coder
directement le compilateur ? Parce qu'il faut bien avouer qu'écrire une
telle grammaire n'a rien d'amusant. Tout d'abord une grammaire, même petite,
possède toujours un certain niveau de complexité qu'il est difficile de
faire tenir entièrement dans sa tête. En l'écrivant on met à jour certains
problèmes qui sinon resteraient cachés longtemps. Autre intéret d'écrire la
grammaire: chaque règle va devenir un morceau de code ; écrire la grammaire
c'est un peu comme avoir déjà écrit une partie du compilateur.
Dans un prochain article je suivrais cette grammaire pour effectuer la
vérification de la syntaxe.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
