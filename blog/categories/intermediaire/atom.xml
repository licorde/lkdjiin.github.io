<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : intermédiaire | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/intermediaire/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-08-29T09:47:23+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/29/les-algorithmes-genetiques-demystifies-2/"/>
    <updated>2013-08-29T09:29:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/29/les-algorithmes-genetiques-demystifies-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Dans cette seconde partie, on commence à coder…</p>

<p>J'ai choisi un problème simple: trouver une expression qui vaut 987 en
mélangeant les chiffres de 0 à 9 et les symboles +, &ndash;, / et %, respectivement
pour addition, soustraction, division entière et reste de la division.
L'expression comportera 12 caractères/symboles maximum. Par exemple:</p>

<ul>
<li>&ldquo;987&rdquo;</li>
<li>&ldquo;900+87&rdquo;</li>
<li>&ldquo;2000/2-13&rdquo;</li>
</ul>


<p>sont différentes solutions possibles au problème posé.</p>

<!-- more -->


<p>Je n'utilise pas la multiplication pour éviter d'avoir des nombres trop
grands (<code>**</code> est l'opérateur de puissance en Ruby, comme dans certains
autres langages).</p>

<p>La première chose à faire est de définir comment on va coder les gènes.
Traditionnellement, ils sont représentés sous la forme d'une chaîne de bits.
Comme on a 14 symboles (10 chiffres et 4 opérateurs mathématiques) à
coder, 4 bits sont suffisants. Les 2 derniers encodages sont des gènes qui
ne font rien:</p>

<pre><code>0000 0
0001 1
0010 2
0011 3
0100 4
0101 5
0110 6
0111 7
1000 8
1001 9
1010 +
1011 -
1100 /
1101 %
1110 ne rien faire
1111 ne rien faire
</code></pre>

<p>L'expression recherchée devant faire au maximum 12 caractères de long, nos
chromosomes mesureront 48 bits (12 caractères multiplié par 4 bits).</p>

<p>Le problème est posé,
c'est parti pour le code. Il est en Ruby mais je vais faire en sorte
qu'il soit compréhensible par tous et facilement transposable dans
votre langage de prédilection.</p>

<p>On doit pouvoir créer un chromosome au hasard:</p>

<p><code>ruby
def make_chromosome
  value = ""
  48.times { value += rand(0..1).to_s }
  [nil, value]
end
</code></p>

<p>Cette fonction renvoie une liste avec <code>nil</code>, qui sera plus tard utilisé
pour mémoriser l'évaluation du chromosome (son score) et une chaîne de
48 caractères au hasard parmi &ldquo;1&rdquo; et &ldquo;0&rdquo;.</p>

<p>On peut maintenant fabriquer une population complète:</p>

<p><code>ruby
def make_population
  population = []
  100.times { population &lt;&lt; make_chromosome }
  population
end
</code></p>

<p>La fonction <code>make_population</code> renvoie une liste de 100 chromosomes.</p>

<p>On peut voir ce que ça donne avec <code>make_population.each {|x| puts x.inspect}</code>:</p>

<pre><code>[nil, "110111010010111000000001011001111000100010101111"]
[nil, "101100010001001000011000111011000001100010000000"]
...
[nil, "111110110011110111111110110000010100100100000100"]
[nil, "000010101001000010011001101010101110011100010010"]
</code></pre>

<p>Maintenant qu'on a créé une population de 100 solutions potentielles, il
faut pouvoir évaluer chaque solution. Pour cela, il faut d'abord être en
mesure de séparer une suite de 48 bits (le chromosome) en 12 parties de
4 bits (les gènes):</p>

<p><code>ruby
def chromosome_to_gene(chromosome)
  chromosome.last.scan /.{4}/
end
</code></p>

<p>La fonction <code>chromosome_to_gene</code> prend en entrée un chromosome (créé avec
<code>make_chromosome</code>) et renvoie une liste des 12 gènes qui le compose.</p>

<p>Pour décrypter l'expression composée par les 12 gènes, il faut tout
d'abord décrypter un seul gène:</p>

<p><code>ruby
def gene_to_operand(gene)
  case gene
  when "0000" then 0
  when "0001" then 1
  when "0010" then 2
  when "0011" then 3
  when "0100" then 4
  when "0101" then 5
  when "0110" then 6
  when "0111" then 7
  when "1000" then 8
  when "1001" then 9
  when "1010" then "+"
  when "1011" then "-"
  when "1100" then "/"
  when "1101" then "%"
  end
end
</code></p>

<p>On peut maintenant decrypter la formule complète (l'expression):</p>

<p><code>ruby
def genes_to_formula(genes)
  formula = []
  genes.each {|gene| formula &lt;&lt; gene_to_operand(gene) }
  formula.join
end
</code></p>

<p><code>genes_to_formula</code> prend en entrée la liste des 12 gènes d'un chromosome
et renvoie l'expression sous la forme d'une chaîne de caractères.</p>

<p>L'évaluation proprement dite se passe ainsi:</p>

<p>``` ruby
def evaluation(genes)
  formula = genes_to_formula(genes)
  begin</p>

<pre><code>result = (@search_value - eval(formula)).abs
</code></pre>

<p>  rescue Exception</p>

<pre><code>result = 999_999_999_999
</code></pre>

<p>  end
  result = 999_999_999_999 unless result.is_a?(Integer)
  result
end
```</p>

<p>Cette fonction mérite quelques d'explications. L'expression (<code>formula</code>)
est évaluée avec <code>eval</code>. En ruby, <code>eval</code> evalue une chaîne de caractères
comme si c'était du code source (comme en Javascript, etc).
On ôte ce résultat de <code>@search_value</code>, qui
contient le nombre qu'on cherche (notre problème) et on garde la valeur
absolue. Ainsi zéro signifie une solution et plus on s'éloigne de zéro,
plus on est loin d'une solution. On pourra donc facilement classer nos
individus. Si <code>eval</code> provoque une exception (à cause d'une formule/expression
incompréhensible), on place une grande valeur
comme résultat puisqu'on est très loin de la solution. On peut voir
le nombre 999.999.999.999 comme étant l'infini. Enfin je regarde si
le résultat de <code>eval</code> est bien un nombre et dans le cas contraire, je
change le résultat pour refleter ce souci. Qu'est ce que ça peut être
d'autre qu'un nombre ? En ruby, une chaîne placée entre <code>/</code> est une
expression régulière. Voilà pour aujourd'hui.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/28/les-algorithmes-genetiques-demystifies/"/>
    <updated>2013-08-28T09:49:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/28/les-algorithmes-genetiques-demystifies</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p><strong>démystifié</strong>:
<blockquote><p>Enlever le caractère mystérieux.</p></blockquote></p>

<p>Un algorithme génétique c'est quoi ? Comment ça marche ? À quoi ça sert ?
Si vous vous posez une de ces questions, cette
nouvelle série d'articles peut vous
intéresser.</p>

<!-- more -->


<h2>Une définition simple</h2>

<p>Tout d'abord, un algorithme génétique est un <em>algorithme</em>. Autrement dit
c'est une suite d'instructions, ou encore une recette, pour résoudre un
problème. C'est peut-être bidon pour certains d'entre vous, mais ça va mieux
en le disant.</p>

<p>Ensuite, pourquoi génétique ? Et bien parce que pour résoudre un problème,
cette catégorie d'algorithmes s'inspire de la biologie, de la génétique,
et notamment du mécanisme de la séléction naturelle et/ou artificielle.</p>

<h2>La démarche</h2>

<p>Pour faire court:</p>

<ol>
<li>On crée une population au hasard. Chaque individu représente une solution
possible au problème posé.</li>
<li>On évalue chaque individu (solution) de la population. En clair, on leur
donne une note.</li>
<li>On selectionne certains individus parmi les plus adaptés.</li>
<li>Les individus (solutions) sélectionnés se reproduisent pour donner
naissance à la nouvelle génération, qui est globalement plus adaptée.</li>
<li>On recommence au point 2 jusqu'à ce qu'on trouve la solution du
problème.</li>
</ol>


<h2>Les domaines d'application</h2>

<p>Tous, ou presque. Trouver le meilleur profil pour une hélice de bateau ou
une aile d'avion, apprendre à marcher à un robot, adapter le comportement
d'un personnage dans un jeu vidéo, maximiser l'exploitation du volume
d'un hangar, etc. Comme chaque nouvelle génération produit globalement
une meilleure solution, les algorithmes génétiques peuvent être très
intéressants lorsqu'on veut obtenir une <em>bonne</em> solution rapidement (et
pas forcement la <em>meilleure</em> solution).</p>

<p>Dans mes prochains articles, je parlerais plus en détails de ces
algorithmes et je montrerais notamment comment les coder.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un langage sur Parrot - partie 11: Arbre syntaxique abstrait]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/26/un-langage-sur-parrot-partie-11-arbre-syntaxique-abstrait/"/>
    <updated>2013-08-26T08:48:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/26/un-langage-sur-parrot-partie-11-arbre-syntaxique-abstrait</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Dans le dernier épisode, je me suis rendu compte que j'aurais intéret
à utiliser un arbre syntaxique abstrait pour mon petit langage. En
voici une première implémentation.</p>

<!-- more -->


<p>Un arbre syntaxique abstrait (<em>Abstract Syntax Tree</em> en anglais, ou AST)
est avant tout une manière de structurer des données:</p>

<pre><code>    A
   / \
  B   C
 / \   \
D   E   F
   /
  G
</code></pre>

<p>On part d'un noeud racine (ici <code>A</code>) et on ajoute des branches qui mènent à
d'autres noeuds. On peut distinguer les noeuds terminaux (<code>D</code>, <code>F</code> et <code>G</code>) des
noeuds non-terminaux.
Les noeuds terminaux, aussi appelés feuilles, contiennent une valeur. Les noeuds
non-terminaux contiennent d'autres noeuds.
C'est une manière pratique de représenter un code source,
l'AST étant (assez) facilement manipulable. Il est dit abstrait dans le sens
où il ne contient pas chaque éléments du langage source. Par exemple, les
parenthèses, les virgules, ou encore les débuts et fins de blocs sont
souvent absents de l'AST. Si vous voulez en savoir plus sur les AST:
<a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree">http://en.wikipedia.org/wiki/Abstract_syntax_tree</a>.</p>

<p>Le code qui suit est sur <a href="https://github.com/lkdjiin/naam">Github</a>,
à la version 0.0.5.</p>

<p>L'objectif est de créer l'AST et de le visualiser ainsi:</p>

<pre><code>program
  function definition
    header
      name ::= sign
      argument ::= n
    if clause
      return value ::= 1
      test
        left value ::= n
        operator value ::= &gt;
        right value ::= 0
    if clause
      return value ::= -1
      test
        left value ::= n
        operator value ::= &lt;
        right value ::= 0
    else clause
      return value ::= 0
  print statement ::= sign(4)
</code></pre>

<p>Voici la classe de base de l'AST:</p>

<p>``` ruby
module Naam::AST
  class Node</p>

<pre><code>def initialize name
  @name = name
  @children = []
end

attr_reader :children, :name

def add_child child; @children &lt;&lt; child; end

def leaf?; @children.empty?; end

def display(indent = 0)
  print " " * indent + @name
  print " ::= #{@value}" if leaf?
  puts
  @children.each {|child| child.display(indent + 2) }
end
</code></pre>

<p>  end
end
```</p>

<p>Elle permet entre autres d'ajouter un noeud enfant avec <code>add_child</code> et de
déterminer si un noeud est une feuille avec <code>leaf?</code>. La méthode <code>display</code>,
appliquée sur le noeud racine permettra d'afficher l'arbre complet.</p>

<p>Un noeud non-terminal ressemblera à ça:</p>

<p>``` ruby
module Naam::AST
  class Program &lt; Node</p>

<pre><code>def initialize
  super("program")
end
</code></pre>

<p>  end
end
```</p>

<p>Pour un noeud terminal (une feuille), on ajoutera simplement une valeur:</p>

<p>``` ruby
module Naam::AST
  class Argument &lt; Node</p>

<pre><code>def initialize value
  super("argument")
  @value = value
end
</code></pre>

<p>  end
end
```</p>

<p>Comment appliquer tout ça ? Directement dans le <em>syntaxer</em>. En voici
quelques extraits:</p>

<p>``` ruby
module Naam::Parser
  class Syntaxer</p>

<pre><code>def initialize
  # ...
  @ast = Naam::AST::Program.new
end

# ...

def function_def
  node = Naam::AST::FunctionDef.new
  @ast.add_child node
  function_header(node)
  if_clause(node) while if_clause?
  else_clause(node)
end

def function_header(node)
  @series = []
  accept_series(:word, :paro, :word, :parc, :affect, :eol)
  f_header = Naam::AST::FunctionHeader.new
  f_header.add_child(Naam::AST::Name.new(@series[0].value))
  f_header.add_child(Naam::AST::Arg.new(@series[2].value))
  node.add_child(f_header)
end

# ...
</code></pre>

<p>  end
end
```</p>

<p>L'AST va me permettre de faire un truc plus propre (même si cette classe
<code>Syntaxer</code> demande toujours un gros <em>refactoring</em>) et de manipuler plus
aisement le code source.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Implémenter un langage sur Parrot - partie 10: émettre le code assembleur]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/20/implementer-un-langage-sur-parrot-partie-10-emettre-le-code-assembleur/"/>
    <updated>2013-08-20T10:01:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/20/implementer-un-langage-sur-parrot-partie-10-emettre-le-code-assembleur</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Maintenant qu'on a
<a href="http://lkdjiin.github.io/blog/2013/08/18/implementer-un-langage-sur-parrot-partie-9-la-syntaxe/">vérifié la syntaxe</a>
de notre petit programme, on peut sortir le code assembleur PIR:</p>

<p><code>ruby lib/naam/main.rb
def self.run(filename)
  # ...
  comp = Compiler.new
  comp.compile(units.dup)
end
</code></p>

<!-- more -->


<p>Voici le module Emitter:</p>

<p>``` ruby lib/naam/emitter.rb
module Naam
  module Emitter</p>

<pre><code># Output the main procedure.
#
# series - An Array of String.
#
# Examples
#
#   Emitter.main(["foo(4)", "bar(-1)"]
#   # =&gt; .sub main :main
#   # =&gt;     .local int f
#   # =&gt;     f = foo(4)
#   # =&gt;     say f
#   # =&gt;     f = bar(-1)
#   # =&gt;     say f
#   # =&gt; .end
#
# Returns nothing.
def self.main(series)
  unless series.empty?
    puts
    puts ".sub main :main"
    puts "    .local int f"
    series.each do |str|
      puts "    f = #{str}"
      puts "    say f"
    end
    puts ".end"
  end
end

# Dispatch different kind of emit message.
#
# type   - A Symbol in :function_header, :function_footer,
#          :if_clause, :else_clause and :label.
# series - An Array of LexicalUnit.
# label  - Hash like { label: "NAME", value: "123" }. Could be nil.
#
# Returns nothing.
def self.emit(type, series, label)
  case type
  when :function_header then function_header(series)
  when :function_footer then function_footer
  when :if_clause then if_clause(series, label)
  when :else_clause then else_clause(series)
  when :label then label(series, label)
  else
    raise Error
  end
end

def self.function_header(series)
  puts ".sub " + series[0].value
  puts "    .param int " + series[2].value
  puts "    .local int result"
  puts
end

def self.function_footer
  puts "RETURN:"
  puts "    .return(result)"
  puts ".end"
end

def self.if_clause(series, label)
  puts "    if #{series[2].value} #{series[3].value} #{series[4].value} " +
       "goto #{label[:label]}"
end

def self.else_clause(series)
  puts "    result = #{series[0].value}"
  puts "    goto RETURN"
end

def self.label(series, label)
  puts label[:label] + ":"
  puts "    result = #{label[:value]}"
  puts "    goto RETURN"
end
</code></pre>

<p>  end
end
```</p>

<p>Et voilà quelques morceaux choisis dans la class Compiler pour montrer
son utilisation:</p>

<p>``` ruby lib/naam/compiler.rb
module Naam</p>

<p>  # Public: Here we transform a list of lexical units in a PIR source
  # code. At least this is the goal.
  #
  # The logic of this class try follow the grammar of Naam (see the file
  # grammar.md).
  class Compiler</p>

<pre><code>def initialize
  @series = []
  @current_label = "LABEL0000"
  @labels = []
  @main = []
end

# Public: Compile lexical units from a Naam program in a PIR
# program.
#
# units - Array of LexicalUnits
#
# Returns nothing.
def compile units
  @units = units
  program
end

private

# This is the entry rule.
#
# Returns nothing.
def program
  while @units.size &gt; 0
    @series = []
    case @units.first.type
    when :eol then accept(:eol)
    else
      instruction
    end
  end
  @labels.each {|lbl| emit(:label, lbl) }
  emit(:function_footer)
  Emitter.main(@main)
end

# ...

# Returns nothing.
def function_def
  accept_series(:word, :paro, :word, :parc, :affect, :eol)
  emit(:function_header)
  if_clause while if_clause?
  else_clause
end

# ...

# Send a message to Emitter module.
#
# type  - A Symbol (see Emitter).
# label - A Hash composed of:
#         :label - The label name as a String.
#         :value - The String value that will be returned by
#                  PIR instructions for this label.
#         By default, label is nil and unused.
#
# Returns nothing.
def emit(type, label = nil)
  Emitter.emit(type, @series, label)
  @series = []
end

# Get a label.
#
# value - String value associated to the label.
#
# Examples
#
#   next_label("123")
#   # =&gt; { label: "LABEL0000", value: "123" }
#   next_label("-9")
#   # =&gt; { label: "LABEL0001", value: "-9" }
#
# Returns the Hash label.
def next_label(value)
  temp = { label: @current_label, value: value }
  @labels &lt;&lt; temp
  @current_label = @current_label.next
  temp
end
</code></pre>

<p>  end
end
```</p>

<p>Maintenant que je le montre, je me rends compte que ce code n'est pas
terrible. Bien que le fichier source à compiler soit extremement simple,
je suis déjà obligé de faire un tas de contorsions, notamment pour sortir
la procédure main. Je pensais que c'était une bonne idée de méler
vérification de la syntaxe et production du code assembleur pour montrer
les relations entre ces deux phases, mais visiblement ça n'aide pas
à la clarté du code. La meilleure solution pour m'en sortir est, je pense,
de me servir d'un AST (Arbre syntaxique abstrait). La prochaine fois je
parlerais donc de l'AST.</p>

<p>À demain.</p>

<p></p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Implémenter un langage sur Parrot - partie 9: la syntaxe]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/18/implementer-un-langage-sur-parrot-partie-9-la-syntaxe/"/>
    <updated>2013-08-18T08:01:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/18/implementer-un-langage-sur-parrot-partie-9-la-syntaxe</id>
    <content type="html"><![CDATA[<p>Après avoir écrit un
<a href="http://lkdjiin.github.io/blog/2013/08/12/parrot-6-ecrire-le-tokenizer/">tokenizer</a>,
avoir produit les <a href="http://lkdjiin.github.io/blog/2013/08/13/implementer-un-langage-sur-parrot-partie-7-le-lexer/">unités lexicales</a>
et avoir défini
<a href="http://lkdjiin.github.io/blog/2013/08/17/implementer-un-langage-sur-parrot-partie-8-la-grammaire/">une grammaire</a>
pour le langage Naam, je passe maintenant à la vérification de la syntaxe.</p>

<!-- more -->


<p>La vérification de la syntaxe se passe dans la classe <code>Compiler</code>. <em>&ndash; C'est pas
le meilleur choix de nom et ça changera par la suite &ndash;</em>. Basiquement, cette
classe ne fait que suivre la logique de la grammaire.</p>

<p>``` ruby lib/naam/compiler.rb
class Compiler</p>

<p>  # units &ndash; Array of LexicalUnits
  def compile units</p>

<pre><code>@units = units
program
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def program</p>

<pre><code>while @units.size &gt; 0
  case @units.first.type
  when :eol then accept(:eol)
  else
    instruction
  end
end
</code></pre>

<p>  end</p>

<p>  def instruction</p>

<pre><code>case @units.first.type
when :keyword then print_statement
when :word then function_def
else
  raise Error
end
</code></pre>

<p>  end</p>

<p>  def print_statement</p>

<pre><code>accept(:keyword, 'print')
accept_series(:word, :paro, :int, :parc, :eol)
</code></pre>

<p>  end</p>

<p>  def function_def</p>

<pre><code>accept_series(:word, :paro, :word, :parc, :affect, :eol)
if_clause while if_clause?
else_clause
</code></pre>

<p>  end</p>

<p>  def if_clause</p>

<pre><code>accept(:int)
accept(:keyword, 'if')
test
accept(:eol)
</code></pre>

<p>  end</p>

<p>  def else_clause</p>

<pre><code>accept(:int)
accept(:keyword, 'else')
accept(:eol)
</code></pre>

<p>  end</p>

<p>  def test</p>

<pre><code>accept_series(:word, :op, :int)
</code></pre>

<p>  end</p>

<p>  def accept(type, value = &lsquo;&rsquo;)</p>

<pre><code>unit = @units.slice!(0)
raise Error unless unit.type == type
if value != ''
  raise Error unless unit.value == value
end
</code></pre>

<p>  end</p>

<p>  def accept_series(*args)</p>

<pre><code>args.each {|arg| accept(arg) }
</code></pre>

<p>  end</p>

<p>  def if_clause?</p>

<pre><code>@units[1].type == :keyword &amp;&amp; @units[1].value == 'if'
</code></pre>

<p>  end
end
```</p>

<p>Quelques commentaires sur ce code:</p>

<p>``` ruby
def instruction
  # &hellip;
  else</p>

<pre><code>raise Error
</code></pre>

<p>  end
end
```</p>

<p>Plusieurs fois j'utilise la classe <code>Error</code>, qui n'existe pas. C'est parce que
je ne veux pas encore réfléchir à la gestion des erreurs. Les seuls cas qui
m'intéressent pour l'instant sont ceux où ça fonctionne.</p>

<p>`&ldquo; ruby
def accept(type, value = &rdquo;)
  unit = @units.slice!(0)
  raise Error unless unit.type == type
  if value != &lsquo;&rsquo;</p>

<pre><code>raise Error unless unit.value == value
</code></pre>

<p>  end
end
```</p>

<p>C'est la méthode <code>accept</code>, toute simple, qui effectue la vérification
de la syntaxe en comparant l'unité lexicale attendue avec celle réellement
disponible. On constate que les unités lexicales (représentées par <code>@units</code>)
sont détruites au fur et à mesure de leur consommation.</p>

<p>La prochaine, il sera enfin temps d'émettre le code PIR.</p>

<p>À demain.
</p>
]]></content>
  </entry>
  
</feed>
