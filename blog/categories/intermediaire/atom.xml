<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : intermédiaire | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/intermediaire/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-08-22T16:22:27+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Implémenter un langage sur Parrot - partie 10: émettre le code assembleur]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/20/implementer-un-langage-sur-parrot-partie-10-emettre-le-code-assembleur/"/>
    <updated>2013-08-20T10:01:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/20/implementer-un-langage-sur-parrot-partie-10-emettre-le-code-assembleur</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Maintenant qu'on a
<a href="http://lkdjiin.github.io/blog/2013/08/18/implementer-un-langage-sur-parrot-partie-9-la-syntaxe/">vérifié la syntaxe</a>
de notre petit programme, on peut sortir le code assembleur PIR:</p>

<p><code>ruby lib/naam/main.rb
def self.run(filename)
  # ...
  comp = Compiler.new
  comp.compile(units.dup)
end
</code></p>

<!-- more -->


<p>Voici le module Emitter:</p>

<p>``` ruby lib/naam/emitter.rb
module Naam
  module Emitter</p>

<pre><code># Output the main procedure.
#
# series - An Array of String.
#
# Examples
#
#   Emitter.main(["foo(4)", "bar(-1)"]
#   # =&gt; .sub main :main
#   # =&gt;     .local int f
#   # =&gt;     f = foo(4)
#   # =&gt;     say f
#   # =&gt;     f = bar(-1)
#   # =&gt;     say f
#   # =&gt; .end
#
# Returns nothing.
def self.main(series)
  unless series.empty?
    puts
    puts ".sub main :main"
    puts "    .local int f"
    series.each do |str|
      puts "    f = #{str}"
      puts "    say f"
    end
    puts ".end"
  end
end

# Dispatch different kind of emit message.
#
# type   - A Symbol in :function_header, :function_footer,
#          :if_clause, :else_clause and :label.
# series - An Array of LexicalUnit.
# label  - Hash like { label: "NAME", value: "123" }. Could be nil.
#
# Returns nothing.
def self.emit(type, series, label)
  case type
  when :function_header then function_header(series)
  when :function_footer then function_footer
  when :if_clause then if_clause(series, label)
  when :else_clause then else_clause(series)
  when :label then label(series, label)
  else
    raise Error
  end
end

def self.function_header(series)
  puts ".sub " + series[0].value
  puts "    .param int " + series[2].value
  puts "    .local int result"
  puts
end

def self.function_footer
  puts "RETURN:"
  puts "    .return(result)"
  puts ".end"
end

def self.if_clause(series, label)
  puts "    if #{series[2].value} #{series[3].value} #{series[4].value} " +
       "goto #{label[:label]}"
end

def self.else_clause(series)
  puts "    result = #{series[0].value}"
  puts "    goto RETURN"
end

def self.label(series, label)
  puts label[:label] + ":"
  puts "    result = #{label[:value]}"
  puts "    goto RETURN"
end
</code></pre>

<p>  end
end
```</p>

<p>Et voilà quelques morceaux choisis dans la class Compiler pour montrer
son utilisation:</p>

<p>``` ruby lib/naam/compiler.rb
module Naam</p>

<p>  # Public: Here we transform a list of lexical units in a PIR source
  # code. At least this is the goal.
  #
  # The logic of this class try follow the grammar of Naam (see the file
  # grammar.md).
  class Compiler</p>

<pre><code>def initialize
  @series = []
  @current_label = "LABEL0000"
  @labels = []
  @main = []
end

# Public: Compile lexical units from a Naam program in a PIR
# program.
#
# units - Array of LexicalUnits
#
# Returns nothing.
def compile units
  @units = units
  program
end

private

# This is the entry rule.
#
# Returns nothing.
def program
  while @units.size &gt; 0
    @series = []
    case @units.first.type
    when :eol then accept(:eol)
    else
      instruction
    end
  end
  @labels.each {|lbl| emit(:label, lbl) }
  emit(:function_footer)
  Emitter.main(@main)
end

# ...

# Returns nothing.
def function_def
  accept_series(:word, :paro, :word, :parc, :affect, :eol)
  emit(:function_header)
  if_clause while if_clause?
  else_clause
end

# ...

# Send a message to Emitter module.
#
# type  - A Symbol (see Emitter).
# label - A Hash composed of:
#         :label - The label name as a String.
#         :value - The String value that will be returned by
#                  PIR instructions for this label.
#         By default, label is nil and unused.
#
# Returns nothing.
def emit(type, label = nil)
  Emitter.emit(type, @series, label)
  @series = []
end

# Get a label.
#
# value - String value associated to the label.
#
# Examples
#
#   next_label("123")
#   # =&gt; { label: "LABEL0000", value: "123" }
#   next_label("-9")
#   # =&gt; { label: "LABEL0001", value: "-9" }
#
# Returns the Hash label.
def next_label(value)
  temp = { label: @current_label, value: value }
  @labels &lt;&lt; temp
  @current_label = @current_label.next
  temp
end
</code></pre>

<p>  end
end
```</p>

<p>Maintenant que je le montre, je me rends compte que ce code n'est pas
terrible. Bien que le fichier source à compiler soit extremement simple,
je suis déjà obligé de faire un tas de contorsions, notamment pour sortir
la procédure main. Je pensais que c'était une bonne idée de méler
vérification de la syntaxe et production du code assembleur pour montrer
les relations entre ces deux phases, mais visiblement ça n'aide pas
à la clarté du code. La meilleure solution pour m'en sortir est, je pense,
de me servir d'un AST (Arbre syntaxique abstrait). La prochaine fois je
parlerais donc de l'AST.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Implémenter un langage sur Parrot - partie 9: la syntaxe]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/18/implementer-un-langage-sur-parrot-partie-9-la-syntaxe/"/>
    <updated>2013-08-18T08:01:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/18/implementer-un-langage-sur-parrot-partie-9-la-syntaxe</id>
    <content type="html"><![CDATA[<p>Après avoir écrit un
<a href="http://lkdjiin.github.io/blog/2013/08/12/parrot-6-ecrire-le-tokenizer/">tokenizer</a>,
avoir produit les <a href="http://lkdjiin.github.io/blog/2013/08/13/implementer-un-langage-sur-parrot-partie-7-le-lexer/">unités lexicales</a>
et avoir défini
<a href="http://lkdjiin.github.io/blog/2013/08/17/implementer-un-langage-sur-parrot-partie-8-la-grammaire/">une grammaire</a>
pour le langage Naam, je passe maintenant à la vérification de la syntaxe.</p>

<!-- more -->


<p>La vérification de la syntaxe se passe dans la classe <code>Compiler</code>. <em>&ndash; C'est pas
le meilleur choix de nom et ça changera par la suite &ndash;</em>. Basiquement, cette
classe ne fait que suivre la logique de la grammaire.</p>

<p>``` ruby lib/naam/compiler.rb
class Compiler</p>

<p>  # units &ndash; Array of LexicalUnits
  def compile units</p>

<pre><code>@units = units
program
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def program</p>

<pre><code>while @units.size &gt; 0
  case @units.first.type
  when :eol then accept(:eol)
  else
    instruction
  end
end
</code></pre>

<p>  end</p>

<p>  def instruction</p>

<pre><code>case @units.first.type
when :keyword then print_statement
when :word then function_def
else
  raise Error
end
</code></pre>

<p>  end</p>

<p>  def print_statement</p>

<pre><code>accept(:keyword, 'print')
accept_series(:word, :paro, :int, :parc, :eol)
</code></pre>

<p>  end</p>

<p>  def function_def</p>

<pre><code>accept_series(:word, :paro, :word, :parc, :affect, :eol)
if_clause while if_clause?
else_clause
</code></pre>

<p>  end</p>

<p>  def if_clause</p>

<pre><code>accept(:int)
accept(:keyword, 'if')
test
accept(:eol)
</code></pre>

<p>  end</p>

<p>  def else_clause</p>

<pre><code>accept(:int)
accept(:keyword, 'else')
accept(:eol)
</code></pre>

<p>  end</p>

<p>  def test</p>

<pre><code>accept_series(:word, :op, :int)
</code></pre>

<p>  end</p>

<p>  def accept(type, value = &lsquo;&rsquo;)</p>

<pre><code>unit = @units.slice!(0)
raise Error unless unit.type == type
if value != ''
  raise Error unless unit.value == value
end
</code></pre>

<p>  end</p>

<p>  def accept_series(*args)</p>

<pre><code>args.each {|arg| accept(arg) }
</code></pre>

<p>  end</p>

<p>  def if_clause?</p>

<pre><code>@units[1].type == :keyword &amp;&amp; @units[1].value == 'if'
</code></pre>

<p>  end
end
```</p>

<p>Quelques commentaires sur ce code:</p>

<p>``` ruby
def instruction
  # &hellip;
  else</p>

<pre><code>raise Error
</code></pre>

<p>  end
end
```</p>

<p>Plusieurs fois j'utilise la classe <code>Error</code>, qui n'existe pas. C'est parce que
je ne veux pas encore réfléchir à la gestion des erreurs. Les seuls cas qui
m'intéressent pour l'instant sont ceux où ça fonctionne.</p>

<p>`&ldquo; ruby
def accept(type, value = &rdquo;)
  unit = @units.slice!(0)
  raise Error unless unit.type == type
  if value != &lsquo;&rsquo;</p>

<pre><code>raise Error unless unit.value == value
</code></pre>

<p>  end
end
```</p>

<p>C'est la méthode <code>accept</code>, toute simple, qui effectue la vérification
de la syntaxe en comparant l'unité lexicale attendue avec celle réellement
disponible. On constate que les unités lexicales (représentées par <code>@units</code>)
sont détruites au fur et à mesure de leur consommation.</p>

<p>La prochaine, il sera enfin temps d'émettre le code PIR.</p>

<p>À demain.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Implémenter un langage sur Parrot - partie 8: la grammaire]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/17/implementer-un-langage-sur-parrot-partie-8-la-grammaire/"/>
    <updated>2013-08-17T09:29:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/17/implementer-un-langage-sur-parrot-partie-8-la-grammaire</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Écrire un langage sans en spécificier la grammaire c'est un peu comme se
tirer une balle dans le pied. Même quand le langage est aussi simple et
petit que
Naam (voir l'<a href="http://lkdjiin.github.io/blog/2013/08/01/implementer-un-langage-sur-la-machine-virtuelle-parrot-partie-1/">article originel</a>),
c'est un gain de temps pour la suite.</p>

<!-- more -->


<p>Pour spécificier la grammaire d'un langage informatique, on utilise
généralement la
<a href="http://fr.wikipedia.org/wiki/Forme_de_Backus-Naur">BNF</a>,
(Backus Naur Form) ou l'une de ses extensions. Il n'est pas rare qu'un auteur
utilise une version personnalisée de la BNF, et c'est ce que je vais faire
pour Naam.</p>

<p>Voici les quelques règles de la méta-syntaxe:</p>

<pre><code>{foo}         zero or more foo
foo | bar     foo or bar
foo           a non-terminal foo
'foo'         keyword foo
[foo]         zero or one foo
---           free speech
</code></pre>

<p>Et voici la grammaire de Naam:</p>

<pre><code>program           ::= {instruction | eol}

instruction       ::= function_def | print_statement

print_statement   ::= 'print' word ( int ) eol

function_def      ::= word ( word ) = eol {if_clause} else_clause

if_clause         ::= int 'if' test eol

test              ::= word op int

else_clause       ::= int 'else' eol

op                ::= &lt; | &gt;

eol               ::= --- End of line
int               ::= --- Integer
word              ::= --- Anything else
</code></pre>

<p>Cette grammaire est vraiment toute petite, mais suffisante pour spécifier
le programme suivant, qui est ce que j'ai choisi pour commencer à écrire
le compilateur Naam:</p>

<pre><code>sign(n)=
1 if n &gt; 0
-1 if n &lt; 0
0 else
</code></pre>

<p>Alors pourquoi écrire une grammaire ? Pourquoi ne pas commencer à coder
directement le compilateur ? Parce qu'il faut bien avouer qu'écrire une
telle grammaire n'a rien d'amusant. Tout d'abord une grammaire, même petite,
possède toujours un certain niveau de complexité qu'il est difficile de
faire tenir entièrement dans sa tête. En l'écrivant on met à jour certains
problèmes qui sinon resteraient cachés longtemps. Autre intéret d'écrire la
grammaire: chaque règle va devenir un morceau de code ; écrire la grammaire
c'est un peu comme avoir déjà écrit une partie du compilateur.
Dans un prochain article je suivrais cette grammaire pour effectuer la
vérification de la syntaxe.</p>

<p>À demain.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Une définition de la programmation fonctionnelle avec Elixir]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/16/une-definition-de-la-programmation-fonctionnelle-avec-elixir/"/>
    <updated>2013-08-16T09:17:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/16/une-definition-de-la-programmation-fonctionnelle-avec-elixir</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<h2>Ou ma tentative désespérée de comprendre la non mutabilité</h2>

<p>Cet article est un article égoiste ! Depuis que je joue un peu avec Elixir, je
m'aperçois que j'ai des soucis à comprendre <em>vraiment</em> la programmation
fonctionnelle.
J'ai entre autres, des difficultés à me faire au coté immuable, non-mutable,
de la chose (<em>immutable</em> en anglais). Je tente donc aujourd'hui de
mettre au clair mes idées sur la question. Ce qui suit peut ressembler
à un dialogue de fou, vous êtes prévenus.</p>

<!-- more -->


<p>Revoici le module Somme, que j'ai utilisé dans un <a href="http://lkdjiin.github.io/blog/2013/07/24/elixir-calculer-la-somme-des-n-premiers-entiers-suite-et-fin/">précédent article</a>.</p>

<p><code>elixir somme.exs
defmodule Somme do
  def run(0, acc), do: acc
  def run(n, acc), do: run(n - 1, n + acc)
end
IO.puts Somme.run(5, 0)
</code></p>

<p>Je vais l'écrire dans un bon vieux langage procédural, et analyser ce qu'il
s'y passe.</p>

<p>``` c somme.c</p>

<h1>include&lt;stdio.h></h1>

<p>int main(void)
{</p>

<pre><code>int somme = 0;
for(int n = 5 ; n &gt; 0 ; n--) {
    somme += n;
} 
printf("%i\n", somme);
return 0;
</code></pre>

<p>}
```</p>

<p>On compile et on lance:</p>

<pre><code>$ gcc somme.c -std=c99
$ ./a.out 
15
</code></pre>

<p>Ici pas de récursivité mais une simple itération. Une boucle qui change la
variable <code>somme</code> à chaque passage. Je crois qu'on devrait d'abord définir
ce qu'est une variable. Une variable, c'est un concept. Une variable définit
à la fois un contenant, un contenu et un type, tout cela accessible par un
nom. Notre variable a ici pour nom <code>somme</code>. Son type est <code>int</code>. Son contenu,
ou encore sa valeur est initialement 0 et change à chaque itération. Son
contenant est un emplacement en mémoire, qui lui ne change pas. «<em>Et tu sais ça
comment que ça change pas ?</em>» Bon, puisque j'ai besoin d'une preuve,
j'ajoute un traceur qui affiche l'emplacement mémoire de <code>somme</code>:</p>

<p>``` c</p>

<h1>include&lt;stdio.h></h1>

<p>int main(void)
{</p>

<pre><code>int somme = 0;
printf("%d\n", &amp;somme);
for(int n = 5 ; n &gt; 0 ; n--) {
    somme += n;
    printf("%d\n", &amp;somme);
} 
printf("%i\n", somme);
return 0;
</code></pre>

<p>}
```</p>

<pre><code>$ gcc somme.c -std=c99
$ ./a.out 
-1081032008
-1081032008
-1081032008
-1081032008
-1081032008
-1081032008
15
</code></pre>

<p>Voilà, on le sait maintenant: la <em>valeur</em> de <code>somme</code> change, mais son
<em>emplacement</em> (son contenant) reste identique.</p>

<p>Si je tente maintenant de mimer ce comportement avec Elixir, je serais tenté
d'écrire:</p>

<p><code>elixir
somme = 0
Enum.each 5..1, fn n -&gt;
  somme = somme + n
end
IO.puts somme
</code></p>

<pre><code>$ elixir somme.exs 
/home/xavier/somme.exs:3: variable somme is unused
0
</code></pre>

<p>Comme Elixir est sympa, il tente de me prévenir que quelque chose ne
tourne pas rond. On peut penser à un problème de <em>scope</em>, se dire que le
<code>somme</code> à l'intérieur de la fonction anonyme n'est pas le même que le
<code>somme</code> à l'extérieur de cette fonction. Mais c'est pas ça. Ou
plus exactement ce n'est pas <em>seulement</em> ça:</p>

<p><code>elixir
somme = 100
Enum.each 5..1, fn n -&gt;
  somme = somme + n
  IO.puts somme
end
IO.puts somme
</code></p>

<pre><code>$ elixir somme.exs 
105
104
103
102
101
100
</code></pre>

<p>La valeur du <code>somme</code> de l'intérieur est initialisée à chaque
itération par la valeur du <code>somme</code> de l'extérieur.
Donc le <code>somme</code> extérieur est connu dans la fonction anonyme.
Ce comportement me
fais m'arracher les cheveux, je sens que je passe complètement à coté
d'un truc essentiel. Je sais qu'on n'écrirait pas cette fonction de
cette manière, mais je veux comprendre <em>pourquoi</em> ce comportement
quand je fais ça. En fait donner le même nom à ces deux variables est
une illusion.
Pour Elixir le contenu de <code>somme</code> est immuable, il ne peut pas changer.
Il serait donc plus juste d'écrire ça:</p>

<p><code>elixir
somme = 0
Enum.each 5..1, fn n -&gt;
  temp = somme + n
end
IO.puts somme
</code></p>

<p>Ce qui, évidemment, ne mène à rien. Je commence peut-être à comprendre.
Si je reprend le programme du départ:</p>

<p><code>elixir somme.exs
defmodule Somme do
  def run(0, acc), do: acc
  def run(n, acc), do: run(n - 1, n + acc)
end
IO.puts Somme.run(5, 0)
</code></p>

<p>On voit bien que les variables ne changent (ne mutent) jamais. Ce sont à
chaque fois de <em>nouvelle création</em> qui sont passées dans les paramètres.</p>

<p><code>elixir
def run(n, acc), do: run(n - 1, n + acc)
</code></p>

<p>Lors d'un passage précis dans cette fonction, on se fiche royalement de savoir
quel était l'état de <code>n</code> et de <code>acc</code> lors des passages précédents. Ce qui
n'est pas le cas dans l'exemple en C:</p>

<p>``` c
for(int n = 5 ; n > 0 ; n&mdash;) {</p>

<pre><code>somme += n;
</code></pre>

<p>}
```</p>

<p>À chaque passage dans la boucle, il faut connaître l'état de <code>somme</code> dans
l'itération précédente.</p>

<p>On m'avait pourtant bien dit que la programmation fonctionnelle s'occupait
des <em>transformations</em> et pas des <em>états</em>. Mais je ne voyais pas du tout
ce que ça pouvait bien signifier. C'est maintenant un peu plus clair,
même s'il me reste encore du chemin à parcourir pour bien saisir tout
ce qu'implique la programmation fonctionnelle…</p>

<p>À demain.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Écrire un DSL en Ruby facilement avec Docile]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/14/ecrire-un-dsl-en-ruby-facilement-avec-docile/"/>
    <updated>2013-08-14T10:41:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/14/ecrire-un-dsl-en-ruby-facilement-avec-docile</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Je suis en train de lire «<a href="http://www.wolframscience.com/">A new kind of science</a>» de Stephen Wolfram
et ça me donne envie de me replonger dans les <a href="https://fr.wikipedia.org/wiki/Automate_cellulaire">automates cellulaires</a>.
Le jeu de la vie est sûrement le programme que j'ai écrit le plus souvent,
mais curieusement jamais en Ruby.</p>

<!-- more -->


<p>J'ai commencé à écrire un
<a href="https://github.com/lkdjiin/cellula">framework pour automate cellulaire</a>,
qui n'aboutira peut-être pas faute de temps. Quoiqu'il en soit, je voudrais
que ce framework soit utilisable par des non-développeurs, d'où le recours
à un DSL (Domain Specific Language). Et pour développer mon DSL, je n'ai
pas trouver plus simple que la gem
<a href="https://github.com/ms-ati/docile">docile</a>.</p>

<p>Voici le DSL que je voudrais:</p>

<p><code>ruby my_automaton.rb
automaton "Test Automaton" do
  dimensions       2
  type             :elementary
  width            100
  height           100
  rule             :b36s26
  pattern          :random
  live_probability 0.1789
end
</code></p>

<p>Docile encourage l'utilisation du design pattern builder. Alors allons-y
pour une classe builder qui va contenir les valeurs par défaut de notre
futur Automaton:</p>

<p>``` ruby automaton_builder.rb
class AutomatonBuilder
  def initialize(name)</p>

<pre><code>@name = name
@dimensions = 2
@type = :elementary
@width = 0
@height = 0
@rule = :b3s23
@pattern = :random
@live_probability = 0.5
</code></pre>

<p>  end</p>

<p>  def dimensions(val); @dimensions = val; self; end
  def type(val); @type = val; self; end
  def width(val); @width = val; self; end
  def height(val); @height = val; self; end
  def rule(val); @rule = val; self; end
  def pattern(val); @pattern = val; self; end
  def live_probability(val); @live_probability = val; self; end</p>

<p>  def build</p>

<pre><code>Automaton.new(@name, @dimensions, @type, @width, @height,
              @rule, @pattern, @live_probability)
</code></pre>

<p>  end
end
```</p>

<p>Il nous faut maintenant une classe Automaton:</p>

<p>``` ruby automaton.rb
class Automaton
  def initialize(name, dimensions, type, width, height, rule,</p>

<pre><code>            pattern, live_probability)
@name = name
@dimensions = dimensions
@type = type
@width = width
@height = height
@rule = rule
@pattern = pattern
@live_probability = live_probability
</code></pre>

<p>  end</p>

<p>  def run</p>

<pre><code>puts "#{@name} running"
</code></pre>

<p>  end
end
```</p>

<p>Et pour finir, on demande à Docile d'évaluer notre DSL puis on charge le
fichier <code>my_automaton.rb</code>. Il ne reste plus qu'à lancer la machine:</p>

<p>``` ruby main.rb
require &lsquo;docile&rsquo;
require &lsquo;./automaton_builder&rsquo;
require &lsquo;./automaton&rsquo;</p>

<p>def automaton(name, &amp;block)
  @auto = Docile.dsl_eval(AutomatonBuilder.new(name), &amp;block).build
end</p>

<p>load ARGV[0]</p>

<p>@auto.run
```</p>

<p>La boucle est bouclée. Vous remarquerez que la méthode <code>automaton</code> définie
dans <code>main.rb</code> ci-dessus est celle qui est utilisée dans le DSL
(<code>my_automaton.rb</code>).</p>

<pre><code>$ ruby ./main.rb my_automaton.rb 
Test Automaton running
</code></pre>

<p>Et voilà. C'est presque trop facile d'écrire un DSL avec Docile…</p>

<p>À demain.</p>
]]></content>
  </entry>
  
</feed>
