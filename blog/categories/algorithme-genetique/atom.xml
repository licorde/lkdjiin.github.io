<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : algorithme génétique | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/algorithme-genetique/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-09-13T09:50:26+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 13]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/13/les-algorithmes-genetiques-demystifies-13/"/>
    <updated>2013-09-13T07:45:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/13/les-algorithmes-genetiques-demystifies-13</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Aujourd'hui on analyse ce qui arrive lorsqu'on joue avec les deux
variables dont on dispose pour l'instant : la taille de la population
et le taux de mutation.</p>

<!-- more -->


<h2>Une définition de la performance</h2>

<p>Comment mesurer les performances d'un algorithme génétique ? Le nombre de
générations nécessaires pour trouver la solution vient tout de suite à
l'esprit. C'est toujours une mesure intéressante mais la plus importante
mesure reste évident <strong>le temps</strong> écoulé avant de trouver la solution.</p>

<p>Les mesures que je propose ici n'ont rien de très <em>scientifique</em>. Pour
chaque mesure j'ai fait tourner l'algorithme génétique développé dans les
<a href="http://lkdjiin.github.io/blog/2013/09/08/les-algorithmes-genetiques-demystifies-8-le-paradoxe-du-singe-savant/">derniers articles</a> (le paradoxe du singe savant) 5 fois de suite.
C'est malgré tout suffisant pour dégager les tendances.</p>

<h2>Performances suivant la taille de la population</h2>

<p>Tout d'abord voyons ce qu'il se passe quand on augmente la taille de la
population.</p>

<pre><code>======================================
| population | génération | secondes |
======================================
|        150 |       3277 |       32 |
|------------------------------------|
|        500 |        363 |       12 |
|------------------------------------|
|      1.000 |         81 |        5 |
|------------------------------------|
|     10.000 |         50 |       33 |
|------------------------------------|
</code></pre>

<p>Ça ne devrait pas vous surprendre : plus la population augmente plus la
solution est trouvée en un minimum de générations. C'est presque la même
chose avec le temps, sauf que passé un certain point, il remonte en flêche.
C'est essentiellement du aux structures de données utilisées pour
construire le <em>mating pool</em>, évaluer les individus, etc. Et ça pose la
question de trouver un langage informatique adapté aux algorithmes
génétiques, langage qui soit un bon compromis entre facilité
d'écriture/lecture et performances brutes.</p>

<h2>Performances suivant le taux de mutation</h2>

<p>Voyons maintenant l'influence du taux de mutation.</p>

<pre><code>======================================
| taux de    | génération | secondes |
| mutation * |            |          |
======================================
|       0.02 |        293 |       20 |
|------------------------------------|
|       0.01 |         81 |        5 |
|------------------------------------|
|      0.005 |         75 |        5 |
|------------------------------------|
|      0.001 |         73 |        5 |
|------------------------------------|
|     0.0001 |         65 |        4 |
|------------------------------------|
|          0 |         ** |       ** |
|------------------------------------|
* Pour une population de 1000 individus.
** Aux environs de la 60ème génération si on a de la
   chance, sinon jamais car on atteint un extremum local.
</code></pre>

<p>Entre 1/100ème et 1/10.000ème la performance évolue, mais peu. À 2/100ème on
voit que la performance est déjà en train de chuter. En dessous de
1/10.000ème, le comportement se rapproche fortement d'un taux de zéro pourcent.
On considère généralement un taux de mutation de 1/<em>n</em> comme un bon
compromis (où <em>n</em> est la taille de la population).</p>

<p>Voilà, cette petite analyse est terminée.
Je ne sais pas de quoi je parlerais la prochaine fois, mais le sujet
est tellement vaste que j'ai l'impression que
cette série sur les algorithmes génétiques ne s'arretera jamais…</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 12]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/12/les-algorithmes-genetiques-demystifies-12/"/>
    <updated>2013-09-12T08:28:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/12/les-algorithmes-genetiques-demystifies-12</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Pour résoudre le paradoxe du singe savant, on a utilisé la méthode
de sélection dite de «la roue de la fortune», mais je n'avais pas
fournit l'algorithme complet de cette méthode. On en parle aujourd'hui.</p>

<!-- more -->


<p>Le problème avec la simulation de la roue de la fortune que j'ai
utilisé <a href="http://lkdjiin.github.io/blog/2013/09/10/les-algorithmes-genetiques-demystifies-10/">précédemment</a>,
c'est qu'elle n'est pas réaliste. Je n'utilisai que la partie entière des
scores d'évaluation pour placer des copies des individus dans le
<em>mating pool</em>. Ainsi un score de 0,99 était éliminatoire, et un score de 2,01
était vu comme deux fois plus adapté qu'un score de 1,99 !</p>

<h2>Une roue de la fortune réaliste</h2>

<p>L'idée, qui vient de <a href="http://en.wikipedia.org/wiki/John_Henry_Holland">John Holland</a>, est de donner une chance supplémentaire
au individus de placer une copie d'eux-mêmes en fonction de la partie
fractionnaire de leur score. Par exemple un individu évalué à 1,87 placera
d'office une copie dans le <em>mating pool</em> et aura 87 chances sur 100 de placer
une seconde copie. De même, un individu évalué à 0,49 aura 49 chances sur 100
de placer une copie. Simple, efficace et réaliste. Voici la méthode
<code>create_mating_pool</code> révisée:</p>

<p>``` ruby
def create_mating_pool
  mating_pool = []
  @population.each do |person|</p>

<pre><code>integer_part = person.first.to_i
fractional_part = person.first - integer_part
integer_part.times { mating_pool &lt;&lt; person }
mating_pool &lt;&lt; person if rand &lt; fractional_part
</code></pre>

<p>  end
  mating_pool
end
```</p>

<p>Pour que ça fonctionne avec n'importe quelle taille de population, et pas
seulement 100 individus, il faut aussi réviser la façon dont on
normalise les scores:</p>

<p>``` ruby
def normalize_population_score
  total = @population.inject(0) {|sum, person| sum + person.first }
  @population.map! do |person|</p>

<pre><code>[person.first.to_f / total * @population_size, person.last]
</code></pre>

<p>  end
end
```</p>

<p>Et voilà, on peut maintenant jouer avec nos deux variables que sont
<code>@population_size</code>, la taille de la population, et <code>@mutation_rate</code>, le
taux de mutation, pour rendre l'algorithme le plus rapide possible.</p>

<p>Il y a beaucoup de choses à propos des algorithmes génétiques sur
lesquelles j'ai encore envie d'écrire, notamment:</p>

<ul>
<li>analyse des variables</li>
<li>autres méthodes de reproduction</li>
<li>autres méthodes de sélection</li>
<li>mélange élitisme/roue de la fortune</li>
<li>code orienté objet (éventuellement création d'un framework)</li>
<li>algorithme dégénéré (Hill-climbing)</li>
<li>extremum local</li>
</ul>


<p>Chaque point de cette liste fera sûrement l'objet d'un (ou plusieurs)
futur article.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 11]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/11/les-algorithmes-genetiques-demystifies-11/"/>
    <updated>2013-09-11T09:04:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/11/les-algorithmes-genetiques-demystifies-11</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>La <a href="http://lkdjiin.github.io/blog/2013/09/10/les-algorithmes-genetiques-demystifies-10/">dernière fois</a>
on a assuré la sélection à l'aide d'une piscine
d'accouplement (je ne me lasse pas de ce terme…). Aujourd'hui, on peut
aller au bout de l'algorithme en ajoutant la reproduction.</p>

<!-- more -->


<h2>La reproduction des phrases</h2>

<p>Il n'y a rien de nouveau par rapport à <a href="http://lkdjiin.github.io/blog/2013/08/29/les-algorithmes-genetiques-demystifies-2/">l'algorithme précédent</a>,
c'est peut-être même plus simple. Voici la méthode <code>crossover</code>, qui
permet d'obtenir un enfant:</p>

<p><code>ruby
def crossover(parent1, parent2)
  point = rand(1..(@search_value.size - 1))
  child = parent1.last[0...point] + parent2.last[point..-1]
  [nil, mutate(child)]
end
</code></p>

<p><code>crossover</code> prends deux chromosomes en entrée (les parents). On définit
un point de croisement au hasard. On utilise ce point de croisement pour
<em>couper</em> les parents en deux parties. Un enfant est produit en concaténant
la première partie du premier parent avec la seconde partie du second
parent. Enfin on renvoie un chromosome, après avoir passer l'enfant/phrase
à la mutation. Voici justement la méthode chargée de la mutation:</p>

<p>``` ruby
def mutate(phrase)
  @search_value.size.times do |index|</p>

<pre><code>phrase[index] = random_gene if rand &lt; @mutation_rate
</code></pre>

<p>  end
  phrase
end
```</p>

<p>La différence avec <a href="http://lkdjiin.github.io/blog/2013/08/29/les-algorithmes-genetiques-demystifies-2/">l'algorithme précédent</a> est que cette fois chaque gène
peut muter. Avantage: on est plus proche du phénomène naturel et on pourrait
se retrouver avec un chromosome dont 2 ou 3 gènes sont mutants, ça semble
bon pour la diversité génétique. Inconvénient: Générer un nombre aléatoire
pour chaque gène peut faire tomber les performances si on a un millier de
gènes (ou plus) par chromosome et/ou une population importante. Comme
je dis d'habitude: «Si c'est de l'informatique, c'est une histoire de
compromis».</p>

<p>On peut maintenant créer une méthode <code>next_generation</code> qui englobe la
sélection et la reproduction:</p>

<p>``` ruby
def next_generation
  mating_pool = create_mating_pool
  pool_size = mating_pool.size
  @population = []
  @population_size.times do</p>

<pre><code>parent1 = mating_pool[rand(pool_size)]
parent2 = mating_pool[rand(pool_size)]
@population &lt;&lt; crossover(parent1, parent2)
</code></pre>

<p>  end
end
```</p>

<p>Je ne vais pas vous faire l'affront d'expliquer cette méthode, vous avez
toutes les cartes en main pour la comprendre. Sinon, c'est que j'ai mal
fait mon boulot…</p>

<p>Il reste à mettre tout ça ensemble, voici le code complet du programme:</p>

<p>``` ruby monkey.rb
def make_chromosome
  value = &ldquo;&rdquo;
  length = @search_value.size
  length.times { value += random_gene }
  [nil, value]
end</p>

<p>def random_gene
  @genes[rand(@genes.size)]
end</p>

<p>def make_population
  population = []
  @population_size.times { population &lt;&lt; make_chromosome }
  population
end</p>

<p>def score_population
  evaluate_population
  normalize_population_score
end</p>

<p>def evaluate_population
  @population.map! {|person| [evaluate(person.last), person.last] }
end</p>

<p>def evaluate(phrase)
  score = 0
  phrase.split(&lsquo;&rsquo;).each_with_index do |character, index|</p>

<pre><code>score += 1 if @search_value[index] == character
</code></pre>

<p>  end
  score
end</p>

<p>def normalize_population_score
  total = @population.inject(0) {|sum, person| sum + person.first }
  @population.map! {|person| [person.first.to_f / total * 100, person.last] }
end</p>

<p>def next_generation
  mating_pool = create_mating_pool
  pool_size = mating_pool.size
  @population = []
  @population_size.times do</p>

<pre><code>parent1 = mating_pool[rand(pool_size)]
parent2 = mating_pool[rand(pool_size)]
@population &lt;&lt; crossover(parent1, parent2)
</code></pre>

<p>  end
end</p>

<p>def create_mating_pool
  mating_pool = []
  @population.each do |person|</p>

<pre><code>person.first.to_i.times { mating_pool &lt;&lt; person }
</code></pre>

<p>  end
  mating_pool
end</p>

<p>def crossover(parent1, parent2)
  point = rand(1..(@search_value.size &ndash; 1))
  child = parent1.last[0&hellip;point] + parent2.last[point..-1]
  [nil, mutate(child)]
end</p>

<p>def mutate(phrase)
  @search_value.size.times do |index|</p>

<pre><code>phrase[index] = random_gene if rand &lt; @mutation_rate
</code></pre>

<p>  end
  phrase
end</p>

<p>def solution_found
  found = false
  @population.each do |person|</p>

<pre><code>found = true if person.last == @search_value
</code></pre>

<p>  end
  found
end</p>

<p>@search_value = &ldquo;Mon royaume pour un cheval&rdquo;
@genes = &ldquo;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ &rdquo;
@population_size = 100
@mutation_rate = 0.01
@population = make_population</p>

<p>1000.times do |generation|
  score_population
  puts &ldquo;Generation: #{generation}&rdquo;
  @population.each {|i| puts i.inspect }
  exit if solution_found
  next_generation
end
```</p>

<p>Et voilà le résultat:</p>

<pre><code>[~/genetic]⇒ ruby monkey.rb 
...
Generation: 869
[1.0092854259184496, "Mon royaume pour un chevaB"]
[1.0092854259184496, "Mon royaume pour un chevan"]
[1.0092854259184496, "Mon royaume pour un chevaB"]
...
[1.0496568429551878, "Mon royaume pour un cheval"]
...
[1.0092854259184496, "Mon royaume pour un chevan"]
[1.0092854259184496, "Mon royaume pour un chevaB"]
[0.9689140088817118, "Mon royaume pour un chNvaB"]
</code></pre>

<p>La prochaine fois on va améliorer notre méthode de sélection pour
tenir compte des chiffres après la virgule.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 10]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/10/les-algorithmes-genetiques-demystifies-10/"/>
    <updated>2013-09-10T08:44:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/10/les-algorithmes-genetiques-demystifies-10</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Dans <a href="http://lkdjiin.github.io/blog/2013/09/09/les-algorithmes-genetiques-demystifies-9/">l'article précédent</a>
on a appris à évaluer la population en normalisant les scores.
Aujourd'hui on s'attaque à la méthode de sélection dite de
«la roue de la fortune».</p>

<!-- more -->


<p>Dans l'algorithme génétique <a href="http://lkdjiin.github.io/blog/2013/08/29/les-algorithmes-genetiques-demystifies-2/">précédent</a>
j'utilisais une méthode de sélection <em>artificielle</em> qu'on appelle
l'élitisme : je conservais un certain nombre des meilleurs
individus d'une génération, en éliminant purement et simplement les
autres. J'ai commencé par présenter cette méthode, l'élitisme, car c'est
la plus simple. On a ainsi pu se concentrer sur d'autres parties des
algorithmes génétiques. Seulement voilà, on a vu que cette méthode de
sélection posait certains problèmes, notamment l'appauvrissement du
patrimoine génétique. La méthode de la roue de la fortune va donner une
chance à tout individu porteur d'un bon gène de le transmettre à la
génération suivante. Mais bien sûr, certains auront plus de chances
que d'autres…</p>

<h2>La roue de la fortune</h2>

<p>Imaginez une roue de la fortune où chaque case représenterait un individu.
Imaginez que plus l'individu est adapté, plus sa case sur cette roue est
large. Autrement dit, un meilleur individu à une case qui occupe un
pourcentage plus important de la roue qu'un moins bon individu. Tiens !
Ça tombe bien, la dernière fois on a justement transformé les scores en
pourcentages.</p>

<p>On va utiliser cette image de la roue de la
fortune pour sélectionner des individus en vue de la reproduction.
Je vais prendre un exemple : supposons une population de 5 individus nommés
A, B, C, D et E. Après évaluation nous pourrions avoir:</p>

<pre><code>A 40%
B 30%
C 20%
D 10%
E  0%
</code></pre>

<p>Pour simuler le principe de la roue de la fortune, nous allons créer une
sélection avec 40 copies de A, 30 copies de B, 20 copies de C et 10 copies
de D. Quand le moment de la reproduction sera venu, on tirera au sort des
couples de parents. De cette manière, les plus adaptés auront plus de
chances de transmettre leurs gènes, mais même les moins adaptés auront aussi
leur chance. L'endroit où l'on place les individus sélectionnés (suivant le
langage : une liste, un tableau, etc) est appellé <em>mating pool</em>, qu'on peut
traduire par piscine d'accouplement. J'aurais préféré un terme qui fasse
moins laboratoire, comme «club de rencontre»…</p>

<p>Voyons le code pour créer ce fameux <em>mating pool</em>:</p>

<p>``` ruby
def create_mating_pool
  mating_pool = []
  @population.each do |person|</p>

<pre><code>person.first.to_i.times { mating_pool &lt;&lt; person }
</code></pre>

<p>  end
  # mating_pool.each {|i| puts i.inspect }
  mating_pool
end
```</p>

<p>La ligne commentée ne sera pas incluse dans le programme final,
mais elle va servir aujourd'hui pour voir ce qu'il se passe et
identifier un souci. Voici le code complet du programme, jusqu'à maintenant:</p>

<p>``` ruby monkey.rb
def make_chromosome
  value = &ldquo;&rdquo;
  length = @search_value.size
  length.times { value += random_gene }
  [nil, value]
end</p>

<p>def random_gene
  @genes[rand(@genes.size)]
end</p>

<p>def make_population
  population = []
  @population_size.times { population &lt;&lt; make_chromosome }
  population
end</p>

<p>def score_population
  evaluate_population
  normalize_population_score
end</p>

<p>def evaluate_population
  @population.map! {|person| [evaluate(person.last), person.last] }
end</p>

<p>def evaluate(phrase)
  score = 0
  phrase.split(&lsquo;&rsquo;).each_with_index do |character, index|</p>

<pre><code>score += 1 if @search_value[index] == character
</code></pre>

<p>  end
  score
end</p>

<p>def normalize_population_score
  total = @population.inject(0) {|sum, person| sum + person.first }
  @population.map! {|person| [person.first.to_f / total * 100, person.last] }
end</p>

<p>def create_mating_pool
  mating_pool = []
  @population.each do |person|</p>

<pre><code>person.first.to_i.times { mating_pool &lt;&lt; person }
</code></pre>

<p>  end
  mating_pool.each {|i| puts i.inspect }
  mating_pool
end</p>

<p>@search_value = &ldquo;Mon royaume pour un cheval&rdquo;
@genes = &ldquo;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ &rdquo;
@population_size = 100
@population = make_population
score_population
create_mating_pool
```</p>

<p>Si on lance ce programme, voici une sortie possible:</p>

<pre><code>[~/genetic]⇒ ruby monkey.rb 
[1.9607843137254901, "xuo pqnnoRrKbvXoQUXbvNVHxA"]
[1.9607843137254901, "Yri QsIVwvnPsNouYLugGlZPEg"]
[1.9607843137254901, "MBxSiHlhlnlgeMwtiVIXNa eiC"]
[1.9607843137254901, "JggyWIGUdXwfpcpeRVVUGPzeFx"]
[5.88235294117647, "HPIJqwyYbgZEboKAkVEsFVeNTa"]
[5.88235294117647, "HPIJqwyYbgZEboKAkVEsFVeNTa"]
[5.88235294117647, "HPIJqwyYbgZEboKAkVEsFVeNTa"]
[5.88235294117647, "HPIJqwyYbgZEboKAkVEsFVeNTa"]
[5.88235294117647, "HPIJqwyYbgZEboKAkVEsFVeNTa"]
...
</code></pre>

<p>On voit que les individus ayant un pourcentage de 1 virgule quelque chose
ont une seule copie d'eux-mêmes, alors qu'un individu avec un pourcentage
de 5 virgule quelque chose a bien placé cinq copies de lui-même.
Comme il n'est pas possible de mettre 1.96 (ou 5.88) copie(s) j'ai utilisé
seulement la partie entière. C'est un vrai problème. Un pourcentage de 1.0
place une copie et un pourcentage de 1.99 place aussi une copie alors que
1.99 est en gros 2 fois meilleur que 1.0 ! Pire, un pourcentage de
0.99 est éliminé, et on a vu avec l'algorithme <a href="http://lkdjiin.github.io/blog/2013/08/29/les-algorithmes-genetiques-demystifies-2/">précédent</a>
que ça n'était pas une bonne chose. Encore pire, l'oubli de ces chiffres
après la virgule peut faire crasher notre programme ! Comment ? Si on
augmente la taille de la population, il devient plus que probable que
chaque individus totalise un pourcentage inférieur à 1%. Autrement dit,
le <em>mating pool</em> risque de rester vide… Tant qu'on gardera une population
de 100 individus ça devrait passer, mais il faudra bien résoudre ce
problème un jour. La prochaine fois on terminera notre algorithme
avec la reproduction.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 9]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/09/les-algorithmes-genetiques-demystifies-9/"/>
    <updated>2013-09-09T12:26:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/09/les-algorithmes-genetiques-demystifies-9</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Dans <a href="http://lkdjiin.github.io/blog/2013/09/08/les-algorithmes-genetiques-demystifies-8-le-paradoxe-du-singe-savant/">l'article précédent</a>
j'ai donné l'objectif de ce second algorithme, inspiré par le paradoxe du
singe savant, et on a vu comment construire la population de phrases.
Aujourd'hui, on se concentre sur la méthode d'évaluation, tout en
introduisant l'idée de «normaliser un score».</p>

<!-- more -->


<p>Une fois la population créée, il faut l'évaluer avant de pouvoir passer à
l'étape de sélection. Je rappelle que nos chromosomes (que j'appelle aussi
individus ou encore solutions potentielles) sont mémorisés dans une liste
contenant un score et une phrase (voir
<a href="http://lkdjiin.github.io/blog/2013/09/08/les-algorithmes-genetiques-demystifies-8-le-paradoxe-du-singe-savant/">Les algorithmes génétiques démystifiés 8</a>).</p>

<p>Voici comment j'évalue la population:</p>

<p>``` ruby
def evaluate_population
  @population.map! {|person| [evaluate(person.last), person.last] }
end</p>

<p>def evaluate(phrase)
  score = 0
  phrase.split(&lsquo;&rsquo;).each_with_index do |character, index|</p>

<pre><code>score += 1 if @search_value[index] == character
</code></pre>

<p>  end
  score
end
```</p>

<p>Je donne 1 point pour chaque lettre bien placée. C'est difficile de
faire plus simple. Je pense que dans un autre article, on expérimentera
une autre manière d'évaluer les phrases en attribuant aussi des points pour
les lettres mal placées.</p>

<p>Contrairement à l'algorithme précédent, je vais aller plus loin en
transformant ces scores en pourcentages. Utiliser les pourcentages sera
très utile pour la méthode de sélection que je développerais dans le
prochain article. Pour transformer les scores en pourcentages, on doit
d'abord les normaliser. Cela signifie qu'on va transformer chaque score en
un nombre compris entre 0 et 1. Pour normaliser, on calcule la somme de
tous les scores de la population et on divise chaque score par ce total.
Il suffit ensuite de multiplier par 100 pour avoir un pourcentage:</p>

<p><code>ruby
def normalize_population_score
  total = @population.inject(0) {|sum, person| sum + person.first }
  @population.map! {|person| [person.first.to_f / total * 100, person.last] }
end
</code></p>

<p>Finalement, on met tout ça ensemble dans une méthode:</p>

<p><code>ruby
def score_population
  evaluate_population
  normalize_population_score
end
</code></p>

<p>Voici notre programme <code>monkey.rb</code> pour l'instant:</p>

<p>``` ruby monkey.rb
def make_chromosome
  value = &ldquo;&rdquo;
  length = @search_value.size
  length.times { value += random_gene }
  [nil, value]
end</p>

<p>def random_gene
  @genes[rand(@genes.size)]
end</p>

<p>def make_population
  population = []
  @population_size.times { population &lt;&lt; make_chromosome }
  population
end</p>

<p>def score_population
  evaluate_population
  normalize_population_score
end</p>

<p>def evaluate_population
  @population.map! {|person| [evaluate(person.last), person.last] }
end</p>

<p>def evaluate(phrase)
  score = 0
  phrase.split(&lsquo;&rsquo;).each_with_index do |character, index|</p>

<pre><code>score += 1 if @search_value[index] == character
</code></pre>

<p>  end
  score
end</p>

<p>def normalize_population_score
  total = @population.inject(0) {|sum, person| sum + person.first }
  @population.map! {|person| [person.first.to_f / total * 100, person.last] }
end</p>

<p>@search_value = &ldquo;Mon royaume pour un cheval&rdquo;
@genes = &ldquo;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ &rdquo;
@population_size = 100
@population = make_population
score_population
@population.each {|i| puts i.inspect }
```</p>

<p>Et voici ce que ça donne:</p>

<pre><code>[~/genetic]⇒ ruby monkey.rb 
[2.083333333333333, "GPjvZUOnEHAwBuVPazOXXYhwaG"]
[0.0, "yQdkKetHFCUpMSMjVFwepXREhT"]
[4.166666666666666, "Fz pHfkVjyRoIhgGglvfWhXhpl"]
[0.0, "fwjafrGAalfDRhpnpAtUoNfVNU"]
[0.0, "zXxPlALVVKxGg sOUdKpSAdKNG"]
[0.0, "myoLBtIbKhfNQPnHUzqHkw Mjz"]
[0.0, "HXDVgzNAKoUhjbVPLLNikGdWqX"]
[0.0, "XQIqLRKNzrxXJUqWRFQpYozNMB"]
[0.0, "xuIIUHEwaAdFcVedVJXkTJjFEv"]
.
.
.
[6.25, " oFkamnafTYpazNMRPY KCEVLZ"]
[2.083333333333333, "JqxvMEowRmEzeRPUwXJdCQQ UB"]
</code></pre>

<p>La prochaine fois, on parlera de la méthode de sélection dite de
«la roue de la fortune», secondée par une piscine d'accouplement
(oui, c'est bien le terme, véridique !).</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
