<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : algorithme génétique | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/algorithme-genetique/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-09-05T13:08:49+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 6]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/05/les-algorithmes-genetiques-demystifies-6/"/>
    <updated>2013-09-05T13:01:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/05/les-algorithmes-genetiques-demystifies-6</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>La dernière fois on était resté sur un algorithme parfois <em>bloqué</em> par
l'extremum local. Aujourd'hui on arrange cela grâce à la mutation génétique.</p>

<!-- more -->


<p>Tout d'abord un petit mot sur la mutation génétique. Vous voyez peut-être
cela comme de sombres expériences de laboratoire, ou bien vous pensez à
Peter Parker mordu par une araignée radioactive et devenant Spiderman…
En fait, la mutation génétique est un phénomène tout à fait naturel, et
à l'origine de l'évolution des espèces. Pour ce qui nous intéresse ici, on
imaginera que, de temps en temps, un gène est <em>mal recopié</em>, ce qui va se
traduire par une inversion d'un bit dans un chromosome.</p>

<p>Voici la méthode qui est chargée de muter un chromosome:</p>

<p>``` ruby
def mutate(chromosome)
  bit = rand(48)
  value = chromosome.last
  if value[bit] == &ldquo;0&rdquo;</p>

<pre><code>value[bit] = "1"
</code></pre>

<p>  else</p>

<pre><code>value[bit] = "0"
</code></pre>

<p>  end
  [nil, value]
end
```</p>

<p>On sélectionne au hasard un bit parmi les 48 que comporte le chromosome,
puis on l'inverse. Enfin on retourne le nouveau chromosome. Pour voir ce
code à l'oeuvre, on peut écrire ceci:</p>

<p><code>ruby
c = make_chromosome
puts c.inspect
c = mutate(c)
puts c.inspect
</code></p>

<p>On peut voir qu'un bit a été inversé:</p>

<pre><code>[~/genetic]⇒ ruby test.rb 
[nil, "101000101001011110110000011000010000110011011110"]
[nil, "101000101001011110110000011000010000110010011110"]
</code></pre>

<p>Reste à savoir <em>quand</em> muter ? On considère généralement que le bon taux
de mutation se trouve entre 1/1000 et 1/100000. Ce qui nous donne la
méthode suivante:</p>

<p>``` ruby
def mutation
  @population.map do |individual|</p>

<pre><code>if rand(1000) == 0
  mutate(individual)
else
  individual
end
</code></pre>

<p>  end
end
```</p>

<p>Un individu sur 1000 va recevoir une mutation, ce qui va permettre d'apporter
du nouveau matériel génétique et, en théorie, d'éviter de tomber dans un
extremum local. Pour voir ce que ça donne, il faut modifier le code du
dernier article pour appliquer la mutation:</p>

<p>``` ruby
10000.times do |generation|
  score_population
  @population = @population.sort
  best = @population.first.first
  puts &ldquo;Generation: #{generation} Best: #{best}&rdquo;
  if best == 0</p>

<pre><code>genes = chromosome_to_gene(@population.first)
puts "Formula: #{genes_to_formula(genes)}"
exit
</code></pre>

<p>  end
  next_generation
  @population = mutation
end
```</p>

<p>Vous noterez au passage que je suis passé de 50 générations à 10000. Les
algorithmes génétiques n'ont vraiment de sens que sur un grand nombre de
générations. Voyons le résultat:</p>

<pre><code>[~/genetic]⇒ ruby test.rb 
Generation: 0 Best: 39
Generation: 1 Best: 100
Generation: 2 Best: 34
Generation: 3 Best: 88
Generation: 4 Best: 44
Generation: 5 Best: 19
Generation: 6 Best: 105
Generation: 7 Best: 47
Generation: 8 Best: 13
Generation: 9 Best: 13
Generation: 10 Best: 13
Generation: 11 Best: 2
Generation: 12 Best: 1
Generation: 13 Best: 3
Generation: 14 Best: 33
Generation: 15 Best: 19
Generation: 16 Best: 7
Generation: 17 Best: 9
Generation: 18 Best: 1
...
Generation: 465 Best: 1
Generation: 466 Best: 0
Formula: 88-1%3+900
</code></pre>

<p>Ça fonctionne ! Sauf que parfois…</p>

<p>Parfois on atteint la 10.000ème génération sans avoir la solution. Je l'ai
déjà dit et je le répète : un algorithme génétique ne peut pas garantir
que l'on trouvera la meilleure solution. Le problème avec notre algorithme
(dont je donne le code complet à la fin de l'article) tient sûrement dans
sa méthode de sélection ainsi que dans la manière dont on produit une
nouvelle génération. Il serait intéressant de voir ce qu'il se passe
en introduisant du sang frais, c'est à dire quelques individus produits
au hasard. Peut-être le sujet d'un prochain article ?</p>

<h2>Le code source entier</h2>

<p>``` ruby
def make_chromosome
  value = &ldquo;&rdquo;
  48.times { value += rand(0..1).to_s }
  [nil, value]
end</p>

<p>def make_population
  population = []
  100.times { population &lt;&lt; make_chromosome }
  population
end</p>

<p>def chromosome_to_gene(chromosome)
  chromosome.last.scan /.{4}/
end</p>

<p>def gene_to_operand(gene)
  case gene
  when &ldquo;0000&rdquo; then 0
  when &ldquo;0001&rdquo; then 1
  when &ldquo;0010&rdquo; then 2
  when &ldquo;0011&rdquo; then 3
  when &ldquo;0100&rdquo; then 4
  when &ldquo;0101&rdquo; then 5
  when &ldquo;0110&rdquo; then 6
  when &ldquo;0111&rdquo; then 7
  when &ldquo;1000&rdquo; then 8
  when &ldquo;1001&rdquo; then 9
  when &ldquo;1010&rdquo; then &ldquo;+&rdquo;
  when &ldquo;1011&rdquo; then &ldquo;&ndash;&rdquo;
  when &ldquo;1100&rdquo; then &ldquo;/&rdquo;
  when &ldquo;1101&rdquo; then &ldquo;%&rdquo;
  end
end</p>

<p>def selection
  @selected = @population[0&hellip;50].shuffle
end</p>

<p>def genes_to_formula(genes)
  formula = []
  genes.each {|gene| formula &lt;&lt; gene_to_operand(gene) }
  formula.join
end</p>

<p>def evaluation(genes)
  formula = genes_to_formula(genes)
  begin</p>

<pre><code>result = (@search_value - eval(formula)).abs
</code></pre>

<p>  rescue Exception</p>

<pre><code>result = 999_999_999_999
</code></pre>

<p>  end
  result = 999_999_999_999 unless result.is_a?(Integer)
  result
end</p>

<p>def score_population
  @population = @population.map do |individual|</p>

<pre><code>genes = chromosome_to_gene(individual)
individual[0] = evaluation(genes)
individual
</code></pre>

<p>  end
end</p>

<p>def crossover(parent1, parent2)
  point = rand(1..47)
  child1 = [nil, parent1.last[0&hellip;point] + parent2.last[point..-1]]
  child2 = [nil, parent2.last[0&hellip;point] + parent1.last[point..-1]]
  [child1, child2]
end</p>

<p>def next_generation
  @selection = selection
  @population = []
  25.times do</p>

<pre><code>parent1, parent2 = @selection.slice!(0, 2)
child1, child2 = crossover(parent1, parent2)
child3, child4 = crossover(parent1, parent2)
@population += [child1, child2, child3, child4]
</code></pre>

<p>  end
end</p>

<p>def mutation
  @population.map do |individual|</p>

<pre><code>if rand(1000) == 0
  mutate(individual)
else
  individual
end
</code></pre>

<p>  end
end</p>

<p>def mutate(chromosome)
  bit = rand(48)
  value = chromosome.last
  if value[bit] == &ldquo;0&rdquo;</p>

<pre><code>value[bit] = "1"
</code></pre>

<p>  else</p>

<pre><code>value[bit] = "0"
</code></pre>

<p>  end
  [nil, value]
end</p>

<p>@search_value = 987
@population = make_population</p>

<p>10000.times do |generation|
  score_population
  @population = @population.sort
  best = @population.first.first
  puts &ldquo;Generation: #{generation} Best: #{best}&rdquo;
  if best == 0</p>

<pre><code>genes = chromosome_to_gene(@population.first)
puts "Formula: #{genes_to_formula(genes)}"
exit
</code></pre>

<p>  end
  next_generation
  @population = mutation
end
```</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 5]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/03/les-algorithmes-genetiques-demystifies-5/"/>
    <updated>2013-09-03T08:43:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/03/les-algorithmes-genetiques-demystifies-5</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Maintenant qu'on sait créer une population de solutions, l'évaluer,
opérer une sélection des meilleures solutions et obtenir une nouvelle
génération par la reproduction, il reste à assembler toutes ces parties
et voir ce qu'il se passe…</p>

<!-- more -->


<p>Voici le code complet de notre algorithme:</p>

<p>``` ruby
def make_chromosome
  value = &ldquo;&rdquo;
  48.times { value += rand(0..1).to_s }
  [nil, value]
end</p>

<p>def make_population
  population = []
  100.times { population &lt;&lt; make_chromosome }
  population
end</p>

<p>def chromosome_to_gene(chromosome)
  chromosome.last.scan /.{4}/
end</p>

<p>def gene_to_operand(gene)
  case gene
  when &ldquo;0000&rdquo; then 0
  when &ldquo;0001&rdquo; then 1
  when &ldquo;0010&rdquo; then 2
  when &ldquo;0011&rdquo; then 3
  when &ldquo;0100&rdquo; then 4
  when &ldquo;0101&rdquo; then 5
  when &ldquo;0110&rdquo; then 6
  when &ldquo;0111&rdquo; then 7
  when &ldquo;1000&rdquo; then 8
  when &ldquo;1001&rdquo; then 9
  when &ldquo;1010&rdquo; then &ldquo;+&rdquo;
  when &ldquo;1011&rdquo; then &ldquo;&ndash;&rdquo;
  when &ldquo;1100&rdquo; then &ldquo;/&rdquo;
  when &ldquo;1101&rdquo; then &ldquo;%&rdquo;
  end
end</p>

<p>def selection
  @selected = @population[0&hellip;50].shuffle
end</p>

<p>def genes_to_formula(genes)
  formula = []
  genes.each {|gene| formula &lt;&lt; gene_to_operand(gene) }
  formula.join
end</p>

<p>def evaluation(genes)
  formula = genes_to_formula(genes)
  begin</p>

<pre><code>result = (@search_value - eval(formula)).abs
</code></pre>

<p>  rescue Exception</p>

<pre><code>result = 999_999_999_999
</code></pre>

<p>  end
  result = 999_999_999_999 unless result.is_a?(Integer)
  result
end</p>

<p>def score_population
  @population = @population.map do |individual|</p>

<pre><code>genes = chromosome_to_gene(individual)
individual[0] = evaluation(genes)
individual
</code></pre>

<p>  end
end</p>

<p>def crossover(parent1, parent2)
  point = rand(1..47)
  child1 = [nil, parent1.last[0&hellip;point] + parent2.last[point..-1]]
  child2 = [nil, parent2.last[0&hellip;point] + parent1.last[point..-1]]
  [child1, child2]
end</p>

<p>def next_generation
  @selection = selection
  @population = []
  25.times do</p>

<pre><code>parent1, parent2 = @selection.slice!(0, 2)
child1, child2 = crossover(parent1, parent2)
child3, child4 = crossover(parent1, parent2)
@population += [child1, child2, child3, child4]
</code></pre>

<p>  end
end</p>

<h1>Ce qui suit est nouveau:</h1>

<p>@search_value = 987
@population = make_population</p>

<p>50.times do |generation|
  score_population
  @population = @population.sort
  best = @population.first.first
  puts &ldquo;Generation: #{generation} Best: #{best}&rdquo;
  exit if best == 0
  next_generation
end
```</p>

<p>Seules les dernières lignes de code sont nouvelles. Elles sont assez
simple à comprendre je pense, même si vous ne connaissez pas le
langage Ruby. On commence par définir le nombre qu'on recherche puis
on crée la population d'origine au hasard avec <code>@population = make_population</code>.
Ensuite on itère sur 50 générations avec <code>50.times do |generation|</code>. C'est
notre première condition de sortie : quoiqu'il se passe, on arrête le
traitement au bout à la 50ème génération. Dans cette boucle on évalue
la génération en cours avec <code>score_population</code> et on la trie. Pour savoir
où on en est visuellement on extrait le meilleur score avec
<code>best = @population.first.first</code> et on affiche cette information à la ligne
suivante. Vient ensuite notre seconde et dernière condition de sortie avec
<code>exit if best == 0</code> ; autrement dit on stoppe le traitement à la première
solution trouvée. Pour finir, on produit la génération suivante avec
<code>next_generation</code>.</p>

<h2>Et ça donne quoi ?</h2>

<p>La plupart du temps ça donne quelque chose comme ça:</p>

<p><code>console
[~/genetic]⇒ ruby test.rb
Generation: 0 Best: 507
Generation: 1 Best: 138
Generation: 2 Best: 485
Generation: 3 Best: 347
Generation: 4 Best: 65
Generation: 5 Best: 208
Generation: 6 Best: 222
Generation: 7 Best: 15
Generation: 8 Best: 15
Generation: 9 Best: 2
Generation: 10 Best: 0
</code></p>

<p>Les générations successives convergent lentement vers la solution.
Si vous voulez voir la solution trouvée (c'est normal d'être curieux)
vous pouvez remplacez une ligne de code pour afficher la solution:</p>

<p>``` ruby</p>

<h1>exit if best == 0</h1>

<p>if best == 0
  genes = chromosome_to_gene(@population.first)
  puts &ldquo;Formula: #{genes_to_formula(genes)}&rdquo;
  exit
end
```</p>

<p>Voici quelques exemples de solutions:</p>

<pre><code>Formula: 912%429+933
Formula: 670+594-277
Formula: 893+91%96+3
Formula: 923--03--61
</code></pre>

<p>Alors, la plupart du temps, ça se passe bien. Mais parfois un phénomène
étrange se produit:</p>

<p><code>console
[~/genetic]⇒ ruby test.rb
Generation: 0 Best: 597
Generation: 1 Best: 621
Generation: 2 Best: 104
...
Generation: 25 Best: 1
...
Generation: 48 Best: 1
Generation: 49 Best: 1
[~/genetic]⇒
</code></p>

<p>L'algorithme reste <em>bloqué</em> sur une valeur et on atteint la 50ème
génération sans avoir trouver de solution. What the fuck ? Et bien
l'algorithme a atteint ce qu'on appelle
<a href="http://fr.wikipedia.org/wiki/Extremum_local">l'extremum local</a>. Pour faire
court, ça signifie qu'il ne peut pas faire mieux
avec les gènes dont il disposait à l'origine. Je developperais cette
idée dans un futur article. En attendant, comment on règle ça ?
En s'inspirant encore une fois de phénomènes naturels : la mutation
et/ou la diversité génétique.
C'est le sujet du prochain article.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 4]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/02/les-algorithmes-genetiques-demystifies-4/"/>
    <updated>2013-09-02T08:26:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/02/les-algorithmes-genetiques-demystifies-4</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Après en avoir terminer avec la création de la population et la sélection,
on passe à la reproduction.</p>

<!-- more -->


<p>Pour imiter ce qu'il se passe dans la nature, de manière fort simple,
on va définir une fonction <code>crossover</code> (croisé, croisement) qui prend
en entrée deux chromosomes, les parents, et qui produit en sortie une liste
de deux autres chromosomes, les enfants. Le principe est de couper chaque
chromosomes parents en deux parties A et B, puis d'assembler la partie A
du parent 1 avec la partie B du parent 2 et vice-versa. Voici une illustration
du processus avec des chromosomes de 8 bits (symbolisés par des lettres):</p>

<pre><code>parent1  aaabbbbb
parent2  xxxyyyyy

enfant1  aaayyyyy
enfant2  xxxbbbbb
</code></pre>

<p>Voici donc la fonction:</p>

<p><code>ruby
def crossover(parent1, parent2)
  point = rand(1..47)
  child1 = [nil, parent1.last[0...point] + parent2.last[point..-1]]
  child2 = [nil, parent2.last[0...point] + parent1.last[point..-1]]
  [child1, child2]
end
</code></p>

<p>Tout d'abord on défini le point de croisement avec <code>point = rand(1..47)</code>.
Puis on assemble les deux chromosomes enfants et on les renvoient sous
la forme d'une liste. Ce mode de reproduction est le plus simple, mais
pas forcement le plus efficace (on en reparle un autre jour).</p>

<p>On a maintenant tout ce qu'il faut pour produire la génération suivante:</p>

<p>``` ruby
def next_generation
  @selection = selection
  @population = []
  25.times do</p>

<pre><code>parent1, parent2 = @selection.slice!(0, 2)
child1, child2 = crossover(parent1, parent2)
child3, child4 = crossover(parent1, parent2)
@population += [child1, child2, child3, child4]
</code></pre>

<p>  end
end
```</p>

<p>Après avoir sélectionné les 50 meilleures solutions (voir
<a href="http://lkdjiin.github.io/blog/2013/08/30/les-algorithmes-genetiques-demystifies-3/">article précédent</a>) je crée une nouvelle population : Avec 50
individus on forme 25 couples qui vont chacun produire 4 enfants et
on retrouve une population de 100 solutions, sensée être globalement
meilleure que la génération précédente.</p>

<p>Même si c'est peu représentatif des phénomènes naturels, dans un algorithme
génétique les générations successives restent généralement stable en taille.
Ça évite aussi bien la croissance infinie (mémoire des ordinateurs limitée)
que le dépérissement de la population.</p>

<p>La prochaine fois on assemblera le tout pour voir notre algorithme
génétique à l'oeuvre.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/30/les-algorithmes-genetiques-demystifies-3/"/>
    <updated>2013-08-30T09:52:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/30/les-algorithmes-genetiques-demystifies-3</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>On termine ce qu'on a commencé
<a href="http://lkdjiin.github.io/blog/2013/08/29/les-algorithmes-genetiques-demystifies-2/">hier</a>,
à savoir l'évaluation de la population et on s'occupe aussi
de la sélection, en vue de la reproduction.</p>

<!-- more -->


<p>Il est temps de noter la population entière:</p>

<p>``` ruby
def score_population
  @population = @population.map do |individual|</p>

<pre><code>genes = chromosome_to_gene(individual)
individual[0] = evaluation(genes)
individual
</code></pre>

<p>  end
end
```</p>

<p>La fonction <code>score_population</code> itère sur chaque individu,
calcule son score et modifie
l'individu pour qu'il reflète ce score. On peut voir ce que donne
notre code jusqu'ici en ajoutant ces quelques lignes:</p>

<p><code>ruby
@search_value = 987
@population = make_population
score_population
@population = @population.sort
@population.each {|individual| puts individual.inspect}
</code></p>

<p>Si vous ne connaissez pas trop Ruby, sachez que <code>sort</code> va trier
la population sur le premier élément de chaque individu, soit son score.
Et voici un résultat possible:</p>

<pre><code>[4, "001100111010111110010010100011111010111100110000"]
[198, "101000011111001000010011110100101010011110001000"]
[331, "011011101110010101101101011100000110001110000100"]
[524, "111011100101011010100010011010101110001110000001"]
[666, "001100101110000111011000100001010101011000000001"]
[735, "101000101111100001001110101101100010101000110000"]
[895, "100111110011101101000110110000110101110100101111"]
[932, "001100010100000111000101011111011000010111110100"]
...
[999999999999, "111100001100101011100000001011111110101110001100"]
[999999999999, "111100101001110111110101101101101101000111101010"]
</code></pre>

<p>Vous pouvez vous amuser à décrypter quelques chromosomes à la main si
ça vous amuse (ou bien si vous êtes sceptique).</p>

<p>On en a maintenant fini avec l'évaluation. Il faut savoir que cette partie est
toujours spécifique à un problème donné. C'est à dire que pour chaque
problème il faut trouver:</p>

<ul>
<li>comment représenter/crypter un gène, un chromosome</li>
<li>comment les décrypter</li>
<li>comment évaluer une solution</li>
<li>comment classer la population</li>
</ul>


<h2>La sélection</h2>

<p>Maintenant on peut passer à l'étape de selection. Ça va être très rapide.
Je vais m'inspirer de la selection artificielle, et non pas naturelle:</p>

<p><code>ruby
def selection
  @selected = @population[0...50].shuffle
end
</code></p>

<p>Simple, non ? Je conserve les 50 premiers individus. Au passage, <code>shuffle</code> sert
à mélanger au hasard. Demain, nous ferons se reproduire ces 50 solutions qui
sont les meilleures de leur génération.</p>

<p><strong>Attention :</strong> si ce type de sélection a le mérite
d'être simple, il n'en est pas moins radical. C'est de l'élitisme, voir
limite de l'eugénisme
(heureusement ce n'est que de l'informatique). Il y a un tas
d'autres façons d'opérer une sélection, et j'en parlerais sûrement plus en
détails plus tard. D'ici là, cette méthode élitiste devrait convenir assez
bien pour notre petit problème (il est possible qu'elle nous cause
quelques soucis quand même… suspens…).</p>

<h2>Un mot sur le code</h2>

<p>J'utilise Ruby pour présenter les algorithmes génétiques car je trouve que
c'est un langage assez facile à comprendre même pour ceux qui ne le
maitrise pas. J'utilise aussi un style volontairement très simple et
procédural pour que chacun puisse l'adapter le plus facilement possible
à son propre paradigme/langage. Si vous voulez voir ce que donne le code
de l'article d'hier d'une manière orienté objet,
<a href="https://twitter.com/PagedeGeek">@Sam</a>
(de <a href="http://www.pagedegeek.com/">Page de Geek</a>)
a eu la gentillesse de s'y coller et a pondu
<a href="https://gist.github.com/PagedeGeek/6378269">ce code</a>
très bien écrit.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/29/les-algorithmes-genetiques-demystifies-2/"/>
    <updated>2013-08-29T09:29:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/29/les-algorithmes-genetiques-demystifies-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Dans cette seconde partie, on commence à coder…</p>

<p>J'ai choisi un problème simple: trouver une expression qui vaut 987 en
mélangeant les chiffres de 0 à 9 et les symboles +, &ndash;, / et %, respectivement
pour addition, soustraction, division entière et reste de la division.
L'expression comportera 12 caractères/symboles maximum. Par exemple:</p>

<ul>
<li>&ldquo;987&rdquo;</li>
<li>&ldquo;900+87&rdquo;</li>
<li>&ldquo;2000/2-13&rdquo;</li>
</ul>


<p>sont différentes solutions possibles au problème posé.</p>

<!-- more -->


<p>Je n'utilise pas la multiplication pour éviter d'avoir des nombres trop
grands (<code>**</code> est l'opérateur de puissance en Ruby, comme dans certains
autres langages).</p>

<p>La première chose à faire est de définir comment on va coder les gènes.
Traditionnellement, ils sont représentés sous la forme d'une chaîne de bits.
Comme on a 14 symboles (10 chiffres et 4 opérateurs mathématiques) à
coder, 4 bits sont suffisants. Les 2 derniers encodages sont des gènes qui
ne font rien:</p>

<pre><code>0000 0
0001 1
0010 2
0011 3
0100 4
0101 5
0110 6
0111 7
1000 8
1001 9
1010 +
1011 -
1100 /
1101 %
1110 ne rien faire
1111 ne rien faire
</code></pre>

<p>L'expression recherchée devant faire au maximum 12 caractères de long, nos
chromosomes mesureront 48 bits (12 caractères multiplié par 4 bits).</p>

<p>Le problème est posé,
c'est parti pour le code. Il est en Ruby mais je vais faire en sorte
qu'il soit compréhensible par tous et facilement transposable dans
votre langage de prédilection.</p>

<p>On doit pouvoir créer un chromosome au hasard:</p>

<p><code>ruby
def make_chromosome
  value = ""
  48.times { value += rand(0..1).to_s }
  [nil, value]
end
</code></p>

<p>Cette fonction renvoie une liste avec <code>nil</code>, qui sera plus tard utilisé
pour mémoriser l'évaluation du chromosome (son score) et une chaîne de
48 caractères au hasard parmi &ldquo;1&rdquo; et &ldquo;0&rdquo;.</p>

<p>On peut maintenant fabriquer une population complète:</p>

<p><code>ruby
def make_population
  population = []
  100.times { population &lt;&lt; make_chromosome }
  population
end
</code></p>

<p>La fonction <code>make_population</code> renvoie une liste de 100 chromosomes.</p>

<p>On peut voir ce que ça donne avec <code>make_population.each {|x| puts x.inspect}</code>:</p>

<pre><code>[nil, "110111010010111000000001011001111000100010101111"]
[nil, "101100010001001000011000111011000001100010000000"]
...
[nil, "111110110011110111111110110000010100100100000100"]
[nil, "000010101001000010011001101010101110011100010010"]
</code></pre>

<p>Maintenant qu'on a créé une population de 100 solutions potentielles, il
faut pouvoir évaluer chaque solution. Pour cela, il faut d'abord être en
mesure de séparer une suite de 48 bits (le chromosome) en 12 parties de
4 bits (les gènes):</p>

<p><code>ruby
def chromosome_to_gene(chromosome)
  chromosome.last.scan /.{4}/
end
</code></p>

<p>La fonction <code>chromosome_to_gene</code> prend en entrée un chromosome (créé avec
<code>make_chromosome</code>) et renvoie une liste des 12 gènes qui le compose.</p>

<p>Pour décrypter l'expression composée par les 12 gènes, il faut tout
d'abord décrypter un seul gène:</p>

<p><code>ruby
def gene_to_operand(gene)
  case gene
  when "0000" then 0
  when "0001" then 1
  when "0010" then 2
  when "0011" then 3
  when "0100" then 4
  when "0101" then 5
  when "0110" then 6
  when "0111" then 7
  when "1000" then 8
  when "1001" then 9
  when "1010" then "+"
  when "1011" then "-"
  when "1100" then "/"
  when "1101" then "%"
  end
end
</code></p>

<p>On peut maintenant decrypter la formule complète (l'expression):</p>

<p><code>ruby
def genes_to_formula(genes)
  formula = []
  genes.each {|gene| formula &lt;&lt; gene_to_operand(gene) }
  formula.join
end
</code></p>

<p><code>genes_to_formula</code> prend en entrée la liste des 12 gènes d'un chromosome
et renvoie l'expression sous la forme d'une chaîne de caractères.</p>

<p>L'évaluation proprement dite se passe ainsi:</p>

<p>``` ruby
def evaluation(genes)
  formula = genes_to_formula(genes)
  begin</p>

<pre><code>result = (@search_value - eval(formula)).abs
</code></pre>

<p>  rescue Exception</p>

<pre><code>result = 999_999_999_999
</code></pre>

<p>  end
  result = 999_999_999_999 unless result.is_a?(Integer)
  result
end
```</p>

<p>Cette fonction mérite quelques d'explications. L'expression (<code>formula</code>)
est évaluée avec <code>eval</code>. En ruby, <code>eval</code> evalue une chaîne de caractères
comme si c'était du code source (comme en Javascript, etc).
On ôte ce résultat de <code>@search_value</code>, qui
contient le nombre qu'on cherche (notre problème) et on garde la valeur
absolue. Ainsi zéro signifie une solution et plus on s'éloigne de zéro,
plus on est loin d'une solution. On pourra donc facilement classer nos
individus. Si <code>eval</code> provoque une exception (à cause d'une formule/expression
incompréhensible), on place une grande valeur
comme résultat puisqu'on est très loin de la solution. On peut voir
le nombre 999.999.999.999 comme étant l'infini. Enfin je regarde si
le résultat de <code>eval</code> est bien un nombre et dans le cas contraire, je
change le résultat pour refleter ce souci. Qu'est ce que ça peut être
d'autre qu'un nombre ? En ruby, une chaîne placée entre <code>/</code> est une
expression régulière. Voilà pour aujourd'hui.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
