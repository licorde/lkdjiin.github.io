<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : algorithme génétique | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/algorithme-genetique/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-08-29T09:47:23+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/29/les-algorithmes-genetiques-demystifies-2/"/>
    <updated>2013-08-29T09:29:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/29/les-algorithmes-genetiques-demystifies-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Dans cette seconde partie, on commence à coder…</p>

<p>J'ai choisi un problème simple: trouver une expression qui vaut 987 en
mélangeant les chiffres de 0 à 9 et les symboles +, &ndash;, / et %, respectivement
pour addition, soustraction, division entière et reste de la division.
L'expression comportera 12 caractères/symboles maximum. Par exemple:</p>

<ul>
<li>&ldquo;987&rdquo;</li>
<li>&ldquo;900+87&rdquo;</li>
<li>&ldquo;2000/2-13&rdquo;</li>
</ul>


<p>sont différentes solutions possibles au problème posé.</p>

<!-- more -->


<p>Je n'utilise pas la multiplication pour éviter d'avoir des nombres trop
grands (<code>**</code> est l'opérateur de puissance en Ruby, comme dans certains
autres langages).</p>

<p>La première chose à faire est de définir comment on va coder les gènes.
Traditionnellement, ils sont représentés sous la forme d'une chaîne de bits.
Comme on a 14 symboles (10 chiffres et 4 opérateurs mathématiques) à
coder, 4 bits sont suffisants. Les 2 derniers encodages sont des gènes qui
ne font rien:</p>

<pre><code>0000 0
0001 1
0010 2
0011 3
0100 4
0101 5
0110 6
0111 7
1000 8
1001 9
1010 +
1011 -
1100 /
1101 %
1110 ne rien faire
1111 ne rien faire
</code></pre>

<p>L'expression recherchée devant faire au maximum 12 caractères de long, nos
chromosomes mesureront 48 bits (12 caractères multiplié par 4 bits).</p>

<p>Le problème est posé,
c'est parti pour le code. Il est en Ruby mais je vais faire en sorte
qu'il soit compréhensible par tous et facilement transposable dans
votre langage de prédilection.</p>

<p>On doit pouvoir créer un chromosome au hasard:</p>

<p><code>ruby
def make_chromosome
  value = ""
  48.times { value += rand(0..1).to_s }
  [nil, value]
end
</code></p>

<p>Cette fonction renvoie une liste avec <code>nil</code>, qui sera plus tard utilisé
pour mémoriser l'évaluation du chromosome (son score) et une chaîne de
48 caractères au hasard parmi &ldquo;1&rdquo; et &ldquo;0&rdquo;.</p>

<p>On peut maintenant fabriquer une population complète:</p>

<p><code>ruby
def make_population
  population = []
  100.times { population &lt;&lt; make_chromosome }
  population
end
</code></p>

<p>La fonction <code>make_population</code> renvoie une liste de 100 chromosomes.</p>

<p>On peut voir ce que ça donne avec <code>make_population.each {|x| puts x.inspect}</code>:</p>

<pre><code>[nil, "110111010010111000000001011001111000100010101111"]
[nil, "101100010001001000011000111011000001100010000000"]
...
[nil, "111110110011110111111110110000010100100100000100"]
[nil, "000010101001000010011001101010101110011100010010"]
</code></pre>

<p>Maintenant qu'on a créé une population de 100 solutions potentielles, il
faut pouvoir évaluer chaque solution. Pour cela, il faut d'abord être en
mesure de séparer une suite de 48 bits (le chromosome) en 12 parties de
4 bits (les gènes):</p>

<p><code>ruby
def chromosome_to_gene(chromosome)
  chromosome.last.scan /.{4}/
end
</code></p>

<p>La fonction <code>chromosome_to_gene</code> prend en entrée un chromosome (créé avec
<code>make_chromosome</code>) et renvoie une liste des 12 gènes qui le compose.</p>

<p>Pour décrypter l'expression composée par les 12 gènes, il faut tout
d'abord décrypter un seul gène:</p>

<p><code>ruby
def gene_to_operand(gene)
  case gene
  when "0000" then 0
  when "0001" then 1
  when "0010" then 2
  when "0011" then 3
  when "0100" then 4
  when "0101" then 5
  when "0110" then 6
  when "0111" then 7
  when "1000" then 8
  when "1001" then 9
  when "1010" then "+"
  when "1011" then "-"
  when "1100" then "/"
  when "1101" then "%"
  end
end
</code></p>

<p>On peut maintenant decrypter la formule complète (l'expression):</p>

<p><code>ruby
def genes_to_formula(genes)
  formula = []
  genes.each {|gene| formula &lt;&lt; gene_to_operand(gene) }
  formula.join
end
</code></p>

<p><code>genes_to_formula</code> prend en entrée la liste des 12 gènes d'un chromosome
et renvoie l'expression sous la forme d'une chaîne de caractères.</p>

<p>L'évaluation proprement dite se passe ainsi:</p>

<p>``` ruby
def evaluation(genes)
  formula = genes_to_formula(genes)
  begin</p>

<pre><code>result = (@search_value - eval(formula)).abs
</code></pre>

<p>  rescue Exception</p>

<pre><code>result = 999_999_999_999
</code></pre>

<p>  end
  result = 999_999_999_999 unless result.is_a?(Integer)
  result
end
```</p>

<p>Cette fonction mérite quelques d'explications. L'expression (<code>formula</code>)
est évaluée avec <code>eval</code>. En ruby, <code>eval</code> evalue une chaîne de caractères
comme si c'était du code source (comme en Javascript, etc).
On ôte ce résultat de <code>@search_value</code>, qui
contient le nombre qu'on cherche (notre problème) et on garde la valeur
absolue. Ainsi zéro signifie une solution et plus on s'éloigne de zéro,
plus on est loin d'une solution. On pourra donc facilement classer nos
individus. Si <code>eval</code> provoque une exception (à cause d'une formule/expression
incompréhensible), on place une grande valeur
comme résultat puisqu'on est très loin de la solution. On peut voir
le nombre 999.999.999.999 comme étant l'infini. Enfin je regarde si
le résultat de <code>eval</code> est bien un nombre et dans le cas contraire, je
change le résultat pour refleter ce souci. Qu'est ce que ça peut être
d'autre qu'un nombre ? En ruby, une chaîne placée entre <code>/</code> est une
expression régulière. Voilà pour aujourd'hui.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/28/les-algorithmes-genetiques-demystifies/"/>
    <updated>2013-08-28T09:49:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/28/les-algorithmes-genetiques-demystifies</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p><strong>démystifié</strong>:
<blockquote><p>Enlever le caractère mystérieux.</p></blockquote></p>

<p>Un algorithme génétique c'est quoi ? Comment ça marche ? À quoi ça sert ?
Si vous vous posez une de ces questions, cette
nouvelle série d'articles peut vous
intéresser.</p>

<!-- more -->


<h2>Une définition simple</h2>

<p>Tout d'abord, un algorithme génétique est un <em>algorithme</em>. Autrement dit
c'est une suite d'instructions, ou encore une recette, pour résoudre un
problème. C'est peut-être bidon pour certains d'entre vous, mais ça va mieux
en le disant.</p>

<p>Ensuite, pourquoi génétique ? Et bien parce que pour résoudre un problème,
cette catégorie d'algorithmes s'inspire de la biologie, de la génétique,
et notamment du mécanisme de la séléction naturelle et/ou artificielle.</p>

<h2>La démarche</h2>

<p>Pour faire court:</p>

<ol>
<li>On crée une population au hasard. Chaque individu représente une solution
possible au problème posé.</li>
<li>On évalue chaque individu (solution) de la population. En clair, on leur
donne une note.</li>
<li>On selectionne certains individus parmi les plus adaptés.</li>
<li>Les individus (solutions) sélectionnés se reproduisent pour donner
naissance à la nouvelle génération, qui est globalement plus adaptée.</li>
<li>On recommence au point 2 jusqu'à ce qu'on trouve la solution du
problème.</li>
</ol>


<h2>Les domaines d'application</h2>

<p>Tous, ou presque. Trouver le meilleur profil pour une hélice de bateau ou
une aile d'avion, apprendre à marcher à un robot, adapter le comportement
d'un personnage dans un jeu vidéo, maximiser l'exploitation du volume
d'un hangar, etc. Comme chaque nouvelle génération produit globalement
une meilleure solution, les algorithmes génétiques peuvent être très
intéressants lorsqu'on veut obtenir une <em>bonne</em> solution rapidement (et
pas forcement la <em>meilleure</em> solution).</p>

<p>Dans mes prochains articles, je parlerais plus en détails de ces
algorithmes et je montrerais notamment comment les coder.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
