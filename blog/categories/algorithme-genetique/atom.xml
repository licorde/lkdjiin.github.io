<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : algorithme génétique | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/algorithme-genetique/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-09-08T10:20:24+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 8 - Le paradoxe du singe savant]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/08/les-algorithmes-genetiques-demystifies-8-le-paradoxe-du-singe-savant/"/>
    <updated>2013-09-08T09:40:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/08/les-algorithmes-genetiques-demystifies-8-le-paradoxe-du-singe-savant</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Dans son livre <a href="http://natureofcode.com/">The nature of code</a>,
Daniel Shiffman consacre un chapitre aux algorithmes génétiques. Je lui
pique l'idée du prochain algorithme que je vais développer sur ce blog.</p>

<p>Cette fois j'aimerais vous montrer un algorithme génétique plus traditionnel,
dans l'esprit de la <em>méthode</em> développée par
<a href="http://en.wikipedia.org/wiki/John_Henry_Holland">John Holland</a>, qu'on peut
considerer comme le pionnier en la matière.</p>

<!-- more -->


<h2>Objectif</h2>

<p>Le but du jeu est d'obtenir la phrase suivante : «Mon royaume pour un
cheval». C'est une variante du
<a href="http://fr.wikipedia.org/wiki/Paradoxe_du_singe_savant">paradoxe du singe savant</a>.
Contrairement à <a href="http://lkdjiin.github.io/blog/2013/08/29/les-algorithmes-genetiques-demystifies-2/">l'algorithme précédent</a>, les chromosomes vont
être représentés par une simple phrase, et non par une chaîne de bits.
Cela va me permettre de me concentrer plus sur l'explication de la
méthode de sélection. Le programme sera encore écrit en Ruby, dans un
style procédural, pour permettre au plus grand nombre de le comprendre
facilement. La seule différence avec le style de code de
<a href="http://lkdjiin.github.io/blog/2013/08/29/les-algorithmes-genetiques-demystifies-2/">l'algorithme précédent</a> est que je vais éviter les <em>nombres magiques</em>
pour pouvoir plus simplement personnalisé l'algorithme.</p>

<p>L'intérêt d'un problème aussi simple, et dont on connait déjà la solution,
est d'apprendre à avoir confiance dans les algorithmes génétiques.
Lorsqu'on passera plus tard à la résolution d'un problème inconnu, on n'aura
pas à se demander «est-ce-que ça fonctionne vraiment ?».</p>

<h2>Créer la population</h2>

<p>Voici le code qui va permettre de créer la population de solutions
potentielles:</p>

<p>``` ruby monkey.rb
def make_chromosome
  value = &ldquo;&rdquo;
  length = @search_value.size
  length.times { value += random_gene }
  [nil, value]
end</p>

<p>def random_gene
  @genes[rand(@genes.size)]
end</p>

<p>def make_population
  population = []
  @population_size.times { population &lt;&lt; make_chromosome }
  population
end</p>

<p>@search_value = &ldquo;Mon royaume pour un cheval&rdquo;
@genes = &ldquo;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ &rdquo;
@population_size = 100
@population = make_population
@population.each {|i| puts i.inspect }
```</p>

<p>La fonction <code>make_chromosome</code> crée une phrase de la même taille que celle qu'on
recherche. Elle se sert de la fonction <code>random_gene</code> pour obtenir les gènes
au hasard. Un gène, ici, est une lettre minuscule ou majuscule, ou un espace.
<code>make_chromosome</code> renvoie une liste avec la phrase et une valeur nulle placée
au début. Cette valeur nulle sera remplacée plus tard par l'évaluation
de la phrase.</p>

<p>Voilà ce que donne le programme pour l'instant:</p>

<pre><code>[~/genetic]⇒ ruby monkey.rb 
[nil, "OdjBvCjnhCGRukFKwbpnUbSGzR"]
[nil, "uVqkznTRQwbUkrxUklkWgIVfyv"]
[nil, "LIRrECVrjFZPqaoySxosMs hdX"]
[nil, "XghuLIEopQNUjECpnnhtISelLs"]
[nil, "ovkilBZhnFTMEweTDOjsDbcqXX"]
[nil, "tGkEbfscRscqqRfoCxtwPuRqVx"]
[nil, "FHnwlsnoHtHbXTzsJohbyaxjIb"]
[nil, "xNbSYbkULcgfootEBJwfYiZqrC"]
[nil, "RcQfonEVMQnbdZX k glNDphbB"]
.
.
.
[nil, "OZVyLLOkKbzZnYTTLNxGty NWh"]
[nil, "rPyGwpTjvUmblwXCqlYBUBtPmZ"]
[nil, "FSQPGCFqYMWhaEurBOnefJceoZ"]
[nil, "bsMFghPtlFfkYLpKWRohhSAHjY"]
[nil, "FFATOumGCSfviwnzobeZOaIOJx"]
[nil, "svVsIjmbuOBTxhfNCUgBrtoI j"]
[nil, "ZyIqsyTefpdTmqxLzSDDPrMxQf"]
[nil, "nbpmNBYOYcmEGI jbs RxocKzv"]
[nil, "FlsryVrgyaGiciJBUzOfJameCh"]
</code></pre>

<p>Dans le prochain article, on s'occupera d'évaluer cette population de
phrase.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 7]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/06/les-algorithmes-genetiques-demystifies-7/"/>
    <updated>2013-09-06T11:59:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/06/les-algorithmes-genetiques-demystifies-7</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p><a href="http://lkdjiin.github.io/blog/2013/09/05/les-algorithmes-genetiques-demystifies-6/">Hier</a>
on a amélioré l'algorithme grâce à la mutation. C'est mieux mais on
peut encore faire mieux. Aujourd'hui on parle un peu plus en détail de
la sélection et de la diversité génétique.</p>

<!-- more -->


<h2>La sélection</h2>

<p>Voici la méthode de sélection:</p>

<p><code>ruby
def selection
  @selected = @population[0...50].shuffle
end
</code></p>

<p>C'est clair et limpide : on conserve la meilleure moitié de la population.
Mais ça pose des problèmes. Que faire si un gène important pour notre
solution se trouve dans la moitié supprimée ? On a vu hier qu'en <em>théorie</em>
la mutation régle le problème. Mais en <em>pratique</em> on a vu aussi qu'on pouvait
atteindre 10.000 générations sans trouver la solution. Autre problème de
taille : l'individu classé à la 1ère place va produire quatre enfants,
tout comme l'invidu classé à la 50ème place. Pourtant il y a un monde entre
les deux. De même, il y a peu de différence entre la 50ème place et la
51ème, et pourtant l'un se reproduira et pas l'autre. Tout ceci semble assez
bancal et arbitraire. Dans un prochain article on explorera une méthode de
sélection plus <em>naturelle</em>, pour l'instant on va essayer d'augmenter le
nombre d'individus sélectionnés, juste pour voir:</p>

<p><code>ruby
def selection
  @selected = @population[0...80].shuffle
end
</code></p>

<h2>La diversité génétique</h2>

<p>Voici la méthode utilisée hier pour produire une nouvelle génération:</p>

<p>``` ruby
def next_generation
  @selection = selection
  @population = []
  25.times do</p>

<pre><code>parent1, parent2 = @selection.slice!(0, 2)
child1, child2 = crossover(parent1, parent2)
child3, child4 = crossover(parent1, parent2)
@population += [child1, child2, child3, child4]
</code></pre>

<p>  end
end
```</p>

<p>On va la changer ainsi:</p>

<p>``` ruby
def next_generation
  @selection = selection
  @population = []
  40.times do</p>

<pre><code>parent1, parent2 = @selection.slice!(0, 2)
child1, child2 = crossover(parent1, parent2)
@population += [child1, child2]
</code></pre>

<p>  end
  20.times { @population &lt;&lt; make_chromosome }
end
```</p>

<p>Tout d'abord on tient compte du fait que le nombre d'individus sélectionnés
a changé : il est maintenant de 80, on va donc former 40 couples. Ensuite,
chaque couple ne va produire que 2 enfants. Enfin, on complète notre
population avec 20 individus créés au hasard. Ce sont eux qui vont apporter
la diversité génétique qui nous faisait défaut.</p>

<p>J'ai testé plusieurs dizaines de fois, et la solution a toujours été
trouvée avant la 1000ème génération (généralement bien avant).
N'hésitez pas à faire des tests
en modifiant le nombre d'invidus sélectionnés, le taux de mutation,
la taille de la population initiale, etc.</p>

<p>La prochaine fois, j'aimerais trouver un problème (toujours très simple) où
les individus ne seraient pas codés sous forme de bits. Je vais chercher ça.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 6]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/05/les-algorithmes-genetiques-demystifies-6/"/>
    <updated>2013-09-05T13:01:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/05/les-algorithmes-genetiques-demystifies-6</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>La dernière fois on était resté sur un algorithme parfois <em>bloqué</em> par
l'extremum local. Aujourd'hui on arrange cela grâce à la mutation génétique.</p>

<!-- more -->


<p>Tout d'abord un petit mot sur la mutation génétique. Vous voyez peut-être
cela comme de sombres expériences de laboratoire, ou bien vous pensez à
Peter Parker mordu par une araignée radioactive et devenant Spiderman…
En fait, la mutation génétique est un phénomène tout à fait naturel, et
à l'origine de l'évolution des espèces. Pour ce qui nous intéresse ici, on
imaginera que, de temps en temps, un gène est <em>mal recopié</em>, ce qui va se
traduire par une inversion d'un bit dans un chromosome.</p>

<p>Voici la méthode qui est chargée de muter un chromosome:</p>

<p>``` ruby
def mutate(chromosome)
  bit = rand(48)
  value = chromosome.last
  if value[bit] == &ldquo;0&rdquo;</p>

<pre><code>value[bit] = "1"
</code></pre>

<p>  else</p>

<pre><code>value[bit] = "0"
</code></pre>

<p>  end
  [nil, value]
end
```</p>

<p>On sélectionne au hasard un bit parmi les 48 que comporte le chromosome,
puis on l'inverse. Enfin on retourne le nouveau chromosome. Pour voir ce
code à l'oeuvre, on peut écrire ceci:</p>

<p><code>ruby
c = make_chromosome
puts c.inspect
c = mutate(c)
puts c.inspect
</code></p>

<p>On peut voir qu'un bit a été inversé:</p>

<pre><code>[~/genetic]⇒ ruby test.rb 
[nil, "101000101001011110110000011000010000110011011110"]
[nil, "101000101001011110110000011000010000110010011110"]
</code></pre>

<p>Reste à savoir <em>quand</em> muter ? On considère généralement que le bon taux
de mutation se trouve entre 1/1000 et 1/100000. Ce qui nous donne la
méthode suivante:</p>

<p>``` ruby
def mutation
  @population.map do |individual|</p>

<pre><code>if rand(1000) == 0
  mutate(individual)
else
  individual
end
</code></pre>

<p>  end
end
```</p>

<p>Un individu sur 1000 va recevoir une mutation, ce qui va permettre d'apporter
du nouveau matériel génétique et, en théorie, d'éviter de tomber dans un
extremum local. Pour voir ce que ça donne, il faut modifier le code du
dernier article pour appliquer la mutation:</p>

<p>``` ruby
10000.times do |generation|
  score_population
  @population = @population.sort
  best = @population.first.first
  puts &ldquo;Generation: #{generation} Best: #{best}&rdquo;
  if best == 0</p>

<pre><code>genes = chromosome_to_gene(@population.first)
puts "Formula: #{genes_to_formula(genes)}"
exit
</code></pre>

<p>  end
  next_generation
  @population = mutation
end
```</p>

<p>Vous noterez au passage que je suis passé de 50 générations à 10000. Les
algorithmes génétiques n'ont vraiment de sens que sur un grand nombre de
générations. Voyons le résultat:</p>

<pre><code>[~/genetic]⇒ ruby test.rb 
Generation: 0 Best: 39
Generation: 1 Best: 100
Generation: 2 Best: 34
Generation: 3 Best: 88
Generation: 4 Best: 44
Generation: 5 Best: 19
Generation: 6 Best: 105
Generation: 7 Best: 47
Generation: 8 Best: 13
Generation: 9 Best: 13
Generation: 10 Best: 13
Generation: 11 Best: 2
Generation: 12 Best: 1
Generation: 13 Best: 3
Generation: 14 Best: 33
Generation: 15 Best: 19
Generation: 16 Best: 7
Generation: 17 Best: 9
Generation: 18 Best: 1
...
Generation: 465 Best: 1
Generation: 466 Best: 0
Formula: 88-1%3+900
</code></pre>

<p>Ça fonctionne ! Sauf que parfois…</p>

<p>Parfois on atteint la 10.000ème génération sans avoir la solution. Je l'ai
déjà dit et je le répète : un algorithme génétique ne peut pas garantir
que l'on trouvera la meilleure solution. Le problème avec notre algorithme
(dont je donne le code complet à la fin de l'article) tient sûrement dans
sa méthode de sélection ainsi que dans la manière dont on produit une
nouvelle génération. Il serait intéressant de voir ce qu'il se passe
en introduisant du sang frais, c'est à dire quelques individus produits
au hasard. Peut-être le sujet d'un prochain article ?</p>

<h2>Le code source entier</h2>

<p>``` ruby
def make_chromosome
  value = &ldquo;&rdquo;
  48.times { value += rand(0..1).to_s }
  [nil, value]
end</p>

<p>def make_population
  population = []
  100.times { population &lt;&lt; make_chromosome }
  population
end</p>

<p>def chromosome_to_gene(chromosome)
  chromosome.last.scan /.{4}/
end</p>

<p>def gene_to_operand(gene)
  case gene
  when &ldquo;0000&rdquo; then 0
  when &ldquo;0001&rdquo; then 1
  when &ldquo;0010&rdquo; then 2
  when &ldquo;0011&rdquo; then 3
  when &ldquo;0100&rdquo; then 4
  when &ldquo;0101&rdquo; then 5
  when &ldquo;0110&rdquo; then 6
  when &ldquo;0111&rdquo; then 7
  when &ldquo;1000&rdquo; then 8
  when &ldquo;1001&rdquo; then 9
  when &ldquo;1010&rdquo; then &ldquo;+&rdquo;
  when &ldquo;1011&rdquo; then &ldquo;&ndash;&rdquo;
  when &ldquo;1100&rdquo; then &ldquo;/&rdquo;
  when &ldquo;1101&rdquo; then &ldquo;%&rdquo;
  end
end</p>

<p>def selection
  @selected = @population[0&hellip;50].shuffle
end</p>

<p>def genes_to_formula(genes)
  formula = []
  genes.each {|gene| formula &lt;&lt; gene_to_operand(gene) }
  formula.join
end</p>

<p>def evaluation(genes)
  formula = genes_to_formula(genes)
  begin</p>

<pre><code>result = (@search_value - eval(formula)).abs
</code></pre>

<p>  rescue Exception</p>

<pre><code>result = 999_999_999_999
</code></pre>

<p>  end
  result = 999_999_999_999 unless result.is_a?(Integer)
  result
end</p>

<p>def score_population
  @population = @population.map do |individual|</p>

<pre><code>genes = chromosome_to_gene(individual)
individual[0] = evaluation(genes)
individual
</code></pre>

<p>  end
end</p>

<p>def crossover(parent1, parent2)
  point = rand(1..47)
  child1 = [nil, parent1.last[0&hellip;point] + parent2.last[point..-1]]
  child2 = [nil, parent2.last[0&hellip;point] + parent1.last[point..-1]]
  [child1, child2]
end</p>

<p>def next_generation
  @selection = selection
  @population = []
  25.times do</p>

<pre><code>parent1, parent2 = @selection.slice!(0, 2)
child1, child2 = crossover(parent1, parent2)
child3, child4 = crossover(parent1, parent2)
@population += [child1, child2, child3, child4]
</code></pre>

<p>  end
end</p>

<p>def mutation
  @population.map do |individual|</p>

<pre><code>if rand(1000) == 0
  mutate(individual)
else
  individual
end
</code></pre>

<p>  end
end</p>

<p>def mutate(chromosome)
  bit = rand(48)
  value = chromosome.last
  if value[bit] == &ldquo;0&rdquo;</p>

<pre><code>value[bit] = "1"
</code></pre>

<p>  else</p>

<pre><code>value[bit] = "0"
</code></pre>

<p>  end
  [nil, value]
end</p>

<p>@search_value = 987
@population = make_population</p>

<p>10000.times do |generation|
  score_population
  @population = @population.sort
  best = @population.first.first
  puts &ldquo;Generation: #{generation} Best: #{best}&rdquo;
  if best == 0</p>

<pre><code>genes = chromosome_to_gene(@population.first)
puts "Formula: #{genes_to_formula(genes)}"
exit
</code></pre>

<p>  end
  next_generation
  @population = mutation
end
```</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 5]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/03/les-algorithmes-genetiques-demystifies-5/"/>
    <updated>2013-09-03T08:43:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/03/les-algorithmes-genetiques-demystifies-5</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Maintenant qu'on sait créer une population de solutions, l'évaluer,
opérer une sélection des meilleures solutions et obtenir une nouvelle
génération par la reproduction, il reste à assembler toutes ces parties
et voir ce qu'il se passe…</p>

<!-- more -->


<p>Voici le code complet de notre algorithme:</p>

<p>``` ruby
def make_chromosome
  value = &ldquo;&rdquo;
  48.times { value += rand(0..1).to_s }
  [nil, value]
end</p>

<p>def make_population
  population = []
  100.times { population &lt;&lt; make_chromosome }
  population
end</p>

<p>def chromosome_to_gene(chromosome)
  chromosome.last.scan /.{4}/
end</p>

<p>def gene_to_operand(gene)
  case gene
  when &ldquo;0000&rdquo; then 0
  when &ldquo;0001&rdquo; then 1
  when &ldquo;0010&rdquo; then 2
  when &ldquo;0011&rdquo; then 3
  when &ldquo;0100&rdquo; then 4
  when &ldquo;0101&rdquo; then 5
  when &ldquo;0110&rdquo; then 6
  when &ldquo;0111&rdquo; then 7
  when &ldquo;1000&rdquo; then 8
  when &ldquo;1001&rdquo; then 9
  when &ldquo;1010&rdquo; then &ldquo;+&rdquo;
  when &ldquo;1011&rdquo; then &ldquo;&ndash;&rdquo;
  when &ldquo;1100&rdquo; then &ldquo;/&rdquo;
  when &ldquo;1101&rdquo; then &ldquo;%&rdquo;
  end
end</p>

<p>def selection
  @selected = @population[0&hellip;50].shuffle
end</p>

<p>def genes_to_formula(genes)
  formula = []
  genes.each {|gene| formula &lt;&lt; gene_to_operand(gene) }
  formula.join
end</p>

<p>def evaluation(genes)
  formula = genes_to_formula(genes)
  begin</p>

<pre><code>result = (@search_value - eval(formula)).abs
</code></pre>

<p>  rescue Exception</p>

<pre><code>result = 999_999_999_999
</code></pre>

<p>  end
  result = 999_999_999_999 unless result.is_a?(Integer)
  result
end</p>

<p>def score_population
  @population = @population.map do |individual|</p>

<pre><code>genes = chromosome_to_gene(individual)
individual[0] = evaluation(genes)
individual
</code></pre>

<p>  end
end</p>

<p>def crossover(parent1, parent2)
  point = rand(1..47)
  child1 = [nil, parent1.last[0&hellip;point] + parent2.last[point..-1]]
  child2 = [nil, parent2.last[0&hellip;point] + parent1.last[point..-1]]
  [child1, child2]
end</p>

<p>def next_generation
  @selection = selection
  @population = []
  25.times do</p>

<pre><code>parent1, parent2 = @selection.slice!(0, 2)
child1, child2 = crossover(parent1, parent2)
child3, child4 = crossover(parent1, parent2)
@population += [child1, child2, child3, child4]
</code></pre>

<p>  end
end</p>

<h1>Ce qui suit est nouveau:</h1>

<p>@search_value = 987
@population = make_population</p>

<p>50.times do |generation|
  score_population
  @population = @population.sort
  best = @population.first.first
  puts &ldquo;Generation: #{generation} Best: #{best}&rdquo;
  exit if best == 0
  next_generation
end
```</p>

<p>Seules les dernières lignes de code sont nouvelles. Elles sont assez
simple à comprendre je pense, même si vous ne connaissez pas le
langage Ruby. On commence par définir le nombre qu'on recherche puis
on crée la population d'origine au hasard avec <code>@population = make_population</code>.
Ensuite on itère sur 50 générations avec <code>50.times do |generation|</code>. C'est
notre première condition de sortie : quoiqu'il se passe, on arrête le
traitement au bout à la 50ème génération. Dans cette boucle on évalue
la génération en cours avec <code>score_population</code> et on la trie. Pour savoir
où on en est visuellement on extrait le meilleur score avec
<code>best = @population.first.first</code> et on affiche cette information à la ligne
suivante. Vient ensuite notre seconde et dernière condition de sortie avec
<code>exit if best == 0</code> ; autrement dit on stoppe le traitement à la première
solution trouvée. Pour finir, on produit la génération suivante avec
<code>next_generation</code>.</p>

<h2>Et ça donne quoi ?</h2>

<p>La plupart du temps ça donne quelque chose comme ça:</p>

<p><code>console
[~/genetic]⇒ ruby test.rb
Generation: 0 Best: 507
Generation: 1 Best: 138
Generation: 2 Best: 485
Generation: 3 Best: 347
Generation: 4 Best: 65
Generation: 5 Best: 208
Generation: 6 Best: 222
Generation: 7 Best: 15
Generation: 8 Best: 15
Generation: 9 Best: 2
Generation: 10 Best: 0
</code></p>

<p>Les générations successives convergent lentement vers la solution.
Si vous voulez voir la solution trouvée (c'est normal d'être curieux)
vous pouvez remplacez une ligne de code pour afficher la solution:</p>

<p>``` ruby</p>

<h1>exit if best == 0</h1>

<p>if best == 0
  genes = chromosome_to_gene(@population.first)
  puts &ldquo;Formula: #{genes_to_formula(genes)}&rdquo;
  exit
end
```</p>

<p>Voici quelques exemples de solutions:</p>

<pre><code>Formula: 912%429+933
Formula: 670+594-277
Formula: 893+91%96+3
Formula: 923--03--61
</code></pre>

<p>Alors, la plupart du temps, ça se passe bien. Mais parfois un phénomène
étrange se produit:</p>

<p><code>console
[~/genetic]⇒ ruby test.rb
Generation: 0 Best: 597
Generation: 1 Best: 621
Generation: 2 Best: 104
...
Generation: 25 Best: 1
...
Generation: 48 Best: 1
Generation: 49 Best: 1
[~/genetic]⇒
</code></p>

<p>L'algorithme reste <em>bloqué</em> sur une valeur et on atteint la 50ème
génération sans avoir trouver de solution. What the fuck ? Et bien
l'algorithme a atteint ce qu'on appelle
<a href="http://fr.wikipedia.org/wiki/Extremum_local">l'extremum local</a>. Pour faire
court, ça signifie qu'il ne peut pas faire mieux
avec les gènes dont il disposait à l'origine. Je developperais cette
idée dans un futur article. En attendant, comment on règle ça ?
En s'inspirant encore une fois de phénomènes naturels : la mutation
et/ou la diversité génétique.
C'est le sujet du prochain article.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 4]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/02/les-algorithmes-genetiques-demystifies-4/"/>
    <updated>2013-09-02T08:26:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/02/les-algorithmes-genetiques-demystifies-4</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Après en avoir terminer avec la création de la population et la sélection,
on passe à la reproduction.</p>

<!-- more -->


<p>Pour imiter ce qu'il se passe dans la nature, de manière fort simple,
on va définir une fonction <code>crossover</code> (croisé, croisement) qui prend
en entrée deux chromosomes, les parents, et qui produit en sortie une liste
de deux autres chromosomes, les enfants. Le principe est de couper chaque
chromosomes parents en deux parties A et B, puis d'assembler la partie A
du parent 1 avec la partie B du parent 2 et vice-versa. Voici une illustration
du processus avec des chromosomes de 8 bits (symbolisés par des lettres):</p>

<pre><code>parent1  aaabbbbb
parent2  xxxyyyyy

enfant1  aaayyyyy
enfant2  xxxbbbbb
</code></pre>

<p>Voici donc la fonction:</p>

<p><code>ruby
def crossover(parent1, parent2)
  point = rand(1..47)
  child1 = [nil, parent1.last[0...point] + parent2.last[point..-1]]
  child2 = [nil, parent2.last[0...point] + parent1.last[point..-1]]
  [child1, child2]
end
</code></p>

<p>Tout d'abord on défini le point de croisement avec <code>point = rand(1..47)</code>.
Puis on assemble les deux chromosomes enfants et on les renvoient sous
la forme d'une liste. Ce mode de reproduction est le plus simple, mais
pas forcement le plus efficace (on en reparle un autre jour).</p>

<p>On a maintenant tout ce qu'il faut pour produire la génération suivante:</p>

<p>``` ruby
def next_generation
  @selection = selection
  @population = []
  25.times do</p>

<pre><code>parent1, parent2 = @selection.slice!(0, 2)
child1, child2 = crossover(parent1, parent2)
child3, child4 = crossover(parent1, parent2)
@population += [child1, child2, child3, child4]
</code></pre>

<p>  end
end
```</p>

<p>Après avoir sélectionné les 50 meilleures solutions (voir
<a href="http://lkdjiin.github.io/blog/2013/08/30/les-algorithmes-genetiques-demystifies-3/">article précédent</a>) je crée une nouvelle population : Avec 50
individus on forme 25 couples qui vont chacun produire 4 enfants et
on retrouve une population de 100 solutions, sensée être globalement
meilleure que la génération précédente.</p>

<p>Même si c'est peu représentatif des phénomènes naturels, dans un algorithme
génétique les générations successives restent généralement stable en taille.
Ça évite aussi bien la croissance infinie (mémoire des ordinateurs limitée)
que le dépérissement de la population.</p>

<p>La prochaine fois on assemblera le tout pour voir notre algorithme
génétique à l'oeuvre.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
